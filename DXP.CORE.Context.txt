# DOCUMENTACIÓN: DXP.CORE.Context.txt - 2/6/2026 9:57:30 PM
### FILE: src\DXP.Core.Database.Domain\OnboardingData.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain;

public class OnboardingData
{
    public GeneralInfo GeneralInfo { get; set; } // Información general del usuario
    public DocumentInfo DocumentInfo { get; set; } // Información del documento del usuario
    public WorkInfo WorkInfo { get; set; } // Información laboral del usuario
    public KycInfo KycInfo { get; set; } // Información KYC (Conozca a su cliente) del usuario
    public string? TaskToken { get; set; } // The token that identifies the process
    public Dictionary<string, DynamicFieldData> AdditionalFields { get; set; } // Información complementaria específica por país

    // Constructor para inicializar las propiedades
    public OnboardingData()
    {
        GeneralInfo = new GeneralInfo();
        DocumentInfo = new DocumentInfo();
        WorkInfo = new WorkInfo();
        KycInfo = new KycInfo();
        TaskToken = string.Empty;
        AdditionalFields = new Dictionary<string, DynamicFieldData>();
    }
}

// Clase para la información general del usuario
public class GeneralInfo
{
    public string? PersonHash { get; set; } // Hash de la persona en People en caso de cliente existente
    public string? FirstName { get; set; } // Primer nombre del usuario
    public string? SecondName { get; set; } // Segundo nombre del usuario
    public string? LastName { get; set; } // Apellido paterno del usuario
    public string? SecondLastName { get; set; } // Apellido materno del usuario
    public string? UserName { get; set; } // El nombre de usuario
    public DateTime DateOfBirth { get; set; } // Fecha de nacimiento del usuario
    public string? Gender { get; set; } // Género del usuario (ej. Masculino, Femenino)
    public bool IsExistingCustomer { get; set; } // Indica si es cliente PS2
    public bool MustCreateProducts { get; set; } // Indica si debe entrar en el flujo de creacion de productos
    public bool MustCreateDebitCard { get; set; } // Indica si se solicita la creacion de la tarjeta de debito
    public bool MustCreatePhysicalCard { get; set; } // Indica si se debe solicitar la creacion de tarjeta fisica (plastico)
    public bool IfCardFailsSendSuccededTrue { get; set; } // Indica si se debe marcar como un exito la creacion de una cuenta apesar de que no se cree tarjeta
    public string? CustomerNumber { get; set; } // Numero de cliente en caso de un usuario existente
    public string? ProfileStatus { get; set; } // Status del perfil (PS0, PS1, PS2)
    public string? AccountNumber { get; set; } // Numero de cuenta en caso de un usuario existente
    public string? IbanNumber { get; set; } // Numero de cuenta Iban en caso de un usuario existente
    public bool IsPep { get; set; } // Indica si el usuario es Persona Expuesta Políticamente (KYC)
    public bool IsPnp { get; set; } // Indica si el usuario es Persona Notariamente Publica (KYC)
    public bool? HasHigherEducation { get; set; } // Indica si el usuario estudió una carrera universitaria
    public string? MaritalStatusCode { get; set; } // Código de estado marital del usuario (ej. Casado, Divorciado)
    public bool? IsResident { get; set; } // Indica si el usuario reside en el país actual
    public AddressInfo ResidenceAddress { get; set; } // Dirección de residencia del usuario si no reside en el país actual
    public string? CurrentCountry { get; set; } // País actual de residencia del usuario
    public string? CountryBirth { get; set; } // País de Nacimiento del usuario.
    public string? Passcode { get; set; } //Código de acceso del usuario.
    public bool HasAcceptedTerms { get; set; } // Indica si el usuario ha aceptado los terminos y condiciones de uso de la app
    public bool HasAcceptedAccountContractTerms { get; set; } // Indica si el usuario ha aceptado los terminos del contrato de creacion de cuenta
    public List<string>? NationalityCodes { get; set; } //Nacionalidades del usuario.
    public SpouseInformation? SpouseInformation { get; set; } // Informacion del conyugue del usuario
    public EconomicInfo EconomicInfo { get; set; } // Información económica del usuario
    public ContactInformation ContactInformation { get; set; } // Información de contacto del usuario
    public CicacInformation? CicacInformation { get; set; } // Informacion CICAC del cliente para Costa Rica
    public CustomerBankInformation CustomerBankInformation { get; set; } // Clase para la informacion bancaria del cliente
    public ProductsInformation? ProductsInformation { get; set; } // Informacion acerca de los productos a crear
    public CustomerReferences[]? CustomerReferences { get; set; } // Referencias personales del usuario
    public EconomicDependent? EconomicDependent { get; set; } // Datos de la persona de quien depende el usuario (de la cual el usuario recibe dinero)
    public AccountBeneficiary? AccountBeneficiary { get; set; } // Datos del beneficiario para la cuenta del usuario
    public SecondNationalityInformation? SecondNationalityInfo { get; set; } // Informacion acerca de la segunda nacionalidad del usuario
    // Constructor para inicializar la fecha de nacimiento por defecto
    public GeneralInfo()
    {
        DateOfBirth = DateTime.MinValue;
        EconomicInfo = new EconomicInfo();
        ContactInformation = new ContactInformation();
        CicacInformation = new CicacInformation();
        ResidenceAddress = new AddressInfo();
        CustomerBankInformation = new CustomerBankInformation();
        ProductsInformation = new ProductsInformation();
        HasAcceptedTerms = false;
        HasAcceptedAccountContractTerms = false;
        CustomerReferences = Array.Empty<CustomerReferences>();
        SpouseInformation = new SpouseInformation();
        EconomicDependent = new EconomicDependent();
        AccountBeneficiary = new AccountBeneficiary();
        SecondNationalityInfo = new SecondNationalityInformation();
    }
}

// Clase para la información del documento del usuario
public class DocumentInfo
{
    public string? DocumentType { get; set; } // Tipo de documento del usuario (ej. Pasaporte, Cédula)
    public string? DocumentNumber { get; set; } // Número de documento del usuario
    public DateTime? IdentificationIssueDate { get; set; } // Fecha de emisión del documento de identificación
    public string? CountryOfIssuance { get; set; } // País de emisión del documento
    public DateTime ExpiryDate { get; set; } // Fecha de expiración del documento

    // Constructor para inicializar las fechas por defecto
    public DocumentInfo()
    {
        IdentificationIssueDate = null;
        ExpiryDate = DateTime.MinValue;
    }
}

// Clase para la información de dirección del usuario
public class AddressInfo
{
    public string? AddressLine1 { get; set; } // Línea de dirección 1
    public string? AddressLine2 { get; set; } // Línea de dirección 2 (opcional)
    public string? AdministrativeDivision1Code { get; set; } // División administrativa 1 (ej. Provincia, Departamento, Estado) : AdministrativeDivision1 = "San José", SJ
    public string? AdministrativeDivision2Code { get; set; } // División administrativa 2 (ej. Cantón, Municipio, Distrito, Condado) : AdministrativeDivision2 = "Cantón Central",  CC
    public string? AdministrativeDivision3Code { get; set; } // División administrativa 3 (ej. Distrito, Ciudad, Pueblo, Aldea): AdministrativeDivision3 = "Escazú",EZ
    public string? AdministrativeDivision4Code { get; set; } // División administrativa 4
    public string? PostalCode { get; set; } // Código postal
    public string? CountryCode { get; set; } // País ej:CR
    public string? ResidenceStreet { get; set; } // Calle de residencia
    public string? ResidenceBuilding { get; set; } //Edificio de residencia
    public string? ResidenceApartmentNumber { get; set; } //Número de apartamento

    // Constructor por defecto
    public AddressInfo()
    {
        AddressLine1 = string.Empty;
        AddressLine2 = string.Empty;
        AdministrativeDivision1Code = string.Empty;
        AdministrativeDivision2Code = string.Empty;
        AdministrativeDivision3Code = string.Empty;
        AdministrativeDivision4Code = string.Empty;
        PostalCode = string.Empty;
        CountryCode = string.Empty;
        ResidenceStreet = string.Empty;
        ResidenceBuilding = string.Empty;
        ResidenceApartmentNumber = string.Empty;
    }
}

// Clase para la información laboral del usuario
public class WorkInfo
{
    public bool CurrentlyEmployed { get; set; } // Indica si el usuario está actualmente empleado
    public bool IsSelfEmployed { get; set; } // Indica si el usuario trabaja por cuenta propia
    public EmploymentStatus EmploymentStatus { get; set; } // Estado de empleo
    public string? EmployerName { get; set; } // Nombre del empleador
    public string? JobTitle { get; set; } // Cargo o puesto de trabajo
    public string? CompanyActivity { get; set; } // Actividad económica de la empresa
    public string? BusinessActivityCode { get; set; } // Actividad económica de la empresa cuando es cliente asalariado
    public string? CompanyPhonePrefix { get; set; } //Prefijo del número de teléfono del lugar de trabajo
    public string? CompanyPhone { get; set; } // Teléfono de la empresa
    public CompanyType? CompanyType { get; set; } // Empresa privada o publica
    public string? WorkAddress { get; set; } // Direccion detallada de la empresa
    public string? GeographicLocationCode { get; set; } // Codigo de catalogo de ubicacion geografica de la empresa
    public DateTime? StartDate { get; set; } // Fecha de inicio de labores en la empresa
    public string? CorporatePositionCode { get; set; } // Catalogo de Posicion Corporativa
    public int? WorkTimeYears { get; set; } // Cantidad de años de laborar en la empresa

    // Constructor para inicializar valores por defecto
    public WorkInfo()
    {
        CurrentlyEmployed = false;
        EmploymentStatus = EmploymentStatus.Unemployed; // Por defecto, no empleado
        IsSelfEmployed = false; // Inicialmente no es trabajador por cuenta propia
    }
}

// Clase para la información KYC (Conozca a su cliente) del usuario
public class KycInfo
{
    public bool IsFatca { get; set; } // Indica si el usuario está sujeto a FATCA
    public bool IsForeignerTaxPayer { get; set; } // Indica si el usuario es contribuyente extranjero

    // Constructor para inicializar valores por defecto
    public KycInfo()
    {
        IsFatca = false;
        IsForeignerTaxPayer = false;
    }
}

// Clase para la información económica del usuario
public class EconomicInfo
{
    public string? OccupationCode { get; set; } // Ocupación del usuario
    public string? EconomicSector { get; set; } // Sector económico del usuario
    public string? SourceOfFunds { get; set; } // Origen de fondos del usuario
    public decimal? IncomeAmount { get; set; } // Monto de ingresos del usuario
    public string? SymbolOfAmount { get; set; } // Simbolo de la moneda del monto de ingresos
    public string? EconomicActivityCode { get; set; } // Codigo de la actividad economica del usuario - core_code del catalogo EconomicActivity
    public string? ProfessionCode { get; set; } // Código de la profesión del usuario
    // Constructor para inicializar valores por defecto
    public EconomicInfo()
    {
        IncomeAmount = 0;
        SymbolOfAmount = string.Empty;
        OccupationCode = string.Empty;
        EconomicSector = string.Empty;
        SourceOfFunds = string.Empty;
        ProfessionCode = string.Empty;
        EconomicActivityCode = string.Empty;
    }
}

// Clase para la información de contacto del usuario
public class ContactInformation
{
    public string? Email { get; set; } // Correo electrónico del usuario
    public string? PhoneNumber { get; set; } // Número de teléfono del usuario
    public string? PhonePrefix { get; set; } //Prefijo del número de teléfono del usuario
    public string? TelephoneNumber { get; set; } // Número telefónico adicional del usuario
}

// Clase para la informacion CICAC del cliente para Costa Rica
public class CicacInformation
{
    public bool ConsultationInCicac { get; set; } // Indica si se ha realizado una consulta en CICAC
    public string? AnotherReasonCicac { get; set; } // Registrar una razón adicional 
    public string? ReasonDeclineCicacCode { get; set; } // Código que explique por qué se rechazó la solicitud   
    public bool? HasCitizenshipInCrsCountries { get; set; }
    public List<string>? CountriesTaxes { get; set; } = new List<string>();
    public bool? AcceptCicacDisclaimer { get; set; }
    public int CicacRejectionCode { get; set; } = 0;
    public string? EconomicActivityCicac { get; set; } // Actividad económica según CICAC

    //Constructor para inicializar valores por defecto
    public CicacInformation()
    {
        ConsultationInCicac = false;
    }
}

// Clase para la informacion bancaria del cliente
public class CustomerBankInformation
{
    public string? BranchCode { get; set; } // Codigo de la sucursal
    public string? LastUser { get; set; } // Ultimo usuario
    public string? OfficialCode { get; set; } // Codigo de usuario
    public string? SubOfficialCode { get; set; } // Codigo de suboficial
    public string? OfficialName { get; set; } //Nombre del Oficial
    public string? SubOfficialName { get; set; } //Nombre del Suboficial
    public string? CampaingId { get; set; } // The campaing id for salesforces
    public string? Referenced { get; set; }// The customer service representative name
    public string? LinkageTypeCode { get; set; } // Codigo de vinculacion

    //Constructor para inicializar valores por defecto
    public CustomerBankInformation()
    {
        BranchCode = string.Empty;
        LastUser = string.Empty;
        OfficialCode = string.Empty;
        SubOfficialCode = string.Empty;
        OfficialName = string.Empty;
        SubOfficialName = string.Empty;
        Referenced = string.Empty;
        CampaingId = string.Empty;
        LinkageTypeCode = string.Empty;
    }
}

// Clase para la creacion de los productos del usuario
public class ProductsInformation
{
    public AccountInformation? AccountInformation { get; set; } // Informacion requerida para la creacion de la cuenta
    public DebitCardInformation? DebitCardInformation { get; set; } // Informacion requerida para la creacion de la tarjeta

    public ProductsInformation()
    {
        AccountInformation = new AccountInformation();
        DebitCardInformation = new DebitCardInformation();
    }
}

// Clase para la informacion requerida para la creacion de la cuenta
public class AccountInformation
{
    public string? ProductCode { get; set; } // Codigo de producto para aperturar la cuenta
    public string? CurrencyCode { get; set; } // Codigo de moneda de la cuenta (NIO, USD)
    public string? CostCenter { get; set; } // Centro de costo asociado a la cuenta
    public decimal OpeningAmount { get; set; } // Monto de apertura de la cuenta
    public string? AccountType { get; set; } // Tipo de cuenta
    public string? Status { get; set; } // Status
    public string? GeneralLedgerAccount { get; set; } // Cuenta de libro mayor general
    public string? AccountInstructions { get; set; } // Instrucciones al crear la cuenta
    public string? AccountPurpose { get; set; } // Proposito de creacion de la cuenta
    public string? OpeningReasonCode { get; set; } // Codigo de apertura
    public string? OpeningModeCode { get; set; } //  Codigo de Modo de apertura
    public string? AccountUsageCode { get; set; } // Codigo de uso de la cuenta
    public string? FundsSourceCode { get; set; } // Codigo de origen de fondos
    public int CashDepositsCount { get; set; } // Cantidad de créditos
    public decimal CashDepositsAmount { get; set; } // Monto crédito
    public int CashWithdrawCount { get; set; } // Cantidad de débitos
    public decimal CashWithdrawAmount { get; set; } // Monto de débitos
    public string? IndustryCode { get; set; } // Código de industria
    public int AccountClassificationCode { get; set; } // Código de clasificación de cuenta
    public string? ResidenceCountry { get; set; } // País de residencia
    public string? CountryRisk { get; set; } // País de riesgo
    public string? ChgDay { get; set; } // O/D S/C CHG DAY
    public string? FrequencyCharges { get; set; } // Frecuencia de cargos
    public string? EconomicActivityCode { get; set; } // Código de actividad económica 
    public string? AccountStatementDay { get; set; } // Día estado de cuenta
    public string? AccountStatementFrequency { get; set; } // Frecuencia del estado de cuenta
    public bool ServiceChargeFlag { get; set; } // Bandera de cargo por servicio
    public bool ServiceCharge { get; set; } // Cargo por servicio
    public bool InterestRetention { get; set; } // Retención de intereses
    public string? LineNumber { get; set; } // Número de Línea
    public string? BasedOnNetGrs { get; set; } // Balance used G/N
    public string? MonthlyVolumeCode { get; set; } // Monthly Volume Code

    public AccountInformation()
    {
        ProductCode = string.Empty;
        CurrencyCode = string.Empty;
        CostCenter = string.Empty;
        OpeningAmount = 0;
        AccountType = string.Empty;
        Status = string.Empty;
        GeneralLedgerAccount = string.Empty;
        AccountInstructions = string.Empty;
        AccountPurpose = string.Empty;
        OpeningReasonCode = string.Empty;
        OpeningModeCode = string.Empty;
        AccountUsageCode = string.Empty;
        FundsSourceCode = string.Empty;
        CashDepositsCount = 0;
        CashDepositsAmount = 0;
        CashWithdrawCount = 0;
        CashWithdrawAmount = 0;
        IndustryCode = string.Empty;
        AccountClassificationCode = 0;
        ResidenceCountry = string.Empty;
        CountryRisk = string.Empty;
        ChgDay = string.Empty;
        FrequencyCharges = string.Empty;
        EconomicActivityCode = string.Empty;
        AccountStatementDay = string.Empty;
        AccountStatementFrequency = string.Empty;
        ServiceChargeFlag = false;
        ServiceCharge = false;
        InterestRetention = false;
        LineNumber = string.Empty;
        BasedOnNetGrs = string.Empty;
        MonthlyVolumeCode = string.Empty;
    }
}

// Clase para la informacion requerida para la creacion de la tarjeta
public class DebitCardInformation
{
    public string? NameOnCard { get; set; } // El nombre que aparece en la tarjeta de debito fisica
    public string? ProductCode { get; set; } // Codigo del producto
    public string? AccountOfficer { get; set; } // Oficial de la cuenta
    public string? AccountOfficerCostCenter { get; set; } //
    public string? AffinityGroup { get; set; } // 
    public CardShippingInformation? ShippingInformation { get; set; } // Informacion para el envío de la tarjeta
    public string? AttedantAccountOfficer { get; set; } //
    public bool AllowReceiveStatementViaEmail { get; set; } // Permitir recibir estado de cuenta por correo electrónico

    public DebitCardInformation()
    {
        NameOnCard = string.Empty;
        ProductCode = string.Empty;
        AccountOfficer = string.Empty;
        AccountOfficerCostCenter = string.Empty;
        AffinityGroup = string.Empty;
        AttedantAccountOfficer = string.Empty;
        AllowReceiveStatementViaEmail = false;
        ShippingInformation = new CardShippingInformation();
    }

}

// Clase para la informacion para el envío de la tarjeta
public class CardShippingInformation
{
    public string? ShippingForm { get; set; } // Forma de envío
    public string? City { get; set; } // Ciudad
    public string? Address { get; set; } // Direccion
    public string? Branch { get; set; } // Sucursal
    public bool IsInSameCountry { get; set; } // Si es en el mismo pais

    public CardShippingInformation()
    {
        ShippingForm = string.Empty;
        City = string.Empty;
        Address = string.Empty;
        Branch = string.Empty;
        IsInSameCountry = false;
    }
}

// Clase para los datos de referencias del usuario
public class CustomerReferences
{
    public string? FullName { get; set; } // Nombre Completo de la persona referenciada

    public string? Phone { get; set; } // Telefono de la persona referenciada

    public CustomerReferences()
    {
        FullName = string.Empty;
        Phone = string.Empty;
    }
}

// Clase para los datos de la persona de quien depende el usuario
public class EconomicDependent
{
    public string? FullName { set; get; }
    public string? IdentificationNumber { get; set; }
    public double? MonthlyIncome { get; set; }
    public string? EconomicActivityCode { get; set; }
    public string? Relation { get; set; }
}

// Clase para los datos del beneficiario de la cuenta del  usuario
public class AccountBeneficiary
{
    public string? FullName { set; get; }
    public string? Relationship { set; get; }
    public string? IdentificationNumber { set; get; }
}

// Clase para los datos del conyugue del usuario
public class SpouseInformation
{
    public string? FullName { get; set; }
    public string? IdentificationNumber { get; set; }
    public string? IdentificationTypeCode { get; set; }
    public string? CellPhone { get; set; }
}

public class SecondNationalityInformation
{
    public bool? HasSecondNationality { get; set; }
    public string? SecondNationalityCode { get; set; }
    public string? DocumentTypeCode { get; set; }
    public string? FrontIdentificationImage { get; set; }
    public string? BackIdentificationImage { get; set; }
}

// Clase para almacenar información dinámica adicional
public class DynamicFieldData
{
    public string FieldName { get; set; } // Nombre del campo
    public object FieldValue { get; set; } // Valor del campo
    public string FieldType { get; set; } // Tipo de dato del campo (opcional para referencia)

    // Constructor para inicializar las propiedades
    public DynamicFieldData(string fieldName, object fieldValue, string fieldType)
    {
        FieldName = fieldName;
        FieldValue = fieldValue;
        FieldType = fieldType;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\ConfigureServices.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Application.Common.Interfaces;
using DXP.Core.Application.Common.Managers;
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Constants;
using DXP.Core.Database.Infrastructure.Cache;
using DXP.Core.Database.Infrastructure.Common;
using DXP.Core.Database.Infrastructure.Persistence;
using DXP.Core.Database.Infrastructure.Persistence.Interceptors;
using DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories;
using DXP.Core.Database.Infrastructure.Persistence.Repositories;
using EasyCaching.Core.Configurations;
using EasyCaching.Redis;
using EasyCaching.Serialization.SystemTextJson.Configurations;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using Microsoft.AspNetCore.Http.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Npgsql;

namespace DXP.Core.Database.Infrastructure
{
    public static class ConfigureServices
    {
        public static IServiceCollection AddDatabaseServices(this IServiceCollection services, string connectionString,
            IConfiguration configuration, string readOnlyConnectionString, bool useReadReplica = false)
        {
            var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);

            // Map Enums
            dataSourceBuilder.MapEnumsToDataSource();
            NpgsqlDataSource dataSource = dataSourceBuilder.Build();
            NpgsqlDataSource readDataSource = dataSource;

            if (useReadReplica)
            {
                var readDataSourceBuilder = new NpgsqlDataSourceBuilder(readOnlyConnectionString);
                readDataSourceBuilder.MapEnumsToDataSource();
                readDataSource = readDataSourceBuilder.Build();
            }

            // Add Interceptors
            services.AddScoped<IInterceptor>(_ => new AuditableEntitySaveChangesInterceptor());
            services.AddScoped<IInterceptor>(_ => new SoftDeleteInterceptor());

            // Add DbContext
            services.AddDbContext<PostgresContext>(optionsBuilder =>
            {
                optionsBuilder.UseNpgsql(dataSource).AddXRayInterceptor(true);
            });

            // Add Read Only DbContext
            services.AddDbContext<ReadPostgresContext>(optionsBuilder =>
            {
                optionsBuilder.UseNpgsql(readDataSource).AddXRayInterceptor(true);
            });

            // Add readonly dapper context
            services.AddSingleton(new DapperContext(readOnlyConnectionString));

            // Register Repositories
            services.AddScoped<IAppScreenRepository, AppScreenRepository>();
            services.AddScoped<IAppSectionCatalogRepository, AppSectionCatalogRepository>();
            services.AddScoped<IDeviceRepository, DeviceRepository>();
            services.AddScoped<IKycRepository, KycRepository>();
            services.AddScoped<IOnboardingHistoryRepository, OnboardingHistoryRepository>();
            services.AddScoped<IOnboardingRepository, OnboardingRepository>();
            services.AddScoped<IOtpRepository, OtpRepository>();
            services.AddScoped<IUserFavoriteFunctionalityRepository, UserFavoriteFunctionalityRepository>();
            services.AddScoped<IUserRepository, UserRepository>();
            services.AddScoped<IBankRepository, BankRepository>();
            services.AddScoped<INotificationConfigRepository, NotificationConfigRepository>();
            services.AddScoped<INotificationRepository, NotificationRepository>();
            services.AddScoped<INotificationHistoryRepository, NotificationHistoryRepository>();
            services.AddScoped<IAppResourceRepository, AppResourceRepository>();
            services.AddScoped<ICountryBankRepository, CountryBankRepository>();
            services.AddScoped<IProfileRepository, UserProfileRepository>();
            services.AddScoped<IUserRequestRepository, UserRequestRepository>();
            services.AddScoped<IAccountTypeRepository, AccountTypeRepository>();
            services.AddScoped<IFavoritesRepository, FavoritesRepository>();
            services.AddScoped<IUserProductRepository, UserProductRepository>();
            services.AddScoped<IUserSubProductRepository, UserSubProductRepository>();
            services.AddScoped<IFunctionalityRepository, FunctionalityRepository>();
            services.AddScoped<IUserFunctionalityRepository, UserFunctionalityRepository>();
            services.AddScoped<ITransactionRepository, TransactionRepository>();
            services.AddScoped<INotificationTextsRepository, NotificationTextsRepository>();
            services.AddScoped<IFrequentlyQuestionsRepository, FrequentlyQuestionsRepository>();
            services.AddScoped<IFrequentlyQuestionsDetailRepository, FrequentlyQuestionsDetailRepository>();
            services.AddScoped<IUserTutorialsRepository, UserTutorialsRepository>();
            services.AddScoped<INotificationTextsDetailRepository, NotificationTextsDetailRepository>();
            services.AddScoped<ITutorialsRepository, TutorialsRepository>();
            services.AddScoped<IProfileAddressRepository, ProfileAddressRepository>();
            services.AddScoped<IBiometricAccountRepository, BiometricAccountRepository>();
            services.AddScoped<IUserFailedAttemptRepository, UserFailedAttemptRepository>();
            services.AddScoped<IAppVersionRepository, AppVersionRepository>();
            services.AddScoped<IAppVersionDetailRepository, AppVersionDetailRepository>();
            services.AddScoped<IUserTransactionConditionRepository, UserTransactionConditionRepository>();
            services.AddScoped<IAdvertisingRepository, AdvertisingRepository>();
            services.AddScoped<IAdvertisingDetailRepository, AdvertisingDetailRepository>();
            services.AddScoped<IQuickActionRepository, QuickActionRepository>();
            services.AddScoped<IUserQuickActionRepository, UserQuickActionRepository>();
            services.AddScoped<ITransferMethodRepository, TransferMethodRepository>();
            services.AddScoped<ITransferMethodCurrencyRepository, TransferMethodCurrencyRepository>();
            services.AddScoped<ITransferMethodProductTypeRepository, TransferMethodProductTypeRepository>();
            services.AddScoped<ICountryBankProductTypeConfigRepository, CountryBankProductTypeConfigRepository>();
            services.AddScoped<ITutorialProgressRepository, TutorialProgressRepository>();
            services.AddScoped<ITutorialActionRepository, TutorialActionRepository>();
            services.AddScoped<IUserConditionRepository, UserConditionRepository>();
            services.AddScoped<ITermsAndConditionsRepository, TermsAndConditionsRepository>();
            services.AddScoped<IUiGroupRepository, UiGroupRepository>();
            services.AddScoped<IOptionItemRepository, OptionItemRepository>();
            services.AddScoped<IUserOptionItemRepository, UserOptionItemRepository>();
            services.AddScoped<IFailedOpportunityRepository, FailedOpportunityRepository>();

            services.AddScoped<IFunFactRepository, FunFactRepository>();
            services.AddScoped<IFunFactDetailRepository, FunFactDetailRepository>();
            services.AddScoped<IUserFeatureStateRepository, UserFeatureStateRepository>();

            // Readonly repositories
            services.AddScoped<IROOnboardingRepository, ROOnboardingRepository>();
            services.AddScoped<IROUserRepository, ROUserRepository>();
            services.AddScoped<IROBankRepository, ROBankRepository>();
            services.AddScoped<IROAppVersionRepository, ROAppVersionRepository>();
            services.AddScoped<IROAdvertisingRepository, ROAdvertisingRepository>();
            services.AddScoped<IROUserProfileRepository, ROUserProfileRepository>();
            services.AddScoped<IROAppResourceRepository, ROAppResourceRepository>();
            services.AddScoped<IROTutorialsRepository, ROTutorialsRepository>();
            services.AddScoped<IROUserRequestRepository, ROUserRequestRepository>();
            services.AddScoped<IROCountryBankRepository, ROCountryBankRepository>();
            services.AddScoped<IROCountryBankProductTypeConfigRepository, ROCountryBankProductTypeConfigRepository>();
            services.AddScoped<IROTransferMethodCurrencyRepository, ROTransferMethodCurrencyRepository>();
            services.AddScoped<IROTransferMethodProductTypeRepository, ROTransferMethodProductTypeRepository>();
            services.AddScoped<IROTransferMethodRepository, ROTransferMethodRepository>();
            services.AddScoped<IROTutorialProgressRepository, ROTutorialProgressRepository>();
            services.AddScoped<IROAccountTypeRepository, ROAccountTypeRepository>();
            services.AddScoped<IROOtpRepository, ROOtpRepository>();
            services.AddScoped<IROTermsAndConditionsRepository, ROTermsAndConditionsRepository>();
            services.AddScoped<IROAdvertisingDetailRepository, ROAdvertisingDetailRepository>();
            services.AddScoped<IROAppScreenRepository, ROAppScreenRepository>();
            services.AddScoped<IROAppSectionCatalogRepository, ROAppSectionCatalogRepository>();
            services.AddScoped<IROFunFactDetailRepository, ROFunFactDetailRepository>();
            services.AddScoped<IRONotificationTextDetailRepository, RONotificationTextDetailRepository>();
            services.AddScoped<IROTutorialActionRepository, ROTutorialActionRepository>();
            services.AddScoped<IROUiGroupRepository, ROUiGroupRepository>();
            services.AddScoped<IROUserConditionRepository, ROUserConditionRepository>();
            services.AddScoped<IROUserFailedAttemptRepository, ROUserFailedAttemptRepository>();
            services.AddScoped<IROUserTransactionConditionRepository, ROUserTransactionConditionRepository>();
            services.AddScoped<IRODeviceRepository, RODeviceRepository>();
            services.AddScoped<IROFavoritesRepository, ROFavoritesRepository>();
            services.AddScoped<IROFrequentlyQuestionsRepository, ROFrequentlyQuestionsRepository>();
            services.AddScoped<IROFrequentlyQuestionsDetailRepository, ROFrequentlyQuestionsDetailRepository>();
            services.AddScoped<IROFunctionalityRepository, ROFunctionalityRepository>();
            services.AddScoped<IROFunFactRepository, ROFunFactRepository>();
            services.AddScoped<IRONotificationRepository, RONotificationRepository>();
            services.AddScoped<IROOptionItemRepository, ROOptionItemRepository>();
            services.AddScoped<IROProfileAddressRepository, ROProfileAddressRepository>();
            services.AddScoped<IROQuickActionRepository, ROQuickActionRepository>();
            services.AddScoped<IROUserQuickActionRepository, ROUserQuickActionRepository>();
            services.AddScoped<IROAppVersionDetailRepository, ROAppVersionDetailRepository>();
            services.AddScoped<IROBiometricAccountRepository, ROBiometricAccountRepository>();
            services.AddScoped<IROFailedOpportunityRepository, ROFailedOpportunityRepository>();
            services.AddScoped<IROUserFavoriteFunctionalityRepository, ROUserFavoriteFunctionalityRepository>();
            services.AddScoped<IROUserFeatureStateRepository, ROUserFeatureStateRepository>();
            services.AddScoped<IROUserFunctionalityRepository, ROUserFunctionalityRepository>();
            services.AddScoped<IROUserOptionItemRepository, ROUserOptionItemRepository>();
            services.AddScoped<IROUserProductRepository, ROUserProductRepository>();
            services.AddScoped<IROUserSubProductRepository, ROUserSubProductRepository>();
            services.AddScoped<IROUserTutorialsRepository, ROUserTutorialsRepository>();
            services.AddScoped<IROKycRepository, ROKycRepository>();
            services.AddScoped<IRONotificationConfigRepository, RONotificationConfigRepository>();
            services.AddScoped<IRONotificationHistoryRepository, RONotificationHistoryRepository>();
            services.AddScoped<IRONotificationTextsRepository, RONotificationTextsRepository>();
            services.AddScoped<IROOnboardingHistoryRepository, ROOnboardingHistoryRepository>();
            services.AddScoped<IROTransactionRepository, ROTransactionRepository>();

            // Configure RepositorySettings
            services.AddScoped(provider =>
            {
                return new RepositorySettings
                {
                    AppScreens = provider.GetRequiredService<IAppScreenRepository>(),
                    AppSectionCatalogs = provider.GetRequiredService<IAppSectionCatalogRepository>(),
                    Devices = provider.GetRequiredService<IDeviceRepository>(),
                    Onboardings = provider.GetRequiredService<IOnboardingRepository>(),
                    OnboardingHistories = provider.GetRequiredService<IOnboardingHistoryRepository>(),
                    Otps = provider.GetRequiredService<IOtpRepository>(),
                    UserFavoriteFunctionalities = provider.GetRequiredService<IUserFavoriteFunctionalityRepository>(),
                    Users = provider.GetRequiredService<IUserRepository>(),
                    Kycs = provider.GetRequiredService<IKycRepository>(),
                    Banks = provider.GetRequiredService<IBankRepository>(),
                    NotificationConfigs = provider.GetRequiredService<INotificationConfigRepository>(),
                    Notifications = provider.GetRequiredService<INotificationRepository>(),
                    NotificationHistories = provider.GetRequiredService<INotificationHistoryRepository>(),
                    CountryBanks = provider.GetRequiredService<ICountryBankRepository>(),
                    UserProfiles = provider.GetRequiredService<IProfileRepository>(),
                    UserRequests = provider.GetRequiredService<IUserRequestRepository>(),
                    AccountTypes = provider.GetRequiredService<IAccountTypeRepository>(),
                    FavoritesRepository = provider.GetRequiredService<IFavoritesRepository>(),
                    AppResources = provider.GetRequiredService<IAppResourceRepository>(),
                    UserProducts = provider.GetRequiredService<IUserProductRepository>(),
                    UserSubProducts = provider.GetRequiredService<IUserSubProductRepository>(),
                    Functionalities = provider.GetRequiredService<IFunctionalityRepository>(),
                    UserFunctionalities = provider.GetRequiredService<IUserFunctionalityRepository>(),
                    Transactions = provider.GetRequiredService<ITransactionRepository>(),
                    NotificationTexts = provider.GetRequiredService<INotificationTextsRepository>(),
                    FrequentlyQuestions = provider.GetRequiredService<IFrequentlyQuestionsRepository>(),
                    FrequentlyQuestionsDetail = provider.GetRequiredService<IFrequentlyQuestionsDetailRepository>(),
                    UserTutorials = provider.GetRequiredService<IUserTutorialsRepository>(),
                    NotificationTextsDetail = provider.GetRequiredService<INotificationTextsDetailRepository>(),
                    Tutorials = provider.GetRequiredService<ITutorialsRepository>(),
                    ProfileAddress = provider.GetRequiredService<IProfileAddressRepository>(),
                    BiometricAccount = provider.GetRequiredService<IBiometricAccountRepository>(),
                    UserFailedAttempts = provider.GetRequiredService<IUserFailedAttemptRepository>(),
                    AppVersion = provider.GetRequiredService<IAppVersionRepository>(),
                    AppVersionDetail = provider.GetRequiredService<IAppVersionDetailRepository>(),
                    UserTransactionConditions = provider.GetRequiredService<IUserTransactionConditionRepository>(),
                    Advertising = provider.GetRequiredService<IAdvertisingRepository>(),
                    AdvertisingDetail = provider.GetRequiredService<IAdvertisingDetailRepository>(),
                    QuickActions = provider.GetRequiredService<IQuickActionRepository>(),
                    UserQuickActions = provider.GetRequiredService<IUserQuickActionRepository>(),
                    TransferMethods = provider.GetRequiredService<ITransferMethodRepository>(),
                    TransferMethodCurrencies = provider.GetRequiredService<ITransferMethodCurrencyRepository>(),
                    TransferMethodProductTypes = provider.GetRequiredService<ITransferMethodProductTypeRepository>(),
                    CountryBankProductTypeConfigs = provider.GetRequiredService<ICountryBankProductTypeConfigRepository>(),
                    TutorialProgress = provider.GetRequiredService<ITutorialProgressRepository>(),
                    TutorialAction = provider.GetRequiredService<ITutorialActionRepository>(),
                    UserCondition = provider.GetRequiredService<IUserConditionRepository>(),
                    TermsAndConditions = provider.GetRequiredService<ITermsAndConditionsRepository>(),
                    UiGroups = provider.GetRequiredService<IUiGroupRepository>(),
                    OptionItems = provider.GetRequiredService<IOptionItemRepository>(),
                    UserOptionItems = provider.GetRequiredService<IUserOptionItemRepository>(),
                    FailedOpportunity = provider.GetRequiredService<IFailedOpportunityRepository>(),
                    FunFactItems = provider.GetRequiredService<IFunFactRepository>(),
                    FunFactDetailItems = provider.GetRequiredService<IFunFactDetailRepository>(),
                    UserFeatureStates = provider.GetRequiredService<IUserFeatureStateRepository>()
                };
            });

            services.AddScoped(readProvider =>
            {
                return new ReadRepositorySettings
                {
                    Users = readProvider.GetRequiredService<IROUserRepository>(),
                    Banks = readProvider.GetRequiredService<IROBankRepository>(),
                    Advertisings = readProvider.GetRequiredService<IROAdvertisingRepository>(),
                    AppVersions = readProvider.GetRequiredService<IROAppVersionRepository>(),
                    UserProfiles = readProvider.GetRequiredService<IROUserProfileRepository>(),
                    Onboarding = readProvider.GetRequiredService<IROOnboardingRepository>(),
                    Tutorials = readProvider.GetRequiredService<IROTutorialsRepository>(),
                    AppResources = readProvider.GetRequiredService<IROAppResourceRepository>(),
                    UserRequests = readProvider.GetRequiredService<IROUserRequestRepository>(),
                    CountryBanks = readProvider.GetRequiredService<IROCountryBankRepository>(),
                    CountryBankProductTypeConfig = readProvider.GetRequiredService<IROCountryBankProductTypeConfigRepository>(),
                    TransferMethodCurrency = readProvider.GetRequiredService<IROTransferMethodCurrencyRepository>(),
                    TransferMethodProductType = readProvider.GetRequiredService<IROTransferMethodProductTypeRepository>(),
                    TransferMethods = readProvider.GetRequiredService<IROTransferMethodRepository>(),
                    TutorialProgress = readProvider.GetRequiredService<IROTutorialProgressRepository>(),
                    AccountType = readProvider.GetRequiredService<IROAccountTypeRepository>(),
                    Otp = readProvider.GetRequiredService<IROOtpRepository>(),
                    TermsAndConditions = readProvider.GetRequiredService<IROTermsAndConditionsRepository>(),
                    AdvertisingDetails = readProvider.GetRequiredService<IROAdvertisingDetailRepository>(),
                    AppScreens = readProvider.GetRequiredService<IROAppScreenRepository>(),
                    AppSectionCatalogs = readProvider.GetRequiredService<IROAppSectionCatalogRepository>(),
                    FunFactDetails = readProvider.GetRequiredService<IROFunFactDetailRepository>(),
                    NotificationTextsDetails = readProvider.GetRequiredService<IRONotificationTextDetailRepository>(),
                    TutorialActions = readProvider.GetRequiredService<IROTutorialActionRepository>(),
                    UiGroups = readProvider.GetRequiredService<IROUiGroupRepository>(),
                    UserConditions = readProvider.GetRequiredService<IROUserConditionRepository>(),
                    UserFailedAttempts = readProvider.GetRequiredService<IROUserFailedAttemptRepository>(),
                    UserTransactionConditions = readProvider.GetRequiredService<IROUserTransactionConditionRepository>(),
                    Devices = readProvider.GetRequiredService<IRODeviceRepository>(),
                    Favorites = readProvider.GetRequiredService<IROFavoritesRepository>(),
                    FrequentlyQuestions = readProvider.GetRequiredService<IROFrequentlyQuestionsRepository>(),
                    FrequentlyQuestionsDetails = readProvider.GetRequiredService<IROFrequentlyQuestionsDetailRepository>(),
                    Functionalities = readProvider.GetRequiredService<IROFunctionalityRepository>(),
                    FunFacts = readProvider.GetRequiredService<IROFunFactRepository>(),
                    Notifications = readProvider.GetRequiredService<IRONotificationRepository>(),
                    OptionItems = readProvider.GetRequiredService<IROOptionItemRepository>(),
                    ProfileAddresses = readProvider.GetRequiredService<IROProfileAddressRepository>(),
                    QuickActions = readProvider.GetRequiredService<IROQuickActionRepository>(),
                    UserQuickActions = readProvider.GetRequiredService<IROUserQuickActionRepository>(),
                    AppVersionDetails = readProvider.GetRequiredService<IROAppVersionDetailRepository>(),
                    BiometricAccounts = readProvider.GetRequiredService<IROBiometricAccountRepository>(),
                    FailedOpportunities = readProvider.GetRequiredService<IROFailedOpportunityRepository>(),
                    UserFavoriteFunctionalities = readProvider.GetRequiredService<IROUserFavoriteFunctionalityRepository>(),
                    UserFeatureStates = readProvider.GetRequiredService<IROUserFeatureStateRepository>(),
                    UserFunctionalities = readProvider.GetRequiredService<IROUserFunctionalityRepository>(),
                    UserOptionItems = readProvider.GetRequiredService<IROUserOptionItemRepository>(),
                    UserProducts = readProvider.GetRequiredService<IROUserProductRepository>(),
                    UserSubProducts = readProvider.GetRequiredService<IROUserSubProductRepository>(),
                    UserTutorials = readProvider.GetRequiredService<IROUserTutorialsRepository>(),
                    Kycs = readProvider.GetRequiredService<IROKycRepository>(),
                    NotificationConfigs = readProvider.GetRequiredService<IRONotificationConfigRepository>(),
                    NotificationHistories = readProvider.GetRequiredService<IRONotificationHistoryRepository>(),
                    NotificationTexts = readProvider.GetRequiredService<IRONotificationTextsRepository>(),
                    OnboardingHistories = readProvider.GetRequiredService<IROOnboardingHistoryRepository>(),
                    Transactions = readProvider.GetRequiredService<IROTransactionRepository>(),
                };
            });
            //Configure ReadRepositorySettings

            // Add UnitOfWork
            services.AddScoped<IUnitOfWork, UnitOfWork>();
            services.AddScoped<IReadUnitOfWork, ReadUnitOfWork>();

            // Configure JSON options
            services.Configure<JsonOptions>(options =>
                options.SerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);

            services.AddEasyCaching(options =>
            {
                // Write (Primary endpoint)
                options.UseRedis(options =>
                {
                    options.SerializerName = "json";

                    options.DBConfig = new RedisDBOptions
                    {
                        Database = int.Parse(configuration["InternalServices:Easycaching:RedisWrite:DbConfig:Database"]!),
                        ConnectionTimeout = int.Parse(configuration["InternalServices:Easycaching:RedisWrite:DbConfig:ConnectionTimeout"]!),
                        AllowAdmin = bool.Parse(configuration["InternalServices:Easycaching:RedisWrite:DbConfig:AllowAdmin"]!),
                        IsSsl = bool.Parse(configuration["InternalServices:Easycaching:RedisWrite:DbConfig:IsSsl"]!),
                        Endpoints =
                        {
                            new ServerEndPoint
                            {
                                Host = configuration["InternalServices:Easycaching:RedisWrite:DbConfig:Endpoints:0:Host"],
                                Port = int.Parse(configuration["InternalServices:Easycaching:RedisWrite:DbConfig:Endpoints:0:Port"]!)
                            }
                        }
                    };
                }, CacheProvider.RedisWrite);

                // Read (Reader endpoint)
                options.UseRedis(options =>
                {
                    options.SerializerName = "json";

                    options.DBConfig = new RedisDBOptions
                    {
                        Database = int.Parse(configuration["InternalServices:Easycaching:RedisRead:DbConfig:Database"]!),
                        ConnectionTimeout = int.Parse(configuration["InternalServices:Easycaching:RedisRead:DbConfig:ConnectionTimeout"]!),
                        AllowAdmin = bool.Parse(configuration["InternalServices:Easycaching:RedisRead:DbConfig:AllowAdmin"]!),
                        IsSsl = bool.Parse(configuration["InternalServices:Easycaching:RedisRead:DbConfig:IsSsl"]!),
                        Endpoints =
                        {
                            new ServerEndPoint
                            {
                                Host = configuration["InternalServices:Easycaching:RedisRead:DbConfig:Endpoints:0:Host"],
                                Port = int.Parse(configuration["InternalServices:Easycaching:RedisRead:DbConfig:Endpoints:0:Port"]!)
                            }
                        }
                    };
                }, CacheProvider.RedisRead);

                options.WithSystemTextJson();
            });

            services.AddScoped<ICacheService, CustomCacheService>();
            services.AddScoped<IRealTimeMessageManager, RealTimeMessageManager>();

            return services;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Application\Behaviors\UserProfileEnrichmentBehavior.cs
```csharp
using DXP.Core.Application.Common.Interfaces;
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Extensions;
using MediatR;
using Microsoft.Extensions.Logging;

namespace DXP.Core.Database.Application.Behaviors;

public class UserProfileEnrichmentBehavior<TRequest, TResponse>(
    ILogger<UserProfileEnrichmentBehavior<TRequest, TResponse>> logger,
    IUnitOfWork unitOfWork,
    ICacheService cacheService,
    IErrorManager errorManager
) : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull
{
    private readonly ILogger<UserProfileEnrichmentBehavior<TRequest, TResponse>> _logger = logger;

    private readonly IUnitOfWork _unitOfWork = unitOfWork;

    private readonly IErrorManager _errorManager = errorManager;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken
    )
    {
        if (request is not IUserProfileAwareRequest)
            return await next();

        var userProfileRequest = (IUserProfileAwareRequest)request;

        _logger.LogInformation(
            "Obteniendo informacion del perfil de usuario {UserId} para la solicitud de tipo {RequestType}",
            userProfileRequest.UserId,
            typeof(TRequest).Name
        );

        if (userProfileRequest.UserId is null)
            await _errorManager.ThrowBadRequestException(
                "DXP052",
                language: userProfileRequest.Language
            );

        var userId = Guid.Parse(userProfileRequest.UserId);

        var userProfile = await cacheService.GetOrCreateAsync(
            CacheKeyBuilder.BuildCacheKey(
                CacheDomain.DigitalExperience,
                userProfileRequest.BankId,
                CacheGroup.UserProfile,
                userId.ToString(),
                CacheGroup.Behavior
            ),
            TimeSpan.FromMinutes(3),
            () =>
                _unitOfWork.Profiles.GetProfileByUserIdAndBankIdAsync(
                    userId,
                    userProfileRequest.BankId.GetDescription()!
                ),
            cancellationToken
        );

        if (userProfile is null)
            await _errorManager.ThrowBadRequestException(
                "DXP052",
                language: userProfileRequest.Language
            );

        userProfileRequest.UserProfile = userProfile;

        return await next();
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Constants\CacheProvider.cs
```csharp
namespace DXP.Core.Database.Domain.Constants
{
    public static class CacheProvider
    {
        public const string RedisWrite = "redis-write";
        public const string RedisRead = "redis-read";
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AccountType.cs
```csharp
using System.ComponentModel.DataAnnotations;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

public class AccountType : BaseAuditableEntity<int>
{
    /// <summary>
    /// Código del core del tipo de cuenta
    /// </summary>
    [Required]
    [MaxLength(10)]
    public required string CoreCode { get; set; }

    /// <summary>
    /// ID del banco al que pertenece el tipo de cuenta
    /// </summary>
    [Required]
    public required string BankId { get; set; }

    /// <summary>
    /// Descripción o nombre del tipo de cuenta
    /// </summary>
    [Required]
    [MaxLength(100)]
    public required string Description { get; set; }

    /// <summary>
    /// Moneda del tipo de cuenta
    /// </summary>
    [Required]
    [MaxLength(34)]
    public required string Currency { get; set; }

    /// <summary>
    /// Número de GL asociado al tipo de cuenta (BLNI)
    /// </summary>
    [MaxLength(16)]
    public string? GlNumber { get; set; }

    public virtual Bank Bank { get; set; } = null!;
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Advertising.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class Advertising : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Descripcion que tendrá la publicidad
        /// </summary>
        public string? Description { get; set; }

        /// <summary>
        /// Pantalla donde va a aparecer la publicidad
        /// </summary>
        [Required]
        public string? ScreenId { get; set; }

        /// <summary>
        /// La manera en que va a ser mostrada esta publicidad
        /// </summary>
        [Required]
        public AdvertisingType Type { get; set; }

        /// <summary>
        /// El módulo al que va a pertenecer la publicidad
        /// </summary>
        public AdvertisingModule? Module { get; set; } = null;

        /// <summary>
        /// Puede ser por país
        /// </summary>
        public string? BankId { get; set; }

        /// <summary>
        /// Si la publicidad está activa o no
        /// </summary>
        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        public virtual ICollection<AdvertisingDetail> AdvertisingDetail { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AdvertisingDetail.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class AdvertisingDetail : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Id que referencia a los datos generales de la advertencia
        /// </summary>
        [Required]
        public int AdvertisingId { get; set; }

        /// <summary>
        /// Url del contenido del detalle de la publicidad
        /// </summary>
        public string MediaUrl { get; set; } = string.Empty;

        /// <summary>
        /// Se especifica si se va a redirigir a una pantalla o a una url externa
        /// </summary>
        [Required]
        public RedirectTo RedirectTo { get; set; }

        /// <summary>
        /// La url o pantalla
        /// </summary>
        public string? Link { get; set; }

        /// <summary>
        /// Especifica si tiene alguna condición para saber si mostrar la publicidad
        /// </summary>
        public bool HasCondition { get; set; }

        /// <summary>
        /// Los datos parámetros que nos van a ayudar a saber si mostrar este banner o no
        /// </summary>
        public string? TargetData { get; set; }

        /// <summary>
        /// Descripción del banner para poder ubicarlos mejor
        /// </summary>
        public string? Description { get; set; }

        /// <summary>
        /// Se podrán ordenar los banner según la prioridad que tengan
        /// </summary>
        public int Priority { get; set; }

        /// <summary>
        /// Si el registro está activo o no
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// Relación de un detalle de la publicicdad
        /// </summary>
        [JsonIgnore]
        public virtual Advertising? Advertising { get; set; } = null;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AppResource.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa un recurso en la aplicación con detalles específicos.
    /// </summary>
    public class AppResource : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Tipo de recurso asociado.
        /// </summary>
        [Required]
        public ResourceType ResourceType { get; set; }

        /// <summary>
        /// Ruta URL del recurso.
        /// </summary>
        [MaxLength(2000)]
        public string? PathResource { get; set; }

        /// <summary>
        /// Versión del recurso.
        /// </summary>
        [Required]
        [MaxLength(50)]
        public string VersionResource { get; set; } = string.Empty;

        /// <summary>
        /// Identificador del banco asociado (opcional).
        /// </summary>
        [MaxLength(255)]
        [ForeignKey("Bank")]
        public string? BankId { get; set; }

        /// <summary>
        /// Tipo de producto asociado al recurso.
        /// </summary>
        public ProductType? ProductType { get; set; }

        /// <summary>
        /// Indica si el recurso está activo o no.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Tipo de subproducto asociado al recurso (opcional).
        /// </summary>
        [MaxLength(255)]
        public string? SubProduct { get; set; }

        public virtual Bank Bank { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AppScreen.cs
```csharp
using System.ComponentModel.DataAnnotations;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa una pantalla en la aplicación.
    /// </summary>
    public class AppScreen : BaseAuditableEntity<string>
    {
        /// <summary>
        /// Nombre de la pantalla.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string? ScreenName { get; set; }

        /// <summary>
        /// Descripción de la pantalla.
        /// </summary>
        public string? Description { get; set; }

        /// <summary>
        /// Referencia a la sección de la aplicación.
        /// </summary>
        [Required]
        public int SectionId { get; set; }

        /// <summary>
        /// Si el registro está activo o no
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// Código de país según ISO 3166-1 alpha-2.
        /// </summary>
        [Required]
        [MaxLength(3)]
        public string? CountryCode { get; set; }

        // Foreign key relationship
        public virtual AppSectionCatalog Section { get; set; } = null!;
        public virtual ICollection<OnboardingHistory> OnboardingHistories { get; set; } = [];
        public virtual ICollection<Notification> Notifications { get; set; } = [];
        public virtual ICollection<NotificationHistory> NotificationHistories { get; set; } = [];
        public virtual ICollection<TutorialAction> TutorialActions { get; set; } = [];
        public virtual ICollection<UiGroup> UiGroups { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AppSectionCatalog.cs
```csharp
using System.ComponentModel.DataAnnotations;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa una sección en el catálogo de la aplicación.
    /// </summary>
    public class AppSectionCatalog : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Nombre de la sección.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string? SectionName { get; set; }

        /// <summary>
        /// Descripción de la sección.
        /// </summary>
        public string? Description { get; set; }

        public virtual ICollection<AppScreen> Sections { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AppVersion.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class AppVersion : BaseAuditableEntity<string>
    {
        /// <summary>
        /// Saber si la actualización es obligartoria o no
        /// </summary>
        public bool IsRequired { get; set; }

        /// <summary>
        /// Descripción de la versión
        /// </summary>
        public string? Description { get; set; }

        [JsonIgnore]
        public virtual ICollection<AppVersionDetail> AppVersionDetail { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\AppVersionDetail.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class AppVersionDetail : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Descripción de la novedad
        /// </summary>
        public string NewDescription { get; set; } = string.Empty;

        /// <summary>
        /// Url de una imagen descriptiva de la novedad
        /// </summary>
        public string? NewImageUrl { get; set; }

        /// <summary>
        /// Id que hará relación con una versión
        /// </summary>
        [Required]
        public string AppVersionId { get; set; } = string.Empty;

        /// <summary>
        /// Relación de un detalle de la versión de la app
        /// </summary>
        [JsonIgnore]
        public virtual AppVersion? AppVersion { get; set; } = null;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Bank.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class Bank : BaseAuditableEntity<string>
    {
        /// <summary>
        /// Nombre del banco.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string? BankName { get; set; }

        /// <summary>
        /// Estado activo del banco.
        /// </summary>
        public bool? Active { get; set; } = true;

        /// <summary>
        /// Usuario que creó el registro del banco.
        /// </summary>
        [MaxLength(50)]
        public string? CreatedBy { get; set; }

        /// <summary>
        /// Usuario que actualizó el registro del banco.
        /// </summary>
        [MaxLength(50)]
        public string? UpdatedBy { get; set; }

        /// <summary>
        /// Prefijo numero de telefono.
        /// </summary>
        [MaxLength(10)]
        public string? Prefix { get; set; }

        /// <summary>
        /// Numero de telefono.
        /// </summary>
        [MaxLength(25)]
        public string? PhoneNumber { get; set; }

        [JsonIgnore]
        public virtual ICollection<Otp> Otps { get; set; } = [];
        public virtual ICollection<Onboarding> Onboardings { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<UserProfile> UserProfiles { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<AccountType> AccountTypes { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<AppResource> AppResources { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<Functionality> Functionalities { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<Transaction> TransactionOriginCountries { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<Transaction> TransactionDestinationCountries { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<FrequentlyQuestions> FrequentlyQuestions { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<User> Users { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<CountryBank> CountryBanks { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<TransferMethod> TransferMethods { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<TutorialAction> TutorialActions { get; set; } = [];
        [JsonIgnore]
        public virtual ICollection<UiGroup> UiGroups { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<FailedOpportunity> FailedOpportunities { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\BiometricAccount.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class BiometricAccount : BaseAuditableEntity<int>
    {
        /// <summary>
        /// ID del usuario al que se relaciona el o los proveedores biométricos
        /// </summary>
        [Required]
        public Guid UserId { get; set; }

        /// <summary>
        /// Proveedor biométrico de la cuenta
        /// </summary>
        [Required]
        public string ProviderName { get; set; } = string.Empty;

        /// <summary>
        /// Id de la cuenta asociada a su proveedor biométrico
        /// </summary>
        [Required]
        public string AccountId { get; set; } = string.Empty;

        /// <summary>
        /// Propiedad para hacer eliminación lógica
        /// </summary>
        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        public virtual User? User { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\CountryBank.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

/// <summary>
/// Representa información de otro banco local
/// </summary>
public class CountryBank : BaseAuditableEntity<int>
{
    /// <summary>
    /// Identificador del banco en el sistema central o CORE BANCARIO.
    /// </summary>
    public string? CoreId { get; set; }

    /// <summary>
    /// Nombre del banco.
    /// </summary>
    public string? BankName { get; set; } = null!;

    /// <summary>
    /// Alias del banco, por ejemplo, Banco LAFISE.
    /// </summary>
    public string? Alias { get; set; }

    /// <summary>
    /// Codigo unico de banco.
    /// </summary>
    public required string Bic { get; set; }

    /// <summary>
    /// Código SWIFT del banco.
    /// </summary>
    public string? SwiftCode { get; set; }

    /// <summary>
    /// Indica si el banco está activo.
    /// </summary>
    public bool IsActive { get; set; } = true;

    /// <summary>
    /// Código ISO del país en el que está registrado el banco (3 dígitos).
    /// </summary>
    public string CountryCode { get; set; } = null!;

    /// <summary>
    /// Logo del banco
    /// </summary>
    [MaxLength(200)]
    public string? ImageUrl { get; set; }

    /// <summary>
    /// ID del banco al que pertenece el tipo de cuenta
    /// </summary>
    [Required]
    public required string BankId { get; set; }

    /// <summary>
    /// Código de referencia externa del registro
    /// </summary>
    public string? ExternalReference = null;

    // Relaciones
    [JsonIgnore]
    public virtual Bank Bank { get; set; } = null!;

    [JsonIgnore]
    public virtual ICollection<FavoriteTransaction> FavoriteTransactions { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<CountryBankProductTypeConfig> CountryBankProductTypeConfigs { get; set; } = [];
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\CountryBankProductTypeConfig.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

public class CountryBankProductTypeConfig : BaseAuditableEntity<int>
{
    public int CountryBankId { get; set; }

    public int TransferMethodProductTypeId { get; set; }

    [Required, MaxLength(3)]
    public string Currency { get; set; } = string.Empty;

    public bool IsActive { get; set; } = true;

    [JsonIgnore]
    public virtual CountryBank? CountryBank { get; set; }

    [JsonIgnore]
    public virtual TransferMethodProductType? TransferMethodProductType { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Device.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class Device : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al usuario final asociado (UUID).
        /// </summary>
        [Required]
        [ForeignKey("User")]
        public Guid? UserId { get; set; }

        /// <summary>
        /// Token único del dispositivo en Firebase.
        /// </summary>
        [Required]
        [MaxLength(255)]
        public string? DeviceToken { get; set; }

        /// <summary>
        /// Nombre descriptivo del dispositivo (opcional).
        /// </summary>
        [MaxLength(100)]
        public string? DeviceName { get; set; }

        /// <summary>
        /// Indica si es el dispositivo primario del usuario.
        /// </summary>
        public bool IsPrimary { get; set; } = false;

        /// <summary>
        /// ID único del dispositivo
        /// </summary>
        public string? UniqueDeviceId { get; set; }

        /// <summary>
        /// Indica si el dispositivo está activo o inactivo.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Hash de biometría del dispositivo
        /// </summary>
        public string? BiometricHash { get; set; }

        /// <summary>
        /// Refresh Token utilizado para autenticación en el dispositivo
        /// </summary>
        public string? RefreshToken { get; set; }

        /// <summary>
        /// Fecha del último inicio de sesión en el dispositivo
        /// </summary>
        public DateTime? LastLogIn { get; set; }

        /// <summary>
        /// Fecha del último cierre de sesión en el dispositivo
        /// </summary>
        public DateTime? LastLogOut { get; set; }

        /// <summary>
        /// Indica si es primer incio de sesión en el dispositivo
        /// </summary>
        public bool IsFirstLogIn { get; set; }

        /// <summary>
        /// Indica si se debe notificar que se ha cerrado sesión en el dispositivo
        /// </summary>
        public bool MustLogOut { get; set; }

        // Foreign key relationships
        [JsonIgnore]
        public virtual User User { get; set; } = null!;

        [JsonIgnore]
        public ICollection<Notification> Notifications { get; set; } = [];

        [JsonIgnore]
        public ICollection<NotificationHistory> NotificationHistories { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FailedOpportunity.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class FailedOpportunity : BaseAuditableEntity<int>
    {
        /// <summary>
        /// ID del banco al que pertenece la oportunidad.
        /// </summary>
        [Required]
        public required string BankId { get; set; }

        /// <summary>
        /// Perfil del usuario al que pertenece la oportunidad.
        /// </summary>
        [Required]
        public required Guid UserId { get; set; }

        /// <summary>
        /// Estado de la oportunidad
        /// </summary>
        [MaxLength(100)]
        public CurrentStage? CurrentStage { get; set; }

        /// <summary>
        /// Razón por la cual falló la oportunidad.
        /// </summary>
        public string? FailedReason { get; set; }

        /// <summary>
        /// Fecha esperada de cierre de la oportunidad.
        /// </summary>
        public DateTime? ExpectedCloseDate { get; set; }

        /// <summary>
        /// Número de reintentos para procesar la oportunidad.
        /// </summary>
        public int RetriesNumber { get; set; } = 0;

        /// <summary>
        /// JSON que contiene la información de la oportunidad fallida.
        /// </summary>
        public string? OpportunityJson { get; set; }

        /// <summary>
        /// Mensaje de error asociado a la falla de la oportunidad.
        /// </summary>
        public string? ErrorMessage { get; set; }

        [JsonIgnore]
        public virtual Bank Bank { get; set; } = null!;

        [JsonIgnore]
        public virtual User User { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FavoriteGroup.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa un grupo de beneficiarios agrupados por país y banco.
    /// </summary>
    public class FavoriteGroup : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Nombre del grupo.
        /// </summary>
        [Required, MaxLength(200)]
        public string GroupName { get; set; } = string.Empty;

        /// <summary>
        /// Identificador único del usuario asociado al beneficiario.
        /// </summary>
        [Required]
        public Guid ProfileId { get; set; }

        /// <summary>
        /// Indica si está activo o inactivo.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Tipo de transacción (por ejemplo, depósito, retiro, transferencia).
        /// </summary>
        public GroupType? GroupType { get; set; }

        [JsonIgnore]
        public virtual UserProfile Profile { get; set; } = null!;
        public virtual ICollection<FavoriteService> FavoriteServices { get; set; } = [];
        public virtual ICollection<FavoriteTransaction> FavoriteTransactions { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FavoriteService.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa una colección de servicios específicos configurados por el cliente.
    /// </summary>
    public class FavoriteService : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Identificador único del servicio en el API o core del banco.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public required string ServiceIdCore { get; set; }

        /// <summary>
        /// Identificador único de la categoria del servicio
        /// </summary>
        [Required]
        [MaxLength(200)]
        public required string ServiceCategoryId { get; set; }

        /// <summary>
        /// Identificador del grupo de beneficiarios al que pertenece el servicio.
        /// </summary>
        [Required]
        public int FavoriteGroupId { get; set; }

        /// <summary>
        /// Nombre del servicio.
        /// </summary>
        [Required]
        [MaxLength(255)]
        public required string ServiceName { get; set; }

        /// <summary>
        /// Identificador del proveedor del servicio.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public required string ProviderId { get; set; }

        /// <summary>
        /// URL de la imagen del servicio.
        /// </summary>
        public string? ImageUrl { get; set; }

        /// <summary>
        /// Estado del servicio (Activo/Inactivo).
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// Tipo de moneda del pago.
        /// </summary>
        [MaxLength(3)]
        public string? Currency { get; set; }

        /// <summary>
        /// Monto del pago.
        /// </summary>
        public decimal? Amount { get; set; }

        /// <summary>
        /// Datos adicionales del pago en formato JSON.
        /// </summary>
        [Required]
        public JsonDocument AdditionalDataPayment { get; set; } = null!;

        /// <summary>
        /// Relación con el grupo favorito.
        /// </summary>
        [ForeignKey(nameof(FavoriteGroupId))]
        public virtual FavoriteGroup FavoriteGroup { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FavoriteTransaction.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa una transacción bancaria.
    /// </summary>
    public class FavoriteTransaction : BaseAuditableEntity<long>
    {
        /// <summary>
        /// Identificador de grupo.
        /// </summary>
        [Required]
        public int FavoriteGroupId { get; set; }

        /// <summary>
        /// Alias de la transacción.
        /// </summary>
        [Required]
        [StringLength(100)]
        public string? Alias { get; set; }

        /// <summary>
        /// Nombre del titular del producto bancario.
        /// </summary>
        [Required]
        [StringLength(100)]
        public string? AccountHolderName { get; set; }

        /// <summary>
        /// Producto Bancario.
        /// </summary>
        public ProductType? ProductType { get; set; }

        /// <summary>
        /// Número de Producto.
        /// </summary>
        [Required]
        [StringLength(50)] // Limita la longitud del número de producto para mayor seguridad.
        public string? ProductNumber { get; set; }

        /// <summary>
        /// Monto de la transacción.
        /// </summary>
        public decimal? Amount { get; set; } = 0; // Permite valor nulo, con valor predeterminado 0

        /// <summary>
        /// Moneda de la transacción (ISO 4217 de 3 dígitos).
        /// </summary>
        [Required]
        [StringLength(3, MinimumLength = 3)] // Asegura que el código de moneda tenga exactamente 3 caracteres.
        public string? Currency { get; set; }

        /// <summary>
        /// Tipo de transacción (por ejemplo, depósito, retiro, transferencia).
        /// </summary>
        public TransactionType? TransactionType { get; set; }

        /// <summary>
        /// Imagen del usuario
        /// </summary>
        [StringLength(300)]
        public string? UserPicture { get; set; }

        /// <summary>
        /// Additional data of favorite transaction
        /// </summary>
        [Required]
        [StringLength(1000)]
        public string? AdditionalData { get; set; }

        /// <summary>
        /// Estado del servicio (Activo/Inactivo).
        /// </summary>
        public bool IsActive { get; set; }

        [Required]
        [StringLength(100)]
        public int? CountryBankId { get; set; }

        [StringLength(60)]
        public Guid? UserDestinationId { get; set; }

        // Relaciones
        /// <summary>
        /// Cuenta bancaria asociada a la transacción.
        /// </summary>
        public virtual CountryBank CountryBank { get; set; } = null!;

        /// <summary>
        /// Usuario destino
        /// </summary>
        [JsonIgnore()]
        [ForeignKey(nameof(User))]
        public virtual User? UserDestination { get; set; }

        /// <summary>
        /// Relación con el grupo favorito.
        /// </summary>
        [ForeignKey(nameof(FavoriteGroupId))]
        public virtual FavoriteGroup FavoriteGroup { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FrequentlyQuestions.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class FrequentlyQuestions : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Id del banco para las preguntas (Varían por país)
        /// </summary>
        [Required]
        public string? BankId { get; set; } = null!;

        /// <summary>
        /// Idioma de las preguntas
        /// </summary>
        [Required]
        public string? Description { get; set; } = null!;

        /// <summary>
        /// Indicador de actividad de la entidad
        /// </summary>
        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        public virtual Bank? Bank { get; set; } = null!;

        [JsonIgnore]
        public virtual ICollection<FrequentlyQuestionsDetail> FrequentlyQuestionsDetail { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FrequentlyQuestionsDetail.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class FrequentlyQuestionsDetail : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Llave foránea para la tabla padre con el contexto sobre la pregunta
        /// </summary>
        [Required]
        public int FrequentlyQuestionsId { get; set; }

        /// <summary>
        /// Idioma de las preguntas
        /// </summary>
        [Required]
        public string? Language { get; set; } = null!;

        /// <summary>
        /// Pregunta como tal
        /// </summary>
        [Required]
        public string? Question { get; set; } = null!;

        /// <summary>
        /// Respuesta de la pregunta
        /// </summary>
        [Required]
        public string? Answer { get; set; } = null!;

        /// <summary>
        /// Indicador de actividad de la entidad
        /// </summary>
        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        public virtual FrequentlyQuestions? FrequentlyQuestion { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Functionality.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa una funcionalidad en el sistema.
    /// </summary>
    public class Functionality : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Nombre de la funcionalidad.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string FunctionalityName { get; set; } = null!;

        /// <summary>
        /// Banco Asociado a la funcionalidad
        /// </summary>
        [Required]
        public string? BankId { get; set; }

        /// <summary>
        /// Descripción de la funcionalidad.
        /// </summary>
        public string? Description { get; set; }

        /// <summary>
        /// Indica si la funcionalidad está activa.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// URL de la imagen asociada a la funcionalidad.
        /// </summary>
        [MaxLength(255)]
        public string? ImageUrl { get; set; }

        /// <summary>
        /// ID de la funcionalidad padre.
        /// </summary>
        [ForeignKey(nameof(ParentFunctionality))]
        public int? ParentFunctionalityId { get; set; }

        /// <summary>
        /// Funcionalidad padre asociada.
        /// </summary>
        public virtual Functionality? ParentFunctionality { get; set; }
        public virtual Bank Bank { get; set; } = null!;
        /// <summary>
        /// Funcionalidades hijas asociadas.
        /// </summary>
        public virtual ICollection<Functionality> ChildFunctionalities { get; set; } = [];
        public virtual ICollection<UserFunctionality> UserFunctionalities { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FunFact.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class FunFact : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Titulo del Fun Fact en caso de tener Title
        /// </summary>
        [MaxLength(20)]
        public string? Title { get; set; } = null;

        /// <summary>
        /// Código del banco al que pertenece el Fun Fact
        /// </summary>
        [Required]
        [MaxLength(10)]
        public string? BankId { get; set; } = null;

        /// <summary>
        /// Estado del Fun Fact
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Tipo de categoria (por ejemplo: Insurance, Onboarding...) a los que pertenecen los Fun Fact
        /// </summary>
        [Required]
        public CategoryType CategoryType { get; set; }
        /// <summary>
        /// Identificador de pantalla que contiene los o el Fun Fact
        /// </summary>
        [MaxLength(50)]
        public string? ScreenId { get; set; } = null!;

        /// <summary>
        /// Llave foranea que representa los detalles del Fun Fact
        /// </summary>
        [JsonIgnore]
        public virtual ICollection<FunFactDetail> FunFactDetail { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\FunFactDetail.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class FunFactDetail : BaseAuditableEntity<int>
    {
        public int FunFactId { get; set; }
        /// <summary>
        /// Descripción del Fun Fact
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string? Description { get; set; } = null;
        /// <summary>
        /// Icon del Fun Fact
        /// </summary>
        public string? Icon { get; set; } = null;
        /// <summary>
        /// Prioridad del Fun Fact en caso de que se lleguen a ordenar en un futuro los Fun Fact en alguna pantalla.
        /// </summary>
        public int Priority { get; set; }
        /// <summary>
        /// El idioma del Fun Fact
        /// </summary>
        public string? Language { get; set; } = null;

        [JsonIgnore]
        public virtual FunFact? FunFact { get; set; } = null;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Kyc.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class Kyc : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al ID del usuario asociado al KYC (UUID).
        /// </summary>
        public Guid? UserId { get; set; }

        /// <summary>
        /// ID de cuenta de Jumio asociado al KYC.
        /// </summary>
        public string? JumioAccountId { get; set; }

        /// <summary>
        /// Enlace de flujo de Jumio asociado al KYC.
        /// </summary>
        public string? JumioWorkflowHref { get; set; }

        /// <summary>
        /// Estado del KYC (pending, approved, rejected).
        /// </summary>
        public KycStatus? KycStatus { get; set; } = Enums.KycStatus.Pending;

        /// <summary>
        /// Datos biométricos asociados al KYC en formato JSON.
        /// </summary>
        public string? BiometricData { get; set; }
        /// <summary>
        /// ID de log en formato SHA.
        /// </summary>
        [MaxLength(300)] // Asumiendo 300 caracteres
        public string? LogId { get; set; } = string.Empty;

        /// <summary>
        /// Tipo de certificado Certificados Biométricos,Certificados de Documento de Identidad o Perfil de Cliente, etc
        /// </summary>
        public CertificateType? CertificateType { get; set; }

        /// <summary>
        /// Certificado de cliente
        /// </summary>
        public string? Certificate { get; set; }

        /// <summary>
        /// Motivo de creación de KYC
        /// </summary> 
        [MaxLength(50)]
        public string? Reason { get; set; }

        /// <summary>
        /// Evaluaciones hechas por KYC
        /// </summary> 
        public string? CheckCategories { get; set; }

        [MaxLength(50)]
        public string? ChallengeId { get; set; }

        // Foreign key relationships
        [JsonIgnore]
        public virtual User User { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Notification.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class Notification : BaseAuditableEntity<long>
{
    /// <summary>
    /// Referencia al usuario al que se envió la notificación.
    /// </summary>
    [Required]
    [Column("user_id")]
    public Guid UserId { get; set; }

    /// <summary>
    /// Medio por el cual se envió la notificación (ej. "Sms", "Email", "Push").
    /// </summary>
    [Column("notification_type")]
    public NotificationType? NotificationType { get; set; }

    /// <summary>
    /// Proceso que envía la notificación
    /// </summary>
    [Required]
    [Column("process_type")]
    public ProcessType ProcessType { get; set; }

    /// <summary>
    /// Mensaje (título) de la notificación enviada.
    /// </summary>
    [Required]
    [Column("message")]
    public string? Message { get; set; } = string.Empty;

    /// <summary>
    /// Detalle de la notificación, tiene un poco más de contenido que el mensaje (título).
    /// </summary>
    [Required]
    [Column("body")]
    public string? Body { get; set; } = string.Empty;

    /// <summary>
    /// Identificador del dispositivo desde el cual se envió la notificación.
    /// </summary>
    [Column("device_id")]
    public int? DeviceId { get; set; }

    /// <summary>
    /// Identificador del texto de la notificación.
    /// </summary>
    [Column("notification_text_id")]
    public int? NotificationTextId { get; set; }

    /// <summary>
    /// Relación con la pantalla para indicar si se puede ir a ella cuando sea push.
    /// </summary>
    [Column("app_screen_id")]
    public string? AppScreenId { get; set; }

    /// <summary>
    /// Datos que se reemplazarán con el cuerpo de una notificación base | modelo.
    /// </summary>
    [Column("data_replacement")]
    public string? DataReplacement { get; set; }

    /// <summary>
    /// Estado de la notificación
    /// </summary>
    [Column("status")]
    public NotificationStatus? Status { get; set; } = NotificationStatus.Sent;

    /// <summary>
    /// Imagen a mostrar en la notificación
    /// </summary>
    [Column("image_url")]
    public string? ImageUrl { get; set; }

    [JsonIgnore]
    // Foreign key relationships
    public virtual User User { get; set; } = null!;

    [JsonIgnore]
    public virtual Device Device { get; set; } = null!;

    [JsonIgnore]
    public virtual AppScreen? AppScreen { get; set; }

    [JsonIgnore]
    public virtual NotificationTexts? NotificationTexts { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\NotificationConfig.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class NotificationConfig : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al usuario asociado al NotificationConfig.
        /// </summary>
        public Guid UserId { get; set; }

        /// <summary>
        /// Tipo de notificación (sms, email, push).
        /// </summary>
        [Required]
        public NotificationType NotificationType { get; set; }

        /// <summary>
        /// Tipo de configuración (Promociones, Novedades).
        /// </summary>
        [Required]
        public ConfigurationType ConfigurationType { get; set; }

        /// <summary>
        /// Descripción breve del tipo de notificación.
        /// </summary>
        [MaxLength(255)]
        public string? Description { get; set; }

        /// <summary>
        /// Estado de activación de la notificación.
        /// </summary>
        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        // Propiedad de navegación
        public virtual User User { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\NotificationHistory.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class NotificationHistory : BaseAuditableEntity<long>
    {
        /// <summary>
        /// Identificador del usuario que recibió la notificación en el historial.
        /// </summary>
        public Guid? UserId { get; set; }

        /// <summary>
        /// Tipo de notificación que se envió (ej. "Sms", "Email", "Push").
        /// </summary>
        public NotificationType? NotificationType { get; set; }

        /// <summary>
        /// Tipo de proceso que envió la notificación
        /// </summary>
        public ProcessType ProcessType { get; set; }

        /// <summary>
        /// Mensaje de la notificación enviada en el historial.
        /// </summary>
        public string Message { get; set; } = string.Empty;

        /// <summary>
        /// Fecha y hora en que se envió la notificación en el historial.
        /// </summary>
        public DateTime SentAt { get; set; }

        /// <summary>
        /// Identificador del dispositivo desde el cual se envió la notificación en el historial.
        /// </summary>
        public int? DeviceId { get; set; }

        /// <summary>
        /// Identificador de la pantalla a la que redirige la notificación
        /// </summary>
        public string? AppScreenId { get; set; }

        // Foreign key relationships
        [JsonIgnore]
        public virtual User User { get; set; } = null!;

        [JsonIgnore]
        public virtual Device Device { get; set; } = null!;

        [JsonIgnore]
        public virtual AppScreen? AppScreen { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\NotificationTexts.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class NotificationTexts : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Titulo de la notificacion que recibirá el usuario
        /// </summary>
        [Required]
        [Column("title")]
        public string? Title { get; set; }

        /// <summary>
        /// Lenguaje en el que deben enviarse los textos de la notificacion push
        /// </summary>
        [Required]
        [Column("language")]
        public string? Language { get; set; }

        /// <summary>
        /// Cuerpo o contenido de la notificacion
        /// </summary>
        [Column("body")]
        public string? Body { get; set; }

        /// <summary>
        /// Tipo de transaccion
        /// </summary>
        [Column("transaction_type")]
        public TransactionType? TransactionType { get; set; }

        /// <summary>
        /// El proceso involucrado en la transaccion
        /// </summary>
        [Column("process_type")]
        public ProcessType? ProcessType { get; set; }

        /// <summary>
        /// El estado de la transaccion
        /// </summary>
        [Column("transaction_status")]
        public TransactionStatus? TransactionStatus { get; set; }

        /// <summary>
        /// Es debito o credito la transaccion
        /// </summary>
        [Required]
        [Column("is_debit_transaction")]
        public bool IsDebit { get; set; }

        /// <summary>
        /// Id adicional para los pagos de servicios
        /// </summary>
        [Column("external_id")]
        public string? ExternalId { get; set; } = null;

        /// <summary>
        /// Muchos detalles de text de notificación
        /// </summary>
        [JsonIgnore]
        public virtual ICollection<NotificationTextsDetail> NotificationTextsDetail { get; set; } = [];

        /// <summary>
        /// Varias notificaciones usarán el mismo texto
        /// </summary>
        [JsonIgnore]
        public ICollection<Notification> Notifications { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\NotificationTextsDetail.cs
```csharp
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class NotificationTextsDetail : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Id foránea que hace referencia a su padre donde están los detalles generales del texto de notificación
        /// </summary>
        [Column("notification_text_id")]
        public int? NotificationTextId { get; set; }

        /// <summary>
        /// Título de la notificación
        /// </summary>
        [Column("title")]
        public string? Title { get; set; }

        /// <summary>
        /// Detalle de la notificación
        /// </summary>
        [Column("body")]
        public string? Body { get; set; }

        /// <summary>
        /// Lenguaje del texto de la notificación
        /// </summary>
        [Column("language")]
        public string? Language { get; set; }

        /// <summary>
        /// Objeto de tipo NotificationTexts
        /// </summary>
        [JsonIgnore]
        public virtual NotificationTexts? NotificationTexts { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Onboarding.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class Onboarding : BaseAuditableEntity<Guid>
    {
        [ForeignKey("User")]
        public Guid UserId { get; set; }

        /// <summary>
        /// Referencia al ID del banco asociado a.
        /// </summary>
        public string? BankId { get; set; }

        /// <summary>
        /// The campaing id for salesforces
        /// </summary>
        public string? CampaingId { get; set; }

        /// <summary>
        /// the customer service representative name
        /// </summary>
        public string? Referenced { get; set; }

        /// <summary>
        /// associated cost center
        /// </summary>
        public string? CostCenter { get; set; }

        /// <summary>
        /// associated branch code
        /// </summary>
        public string? BranchCode { get; set; }

        /// <summary>
        /// associated official code
        /// </summary>
        public string? OfficialCode { get; set; }

        /// <summary>
        /// associated official name
        /// </summary>
        public string? OfficialName { get; set; }

        /// <summary>
        /// associated subofficial code
        /// </summary>
        public string? SubOfficialCode { get; set; }

        /// <summary>
        /// associated subofficial name
        /// </summary>
        public string? SubOfficialName { get; set; }

        [Required]
        public OnboardingStatus? OnboardStatus { get; set; } = OnboardingStatus.Pending;

        [JsonIgnore]
        public virtual User User { get; set; } = null!;
        [JsonIgnore]
        public virtual Bank Bank { get; set; } = null!;
        [JsonIgnore]
        public virtual ICollection<OnboardingHistory> OnboardingHistories { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\OnboardingHistory.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class OnboardingHistory : BaseAuditableEntity<Guid>
    {
        public Guid UserId { get; set; }
        public Guid OnboardingId { get; set; }
        public string? ScreenId { get; set; }
        public string? ScreenData { get; set; }

        [JsonIgnore]
        public virtual User User { get; set; } = null!;
        [JsonIgnore]
        public virtual Onboarding Onboarding { get; set; } = null!;
        [JsonIgnore]
        public virtual AppScreen AppScreen { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\OptionItem.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Database.Domain.Interfaces;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa las opciones presentadas en cada agrupador
    /// </summary>
    public class OptionItem : BaseAuditableEntity<Guid>, IVersionable
    {
        /// <summary>
        /// Indica la prioridad de la opción.
        /// </summary>
        public int? Priority { get; set; }

        /// <summary>
        /// Indica el nombre para identificar la opción.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Name { get; set; }

        /// <summary>
        /// Indica la etiqueta que se mostrará en pantalla.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Label { get; set; }

        /// <summary>
        /// Indica el logo o ícono de la opción.
        /// </summary>
        [Required]
        [MaxLength(250)]
        public required string Icon { get; set; }

        /// <summary>
        /// Indica lo que la opción levantará.
        /// </summary>
        [Required]
        public required QuickActionType Type { get; set; }

        /// <summary>
        /// Indica la categoría de la opción.
        /// </summary>
        [Required]
        public required QuickActionCategory Category { get; set; }

        /// <summary>
        /// Indica hacia donde va a redirigir la opción.
        /// </summary>
        [Required]
        public string RedirectTo { get; set; } = string.Empty;

        /// <summary>
        /// Información adicional relacionada a la opción.
        /// </summary>
        [Column(TypeName = "jsonb")]
        public string? AdditionalData { get; set; }

        /// <summary>
        /// Indica si la opción es nueva.
        /// </summary>
        public bool IsNew { get; set; } = false;

        /// <summary> 
        /// Indica la opción está activa.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Indica si la opción está en mantenimiento.
        /// </summary>
        public bool InMaintenance { get; set; } = false;

        /// <summary>
        /// Indica la versión mínima del registro para funcionar
        /// </summary>
        public required string MinVersion { get; set; }

        /// <summary>
        /// Indica la versión máxima del registro para funcionar
        /// </summary>
        public string? MaxVersion { get; set; }

        /// <summary>
        /// ID del agrupador donde se encuentra la opción.
        /// </summary>
        public required int UiGroupId { get; set; }

        // Relaciones
        /// <summary>
        /// Indica en qué agrupador se encuentra la opción.
        /// </summary>
        [JsonIgnore]
        public virtual UiGroup UiGroup { get; set; } = null!;

        // Relaciones foráneas
        [JsonIgnore]
        public virtual ICollection<UserOptionItem> UserOptionItems { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Otp.cs
```csharp
using System.ComponentModel.DataAnnotations;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class Otp : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al ID del usuario asociado al OTP (UUID).
        /// </summary>
        public Guid? UserId { get; set; }

        /// <summary>
        /// Referencia al ID del banco asociado al OTP.
        /// </summary>
        public string? BankId { get; set; }

        /// <summary>
        /// Código OTP generado.
        /// </summary>
        [Required]
        [MaxLength(10)]
        public string? OtpCode { get; set; }

        /// <summary>
        /// Tipo de OTP (sms, email, push).
        /// </summary>
        [Required]
        public OtpType OtpType { get; set; }

        /// <summary>
        /// Estado del OTP (generated, sent, expired).
        /// </summary>
        [Required]
        public OtpStatus? OtpStatus { get; set; } = Enums.OtpStatus.Initialized;

        /// <summary>
        /// Tiempo de expiración del OTP (marca de tiempo con zona horaria).
        /// </summary>
        public DateTime? ExpiryTime
        {
            get => _expiryTime;
            set => _expiryTime = value.HasValue ? DateTime.SpecifyKind(value.Value, DateTimeKind.Utc) : value;
        }
        private DateTime? _expiryTime;
        /// <summary>
        /// Número de intentos fallidos.
        /// </summary>
        public int? FailedAttempts { get; set; } = 0;

        /// <summary>
        /// Tipo de proceso que originó el otp
        /// </summary>
        public ProcessType? ProcessType { get; set; }

        // Foreign key relationships
        public virtual Bank Bank { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\ProfileAddress.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class ProfileAddress : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Categoría de la dirección: Home, Work, Other
        /// </summary>
        [Required]
        public AddressType? AddressType { get; set; } = Enums.AddressType.OtherType;

        /// <summary>
        /// Dirección del perfil
        /// </summary>
        [Required]
        public string Address { get; set; } = string.Empty;

        /// <summary>
        /// ID del perfil
        /// </summary>
        [Required]
        public Guid ProfileId { get; set; }

        /// <summary>
        /// Alias de la dirección
        /// </summary>
        public string Alias { get; set; } = string.Empty;

        /// <summary>
        /// Ubicación geográfica, ej: Nicaragua - Managua - Managua - Américas #1 - 11187
        /// </summary>
        public string GeographicalLocation { get; set; } = string.Empty;

        /// <summary>
        /// Latitud de la dirección (Opcional)
        /// </summary>
        public double? Latitude { get; set; }

        /// <summary>
        /// Longitud de la dirección (Opcional)
        /// </summary>
        public double? Longitude { get; set; }

        /// <summary>
        /// Si es activo o no
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Relación de una dirección a un perfil
        /// </summary>
        [JsonIgnore]
        public virtual UserProfile? UserProfile { get; set; } = null;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\QuickAction.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Database.Domain.Interfaces;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa los Quick Actions del sistema.
    /// </summary>
    public class QuickAction : BaseAuditableEntity<Guid>, IVersionable
    {
        /// <summary>
        /// Indica la prioridad del Quick Action
        /// </summary>
        public int? Priority { get; set; }

        /// <summary>
        /// Indica el nombre para identificar el Quick Action.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Name { get; set; }

        /// <summary>
        /// Indica el texto que se imprimirá en el Quick Action.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Description { get; set; }

        /// <summary>
        /// Indica el logo o ícono del Quick Action.
        /// </summary>
        [Required]
        [MaxLength(250)]
        public required string Icon { get; set; }

        /// <summary>
        /// Indica el tipo del Quick Action.
        /// </summary>
        [Required]
        public required QuickActionType Type { get; set; }

        /// <summary>
        /// Indica la categoría del Quick Action.
        /// </summary>
        [Required]
        public required QuickActionCategory Category { get; set; }

        /// <summary>
        /// Indica el Id del Banco del Quick Action.
        /// </summary>
        [Required]
        [MaxLength(4)]
        public required string BankId { get; set; }

        /// <summary>
        /// Indica donde va a redirigir el Quick Action en el sistema.
        /// </summary>
        [Required]
        [MaxLength(150)]
        public string RedirectTo { get; set; } = string.Empty;

        /// <summary>
        /// Indica si está activo el Quick Action.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Indica si el Quick Action es nuevo.
        /// </summary>
        public bool IsNew { get; set; } = false;

        /// <summary>
        /// Indica si el Quick Action está en mantenimiento.
        /// </summary>
        public bool InMaintenance { get; set; } = false;

        [MaxLength(1500)]
        public string? AdditionalData { get; set; }

        /// <summary>
        /// Indica la versión mínima del registro para funcionar
        /// </summary>
        public required string MinVersion { get; set; }

        /// <summary>
        /// Indica la versión máxima del registro para funcionar
        /// </summary>
        public string? MaxVersion { get; set; }

        // Relaciones
        [JsonIgnore]
        public virtual ICollection<UserQuickAction> UserQuickActions { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TermsAndConditions.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class TermsAndConditions : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Como se diferencian los términos y condiciones
        /// </summary>
        public string? Name { get; set; }

        /// <summary>
        /// Si está activo o no
        /// </summary>
        public bool IsActive { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Transaction.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class Transaction : BaseAuditableEntity<long>
{
    /// <summary>
    /// ID de la tabla user profile
    /// </summary>
    [Required]
    public Guid UserProfileId { get; set; }

    /// <summary>
    /// Tipo de transacción
    /// </summary>
    [Required]
    public required TransactionType TransactionType { get; set; }

    /// <summary>
    /// ID del dominio de transacciones
    /// </summary>
    public long? TransactionDomainId { get; set; }

    /// <summary>
    /// Estado de la transacción
    /// </summary>
    public TransactionStatus? TransactionStatus { get; set; } = Enums.TransactionStatus.Validated;

    /// <summary>
    /// Estado de contabilización de la transacción
    /// </summary>
    public TransactionSubStatus? TransactionSubStatus { get; set; } = Enums.TransactionSubStatus.Completed;

    /// <summary>
    /// Número de producto del débito de la transacción
    /// </summary>
    [Required]
    [MaxLength(100)]
    public string DebitProductNumber { get; set; } = string.Empty;

    /// <summary>
    /// Banco origen de la transacción
    /// </summary>
    [Required]
    public string OriginCountryId { get; set; } = string.Empty;

    /// <summary>
    /// Banco destino de la transacción
    /// </summary>
    [Required]
    public string DestinationCountryId { get; set; } = string.Empty;

    /// <summary>
    /// Nombre del titular del producto destino
    /// </summary>
    [MaxLength(250)]
    public string? DestinationProductHolder { get; set; }

    /// <summary>
    /// Información adicional requerida
    /// </summary>
    public string? AdditionalData { get; set; }

    [JsonIgnore]
    public virtual UserProfile? UserProfile { get; set; }
    public virtual Bank? OriginCountry { get; set; }
    public virtual Bank? DestinationCountry { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TransferMethod.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

public class TransferMethod : BaseAuditableEntity<int>
{
    [Required]
    public string BankId { get; set; } = string.Empty;

    [Required, MaxLength(50)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(100)]
    public string? Description { get; set; }

    public string? Icon { get; set; }

    [Required, MaxLength(50)]
    public string TransactionDomainId { get; set; } = string.Empty;

    public bool IsActive { get; set; } = true;

    [JsonIgnore]
    public virtual Bank? Bank { get; set; }

    [JsonIgnore]
    public virtual ICollection<TransferMethodCurrency> TransferMethodCurrencies { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<TransferMethodProductType> TransferMethodProductTypes { get; set; } = [];
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TransferMethodCurrency.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

public class TransferMethodCurrency : BaseAuditableEntity<int>
{
    public int TransferMethodId { get; set; }

    [Required, MaxLength(3)]
    public string SourceCurrency { get; set; } = string.Empty;

    [Required, MaxLength(3)]
    public string DestinationCurrency { get; set; } = string.Empty;

    public bool IsActive { get; set; } = true;

    [JsonIgnore]
    public virtual TransferMethod? TransferMethod { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TransferMethodProductType.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class TransferMethodProductType : BaseAuditableEntity<int>
{
    public int TransferMethodId { get; set; }

    [Required]
    public LocalBankProductType LocalBankProductType { get; set; }

    public bool IsActive { get; set; } = true;

    [JsonIgnore]
    public virtual TransferMethod? TransferMethod { get; set; }

    [JsonIgnore]
    public virtual ICollection<CountryBankProductTypeConfig> CountryBankProductTypeConfigs { get; set; } = [];
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TutorialAction.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class TutorialAction : BaseAuditableEntity<int>
{
    public required int Step { get; set; }
    public required string AppScreenId { get; set; }
    public required string ActionId { get; set; }
    public string? TutorialDescription { get; set; } = string.Empty;
    public required RedirectionBehavior RedirectionBehavior { get; set; }
    public required string BankId { get; set; }
    public bool IsActive { get; set; } = true;
    [JsonIgnore]
    public virtual Bank Bank { get; set; } = null!;
    [JsonIgnore]
    public virtual AppScreen AppScreen { get; set; } = null!;
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\TutorialProgress.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class TutorialProgress : BaseAuditableEntity<int>
    {
        /// <summary>
        /// ID del usuario que abrió la funcionalidad
        /// </summary>
        public Guid UserProfileId { get; set; }

        /// <summary>
        /// Número de paso
        /// </summary>
        public required int Step { get; set; }

        /// <summary>
        /// Pantalla donde el tutorial se mostrará
        /// </summary>
        public required string ScreenId { get; set; }

        /// <summary>
        /// Acción que desencadena el tutorial
        /// </summary>
        public required string ActionId { get; set; }

        /// <summary>
        /// Descripción del tutorial
        /// </summary>
        public string? TutorialDescription { get; set; } = string.Empty;

        /// <summary>
        /// Banco del tutorial
        /// </summary>
        public string TutorialBankId { get; set; } = string.Empty;

        /// <summary>
        /// Usuario del registro
        /// </summary>
        public virtual UserProfile? UserProfile { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Tutorials.cs
```csharp
using System.ComponentModel.DataAnnotations;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class Tutorials : BaseAuditableEntity<int>
    {

        /// <summary>
        /// Título del tutorial
        /// </summary>
        [Required]
        public string Title { get; set; } = string.Empty;

        /// <summary>
        /// Categoría del tutorial
        /// </summary>
        [Required]
        public TutorialCategory? Category { get; set; } = TutorialCategory.Others;

        /// <summary>
        /// Url que nos lleva al video del tutorial
        /// </summary>
        [Required]
        public string? TutorialUrl { get; set; }

        /// <summary>
        /// Url de la miniatura del tutorial
        /// </summary>
        public string? ThumbnailUrl { get; set; }

        /// <summary>
        /// Duración del video
        /// </summary>
        public TimeSpan? Duration { get; set; }

        /// <summary>
        /// Banco perteneciente al tutorial
        /// </summary>
        public string TutorialBankId { get; set; } = string.Empty;

        /// <summary>
        /// Si es activo o no
        /// </summary>
        public bool IsActive { get; set; } = true;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UiGroup.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa los agrupadores a nivel de UI (Modal, Drawer, Section, etc...)
    /// </summary>
    public class UiGroup : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Indica el nombre para identificar el agrupador.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Name { get; set; }

        /// <summary>
        /// Indica la etiqueta que se mostrará en pantalla.
        /// </summary>
        [Required]
        [MaxLength(60)]
        public required string Label { get; set; }

        /// <summary>
        /// Indica el tipo de agrupador.
        /// </summary>
        [Required]
        public required UiGroupType Type { get; set; }

        /// <summary>
        /// Indica si el agrupador está activo.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// ID de la pantalla donde se encuentra el agrupador.
        /// </summary>
        public required string AppScreenId { get; set; }

        /// <summary>
        /// ID del banco al que pertenece el agrupador.
        /// </summary>
        public required string BankId { get; set; }

        // Relaciones
        /// <summary>
        /// Indica en qué pantalla se encuentra el agrupador.
        /// </summary>
        [JsonIgnore]
        public virtual AppScreen AppScreen { get; set; } = null!;

        /// <summary>
        /// Indica a qué banco pertenece el agrupador.
        /// </summary>
        [JsonIgnore]
        public virtual Bank Bank { get; set; } = null!;

        // Relaciones foráneas
        [JsonIgnore]
        public virtual ICollection<OptionItem> OptionItems { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\User.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class User : BaseAuditableEntity<Guid>
{
    /// <summary>
    /// ID de usuario en Auth0.
    /// </summary>
    [Required]
    public required string Auth0UserId { get; set; } = "auth0|empty";

    /// <summary>
    /// Indica si las notificaciones están habilitadas para el usuario.
    /// </summary>
    public bool HasNotificationEnabled { get; set; }

    /// <summary>
    /// Estado del usuario.
    /// </summary>
    public UserStatus? UserStatus { get; set; } = Enums.UserStatus.Created;

    /// <summary>
    /// Nombre de usuario
    /// </summary>
    public string? Username { get; set; }

    /// <summary>
    /// PersonHash de la persona en People
    /// </summary>
    public string? PeopleId { get; set; }

    /// <summary>
    /// Nombre completo del usuario
    /// </summary>
    public string? UserFullName { get; set; }

    /// <summary>
    /// Sexo del usuario
    /// </summary>
    public string? Sex { get; set; }

    /// <summary>
    /// Ruta de acceso a la foto de perfil del usuario
    /// </summary>
    public string? ProfilePictureKey { get; set; }

    /// <summary>
    /// Flag que indica si el usuario ha aceptado los terminos y condiciones
    /// </summary>
    public bool HasAcceptedTerms { get; set; }

    /// <summary>
    /// Permite definir si el usuario quiere o no mostrar su monto.
    /// </summary>
    public bool ShowAmount { get; set; } = true;

    /// <summary>
    /// Es para indicar si el usuario es o no un cliente existente
    /// </summary>
    public bool IsExistingCustomer { get; set; } = false;

    /// <summary>
    /// Lenguaje para la app configurado por el usuario
    /// </summary>
    public string? Language { get; set; }

    /// <summary>
    /// Nombre corto del usuario (primer nombre y primer apellido)
    /// </summary>
    public string? ShortName { get; set; }

    /// <summary>
    /// Último banco al que ha ingresado el usuario
    /// </summary>
    public string? LastUserBankId { get; set; }

    /// <summary>
    /// Método de autenticación utilizado por el usuario
    /// </summary>
    public AuthenticationMethod? AuthenticationMethod { get; set; }

    /// <summary>
    /// Fecha de nacimiento del usuario
    /// </summary>
    public DateTime? BirthDate { get; set; }

    /// <summary>
    /// Flag que indica si es un usuario genérico para ambiente QA
    /// </summary>
    public bool? IsGenericUser { get; set; } = false;

    // Propiedades de navegación para las relaciones
    [JsonIgnore]
    public virtual ICollection<Device> Devices { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<BiometricAccount> BiometricAccounts { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<Kyc> Kycs { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<FavoriteTransaction> FavoriteTransactions { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<UserFavoriteFunctionality> UserFavoriteFunctionalities { get; set; } = [];
    [JsonIgnore]
    public virtual Onboarding Onboarding { get; set; } = null!;
    [JsonIgnore]
    public virtual ICollection<OnboardingHistory> OnboardingHistories { get; set; } = [];

    public virtual ICollection<NotificationConfig> NotificationConfigs { get; set; } = [];
    [JsonIgnore]
    public virtual ICollection<Notification> Notifications { get; set; } = [];
    [JsonIgnore]
    public virtual ICollection<NotificationHistory> NotificationHistories { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<UserProfile> UserProfiles { get; set; } = [];

    [JsonIgnore]
    public virtual ICollection<UserTutorials> UserTutorials { get; set; } = [];

    [JsonIgnore]
    public virtual UserFailedAttempt? UserFailedAttempt { get; set; }

    [JsonIgnore]
    public virtual Bank? Bank { get; set; } = null!;

    [JsonIgnore]
    public virtual FailedOpportunity? FailedOpportunity { get; set; } = null!;
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserCondition.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserCondition : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Id del usuario que ha aceptado términos y condiciones
        /// </summary>
        public Guid UserProfileId { get; set; }

        /// <summary>
        /// Condición de términos y condiciones
        /// </summary>
        public string? Condition { get; set; }

        /// <summary>
        /// Subcondición si aplica
        /// </summary>
        public string? SubCondition { get; set; }

        /// <summary>
        /// Perfil del usuario que aceptó términos y condiciones
        /// </summary>
        [JsonIgnore]
        public virtual UserProfile? UserProfile { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserFailedAttempt.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities;

public class UserFailedAttempt : BaseAuditableEntity<int>
{
    public Guid UserId { get; set; }

    public int AttemptNumber { get; set; }

    public DateTime LastAttemptAt { get; set; }

    public virtual User? User { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserFavoriteFunctionality.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserFavoriteFunctionality : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al usuario que ha marcado la funcionalidad como favorita.
        /// </summary>
        [Required]
        [ForeignKey("User")]
        public Guid UserId { get; set; }

        /// <summary>
        /// Referencia a la funcionalidad específica que ha sido marcada como favorita por el usuario.
        /// </summary>
        [Required]
        [ForeignKey("Functionality")]
        public int FunctionalityId { get; set; }

        /// <summary>
        /// Estado de la relación favorita.
        /// </summary>
        [Required]
        public string Status { get; set; } = "Active";

        [JsonIgnore]
        /// <summary>
        /// Usuario relacionado.
        /// </summary>
        public virtual User User { get; set; } = null!;

    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserFeatureState.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserFeatureState : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Referencia al ID del usuario asociado al feature.
        /// </summary>
        public Guid UserProfileId { get; set; }

        /// <summary>
        /// Referencia a un elemento asociado a este user feature.
        /// </summary>
        public string? ReferenceKey { get; set; }

        /// <summary>
        /// Referencia a un feature en especifico.
        /// </summary>
        [Required]
        public UserFeatureCategory Category { get; set; }

        /// <summary>
        /// Estado actual del UI feature.
        /// </summary
        public UserFeatureStatus? Status { get; set; }

        /// <summary>
        /// Información adicional relacionada al feature.
        /// </summary
        public string? Data { get; set; }

        /// <summary>
        /// Fecha de siguiente aparicion en UTC.
        /// </summary>
        public DateTime? NextShowAt { get; set; }

        /// <summary>
        /// Propiedad de navegación UserProfile.
        /// </summary>
        [JsonIgnore]
        public virtual UserProfile? UserProfile { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserFunctionality.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa la relación entre un usuario y una funcionalidad en el sistema.
    /// </summary>
    public class UserFunctionality : BaseAuditableEntity<int>
    {
        /// <summary>
        /// Identificador único del usuario asociado al beneficiario.
        /// </summary>
        [Required]
        public Guid? ProfileId { get; set; }

        /// <summary>
        /// Identificador de la funcionalidad.
        /// </summary>
        [Required]
        public int FunctionalityId { get; set; }

        /// <summary>
        /// Indica si la funcionalidad está activa para el usuario.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Fecha en la que la funcionalidad fue asignada al usuario.
        /// </summary>
        public DateTime AssignedDate { get; set; } = DateTime.UtcNow;

        // Relaciones
        [JsonIgnore]
        [ForeignKey(nameof(ProfileId))]
        public virtual UserProfile Profile { get; set; } = null!;

        [ForeignKey(nameof(FunctionalityId))]
        public virtual Functionality Functionality { get; set; } = null!; // Asegúrate de tener una clase Functionality en tu dominio
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserOptionItem.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa la relación entre un usuario y una opción en el sistema.
    /// </summary>
    public class UserOptionItem : BaseAuditableEntity<Guid>
    {
        /// <summary>
        /// ID de la opción relacionada.
        /// </summary>
        [Required]
        public required Guid OptionItemId { get; set; }

        /// <summary>
        /// ID del perfil de usuario relacionado.
        /// </summary>
        [Required]
        public required Guid UserProfileId { get; set; }

        /// <summary>
        /// Indica si la opción está activa para el usuario.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Indica si la opción está desactivada para el usuario de forma manual.
        /// </summary>
        public bool IsManuallyDisabled { get; set; } = false;

        /// <summary>
        /// Indica el orden en que se carga la opción.
        /// </summary>
        [Required]
        public required int Priority { get; set; }

        // Relaciones
        /// <summary>
        /// Indica el perfil del usuario asociado a la opción.
        /// </summary>
        [JsonIgnore]
        public virtual UserProfile UserProfile { get; set; } = null!;

        /// <summary>
        /// Indica la opción asociada con el perfil.
        /// </summary>
        [JsonIgnore]
        public virtual OptionItem OptionItem { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserProduct.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa un producto en el sistema
    /// </summary>
    public class UserProduct : BaseAuditableEntity<Guid>
    {
        /// <summary>
        /// Referencia al perfil del usuario
        /// </summary>
        [Required]
        public Guid ProfileId { get; set; }

        /// <summary>
        /// Tipo de producto (ENUM)
        /// </summary>
        [Required]
        public ProductType ProductType { get; set; }

        /// <summary>
        /// Número del producto
        /// </summary>
        [Required]
        [MaxLength(50)]
        public string ProductNumber { get; set; } = null!;

        /// <summary>
        /// Código del tipo de producto ( Debit Card: C, T / Account: SAV, NOW ... )
        /// </summary>
        [Required]
        [MaxLength(20)]
        public string ProductCodeType { get; set; } = null!;

        /// <summary>
        /// Alías personalizable del producto
        /// </summary>
        [Required]
        [MaxLength(255)]
        public string Alias { get; set; } = null!;

        /// <summary>
        /// Indica si el producto está activo
        /// </summary>
        [Required]
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Indica si el producto tiene movimientos de crédito
        /// </summary>
        [Required]
        public bool HasCreditMovements { get; set; } = false;

        /// <summary>
        /// Url de la imágen del producto
        /// </summary>
        [Required]
        [MaxLength(1000)]
        public string ImageUrl { get; set; } = null!;

        /// <summary>
        /// Sub estado tarjeta entregada,Bloqueada,etc (ENUM)
        /// </summary>
        public CardSubStatus? CardSubStatus { get; set; }

        /// <summary>
        /// Nombre del archivo QR almacenado en S3 (ej. qr_12345.png)
        /// </summary>
        [MaxLength(300)]
        public string? QrFileName { get; set; }

        /// <summary>
        /// Indica si el producto es favorito
        /// </summary>
        [Required]
        public bool IsFavorite { get; set; } = false;

        // Relaciones
        [JsonIgnore]
        public virtual UserProfile UserProfile { get; set; } = null!;
        public virtual ICollection<UserSubProduct> UserSubProducts { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserProfile.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserProfile : BaseAuditableEntity<Guid>
    {
        /// <summary>
        /// User Id de la tabla usuario
        /// </summary>
        public Guid? UserId { get; set; }
        /// <summary>
        /// Tipo de documento del perfil.
        /// </summary>
        [Required]
        public required string DocumentType { get; set; }

        /// <summary>
        /// Número de documento del perfil.
        /// </summary>
        [Required]
        public required string DocumentNumber { get; set; }

        /// <summary>
        /// País de identificación del perfil.
        /// </summary>
        public string? CountryCode { get; set; }

        /// <summary>
        /// Número de teléfono del perfil.
        /// </summary>
        public string? PhoneNumber { get; set; }

        /// <summary>
        /// Prefijo del número celular. Ex: +505, +506, etc.
        /// </summary>
        public string? PhonePrefix { get; set; }

        /// <summary>
        /// Dirección de correo electrónico del perfil.
        /// </summary>
        public string? Email { get; set; }

        /// <summary>
        /// CIF del perfil.
        /// </summary>
        public string? CIF { get; set; }

        /// <summary>
        /// ID del banco asociado al perfil.
        /// </summary>
        [Required]
        public required string? BankID { get; set; }

        /// <summary>
        /// Indica si el perfil está activo.
        /// </summary>
        public bool IsActive { get; set; }

        // Propiedades de navegación para las relaciones

        public virtual User User { get; set; } = null!;

        [JsonIgnore]
        public virtual Bank Bank { get; set; } = null!;

        [JsonIgnore]
        public virtual ICollection<UserRequest> UserRequests { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<FavoriteGroup> FavoriteGroups { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserProduct> UserProducts { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserFunctionality> UserFunctionalities { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<Transaction> Transactions { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<ProfileAddress> ProfileAdresses { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserTransactionCondition> UserTransactionConditions { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserCondition> UserConditions { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserQuickAction> UserQuickActions { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<TutorialProgress> TutorialProgress { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserOptionItem> UserOptionItems { get; set; } = [];

        [JsonIgnore]
        public virtual ICollection<UserFeatureState> UserFeatureStates { get; set; } = [];
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserQuickAction.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Domain.Entities
{
    /// <summary>
    /// Representa la relación entre un usuario y un quick action en el sistema.
    /// </summary>
    public class UserQuickAction : BaseAuditableEntity<Guid>
    {
        /// <summary>
        /// Identificador del Quick Action
        /// </summary>
        [Required]
        public required Guid QuickActionId { get; set; }

        /// <summary>
        /// Identificador único del usuario asociado al beneficiario.
        /// </summary>
        [Required]
        public required Guid UserProfileId { get; set; }

        /// <summary>
        /// Indica si el quick action está activo para el usuario.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Indica el orden en que se carga el item atajo
        /// </summary>
        [Required]
        public required int Order { get; set; }

        // Relaciones
        [JsonIgnore]
        [ForeignKey(nameof(UserProfileId))]
        public virtual UserProfile UserProfile { get; set; } = null!;

        [JsonIgnore]
        [ForeignKey(nameof(QuickActionId))]
        public virtual QuickAction QuickAction { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserRequest.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

/// <summary>
/// Guarda el registro de una solicitud
/// </summary>
public class UserRequest : BaseAuditableEntity<int>
{
    /// <summary>
    /// ID de la tabla usuarios
    /// </summary>
    public Guid UserProfileId { get; set; }

    /// <summary>
    /// Tipo de solicitud
    /// </summary>
    [Required]
    public required RequestType Type { get; set; }

    /// <summary>
    /// Tipo de producto, en caso sea solicitud de producto
    /// </summary>
    public ProductType? SubType { get; set; }

    /// <summary>
    /// Sub clasificacion de un producto, en el caso de que una soliciutd sea de tipo producto
    /// </summary>
    public string? SubTypeProduct { get; set; }

    /// <summary>
    /// Información relacionada a la solicitud
    /// </summary>Ñ
    [Required]
    public required string Data { get; set; }

    /// <summary>
    /// Estado de la solicitud
    /// </summary>
    public RequestStatus? Status { get; set; } = RequestStatus.Initialized;

    /// <summary>
    /// Código de error en caso de estado Fallido
    /// </summary>
    public string? ErrorCode { get; set; }

    /// <summary>
    /// Mensaje de error en caso de estado Fallido
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Id de solicitudes externas
    /// </summary>
    public string? ExternalRequestId { get; set; }

    /// <summary>
    /// Propiedad de navegación UserProfile
    /// </summary>
    [JsonIgnore]
    public virtual UserProfile UserProfile { get; set; } = null!;
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserSubProduct.cs
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserSubProduct : BaseAuditableEntity<Guid>
    {
        /// <summary>
        /// Referencia al producto asociado
        /// </summary>
        [Required]
        [ForeignKey("UserProduct")]
        public Guid ProductId { get; set; }

        /// <summary>
        /// Tipo de sub producto
        /// </summary>
        [Required]
        public ProductType SubProductType { get; set; }

        /// <summary>
        /// Numero del subproducto
        /// </summary>
        [Required]
        [MaxLength(50)]
        public string SubProductNumber { get; set; } = null!;

        [Required]
        [MaxLength(20)]
        public string SubProductCodeType { get; set; } = null!;

        /// <summary>
        /// Indica si el sub producto está activo
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Estado logístico actual de la tarjeta física, según la trazabilidad (Tracking).
        /// </summary>
        public CardDeliveryStatus? CardDeliveryStatus { get; set; }

        // Relaciones
        public virtual UserProduct UserProduct { get; set; } = null!;
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserTransactionCondition.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities;

public class UserTransactionCondition : BaseAuditableEntity<int>
{
    public Guid UserProfileId { get; set; }

    public TransactionType TransactionType { get; set; }

    public string? TransactionSubType { get; set; }

    public virtual UserProfile? UserProfile { get; set; }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\UserTutorials.cs
```csharp
using System.Text.Json.Serialization;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Domain.Entities
{
    public class UserTutorials : BaseAuditableEntity<int>
    {
        /// <summary>
        /// ID del usuario que abrió la funcionalidad de la transacción
        /// </summary>
        public Guid UserId { get; set; }

        /// <summary>
        /// Tipo de transacción que indica que funcionalidad abrió el usuario
        /// </summary>
        public TransactionType TransactionType { get; set; }

        /// <summary>
        /// Subtipo de transacción en caso de que la transacción lo queriera
        /// </summary>
        public string? TransactionSubType { get; set; }

        [JsonIgnore]
        public virtual User? User { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\AddressType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum AddressType
    {
        [Description("OtherType")]
        [PgName("OtherType")]
        OtherType = 1,

        [Description("Home")]
        [PgName("Home")]
        Home = 2,

        [Description("Work")]
        [PgName("Work")]
        Work = 3
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\AdvertisingModule.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum AdvertisingModule
    {
        [Description("Account")]
        [PgName("Account")]
        Account = 1,

        [Description("Insurance")]
        [PgName("Insurance")]
        Insurance = 2,

        [Description("CreditCard")]
        [PgName("CreditCard")]
        CreditCard = 3,

        [Description("Loan")]
        [PgName("Loan")]
        Loan = 4,

        [Description("Coupon")]
        [PgName("Coupon")]
        Coupon = 5,

        [Description("None")]
        [PgName("None")]
        None = 6
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\AdvertisingType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum AdvertisingType
    {
        [Description("Banner")]
        [PgName("Banner")]
        Banner = 1,

        [Description("Splash")]
        [PgName("Splash")]
        Splash = 2,

        [Description("HomeHeader")]
        [PgName("HomeHeader")]
        HomeHeader = 3,
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\AuthenticationMethod.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum AuthenticationMethod
{
    /// <summary>
    /// Código
    /// </summary>
    [Description("Passcode")]
    [PgName("Passcode")]
    Passcode = 1,

    /// <summary>
    /// Biometría
    /// </summary>
    [Description("Biometric")]
    [PgName("Biometric")]
    Biometric = 2
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\BeneficiaryType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    /// <summary>
    /// Enumera los diferentes tipos de beneficiarios en el sistema.
    /// </summary>
    public enum BeneficiaryType
    {
        /// <summary>
        /// Beneficiario individual.
        /// </summary>
        [Description("Individual")]
        [PgName("Individual")]
        Individual = 1,

        /// <summary>
        /// Beneficiario empresarial.
        /// </summary>
        [Description("Company")]
        [PgName("Company")]
        Company = 2,

        /// <summary>
        /// Beneficiario de organización sin fines de lucro.
        /// </summary>
        [Description("Non-Profit Organization")]
        [PgName("NonProfitOrganization")]
        NonProfitOrganization = 3,

        /// <summary>
        /// Beneficiario gubernamental.
        /// </summary>
        [Description("Government")]
        [PgName("Government")]
        Government = 4,

        /// <summary>
        /// Beneficiario de institución financiera.
        /// </summary>
        [Description("Financial Institution")]
        [PgName("FinancialInstitution")]
        FinancialInstitution = 5,

        /// <summary>
        /// Beneficiario de entidad educativa.
        /// </summary>
        [Description("Educational Institution")]
        [PgName("EducationalInstitution")]
        EducationalInstitution = 6,

        /// <summary>
        /// Beneficiario no especificado o desconocido.
        /// </summary>
        [Description("Unknown")]
        [PgName("Unknown")]
        Unknown = 99
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CardDeliveryStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum CardDeliveryStatus
    {
        /// <summary>
        /// Tarjeta solicitada, pendiente de iniciar el proceso logístico.
        /// </summary>
        [Description("Pending")]
        [PgName("Pending")]
        Pending = 1,

        /// <summary>
        /// Proceso logístico o de solicitud en curso (En Tránsito, Listo para Retiro, Impresión).
        /// </summary>
        [Description("Processing")]
        [PgName("Processing")]
        Processing = 2,

        /// <summary>
        /// Tarjeta no pudo ser entregada/retirada, devuelta al área operativa/sucursal.
        /// </summary>
        [Description("Returned to Origin")]
        [PgName("Returned")]
        Returned = 3,

        /// <summary>
        /// El objetivo final de la tarjeta fue alcanzado (entrega exitosa o retiro en local).
        /// </summary>
        [Description("Completed (Delivered)")]
        [PgName("Completed")]
        Completed = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CardSubStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum CardSubStatus
    {
        /// <summary>
        /// Alta de nueva tarjeta
        /// </summary>
        [Description("Created")]
        [PgName("Created")]
        Created = 1,

        /// <summary>
        /// Tarjeta se confirma troquelada
        /// </summary>
        [Description("Embossed")]
        [PgName("Embossed")]
        Embossed = 2,

        /// <summary>
        /// Tarjeta enviada (a sucursal o mensajero)
        /// </summary>
        [Description("Shipped")]
        [PgName("Shipped")]
        Shipped = 3,

        /// <summary>
        /// Tarjeta recibida en sucursal
        /// </summary>
        [Description("Received")]
        [PgName("Received")]
        Received = 4,

        /// <summary>
        /// Tarjeta entregada (en sucursal o por mensajero)
        /// </summary>
        [Description("Delivered")]
        [PgName("Delivered")]
        Delivered = 5,

        /// <summary>
        /// Tarjeta devuelta (por el cliente o mensajero)
        /// </summary>
        [Description("Returned")]
        [PgName("Returned")]
        Returned = 6,

        /// <summary>
        /// Tarjeta rechazada por el cliente
        /// </summary>
        [Description("Rejected")]
        [PgName("Rejected")]
        Rejected = 7,

        /// <summary>
        /// Tarjeta activada exitosamente
        /// </summary>
        [Description("Activated")]
        [PgName("Activated")]
        Activated = 8,

        /// <summary>
        /// Estado inicial del proceso (solicitud/tracking)
        /// </summary>
        [Description("Initialized")]
        [PgName("Initialized")]
        Initialized = 9,

        /// <summary>
        /// Proceso de solicitud o tracking en curso
        /// </summary>
        [Description("Processing")]
        [PgName("Processing")]
        Processing = 10,

        /// <summary>
        /// En espera de actualización del proceso
        /// </summary>
        [Description("Pending")]
        [PgName("Pending")]
        Pending = 11,

        /// <summary>
        /// El proceso fue completado
        /// </summary>
        [Description("Completed")]
        [PgName("Completed")]
        Completed = 12,

        /// <summary>
        /// El proceso falló
        /// </summary>
        [Description("Failed")]
        [PgName("Failed")]
        Failed = 13,

        /// <summary>
        /// Se puede retirar tarjeta en ventanilla/sucursal
        /// </summary>
        [Description("ReadyForPickup")]
        [PgName("ReadyForPickup")]
        ReadyForPickup = 14,

        /// <summary>
        /// Se usa para señalizar que una cuenta no tiene una tarjeta (ni virtual, ni fisica)
        /// </summary>
        [Description("CardPending")]
        [PgName("CardPending")]
        CardPending = 15
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CategoryType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum CategoryType
    {
        [Description("Insurance")]
        [PgName("Insurance")]
        Insurance
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CertificateType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum CertificateType
{
    /// <summary>
    /// Certificados Biométricos.
    /// </summary>
    [Description("Biometric")]
    [PgName("Biometric")]
    Biometric = 1,

    /// <summary>
    /// Certificados de Documento de Identidad o Perfil de Cliente.
    /// </summary>
    [Description("Profile")]
    [PgName("Profile")]
    Profile = 2,

    /// <summary>
    /// Certificados de Autenticación de la persona
    /// </summary>
    [Description("Authentication")]
    [PgName("Authentication")]
    Authentication = 3,

    /// <summary>
    /// Certificados de FaceToFace
    /// </summary>
    [Description("FaceToFace")]
    [PgName("FaceToFace")]
    FaceToFace = 4
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CompanyType.cs
```csharp
using System.ComponentModel;

namespace DXP.Core.Database.Domain.Enums
{
    public enum CompanyType
    {
        [Description("PublicCompany")]
        PublicCompany = 1,

        [Description("PrivateCompany")]
        PrivateCompany = 2
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\ConfigurationType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum ConfigurationType
    {
        [Description("Promotions")]
        [PgName("Promotions")]
        Promotions = 1,

        [Description("News")]
        [PgName("News")]
        News = 2
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\CurrentStage.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum CurrentStage
    {
        [Description("Initial")]
        [PgName("Initial")]
        Initial = 1,

        [Description("InProgress")]
        [PgName("InProgress")]
        InProgress = 2,

        [Description("Proposal")]
        [PgName("Proposal")]
        Proposal = 3,

        [Description("ClosedWon")]
        [PgName("ClosedWon")]
        ClosedWon = 4,

        [Description("ClosedLost")]
        [PgName("ClosedLost")]
        ClosedLost = 5,

        [Description("Failed")]
        [PgName("Failed")]
        Failed = 6,
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\EmploymentStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;
public enum EmploymentStatus
{
    [Description("Employed")]
    [PgName("Employed")]
    Employed = 1,

    [Description("SelfEmployed")]
    [PgName("SelfEmployed")]
    SelfEmployed = 2,

    [Description("Student")]
    [PgName("Student")]
    Student = 3,

    [Description("Retired")]
    [PgName("Retired")]
    Retired = 4,

    [Description("Homemaker")]
    [PgName("Homemaker")]
    Homemaker = 5,

    [Description("Unemployed")]
    [PgName("Unemployed")]
    Unemployed = 6
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\GroupType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    /// <summary>
    /// Represents the different types of groups.
    /// </summary>
    public enum GroupType
    {
        /// <summary>
        /// Group for transactions.
        /// </summary>
        [Description("Transactions")]
        [PgName("Transactions")]
        Transactions = 1,

        /// <summary>
        /// Group for services.
        /// </summary>
        [Description("Services")]
        [PgName("Services")]
        Services = 2
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\Iso4217Currency.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum Iso4217Currency
    {
        [Description("CRC")]
        CRC = 188,
        [Description("DOP")]
        DOP = 214,
        [Description("HNL")]
        HNL = 340,
        [Description("NIO")]
        NIO = 558,
        [Description("USD")]
        USD = 840,
        [Description("EUR")]
        EUR = 978
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\KycStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum KycStatus
    {
        [Description("Pending")]
        [PgName("Pending")]
        Pending = 1,

        [Description("Approved")]
        [PgName("Approved")]
        Approved = 2,

        [Description("Rejected")]
        [PgName("Rejected")]
        Rejected = 3,

        [Description("Failed")]
        [PgName("Failed")]
        Failed = 4,

        [Description("Conditioned")]
        [PgName("Conditioned")]
        Conditioned = 5,

        [Description("Invalidated")]
        [PgName("Invalidated")]
        Invalidated = 6,

        /// <summary>
        /// Señaliza que fue creado pero todavía no tiene un documento de KYC generado.
        /// </summary>
        [Description("KycDocumentPending")]
        [PgName("KycDocumentPending")]
        KycDocumentPending = 7
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\LocalBankProductType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum LocalBankProductType
{
    [Description("CCTE")]
    [PgName("Account")]
    Account = 1,

    [Description("TACR")]
    [PgName("CreditCard")]
    CreditCard = 2,

    [Description("PTMO")]
    [PgName("Loan")]
    Loan = 3,

    [Description("CAHO")]
    [PgName("SavingsAccount")]
    SavingsAccount = 4
}


```

### FILE: src\DXP.Core.Database.Domain\Enums\NotificationStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum NotificationStatus
    {
        [Description("Sent")]
        [PgName("Sent")]
        Sent = 1,

        [Description("Unread")]
        [PgName("Unread")]
        Unread = 2,

        [Description("Read")]
        [PgName("Read")]
        Read = 3
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\NotificationType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum NotificationType
    {
        [Description("Sms")]
        [PgName("Sms")]
        Sms = 1,

        [Description("Email")]
        [PgName("Email")]
        Email = 2,

        [Description("Push")]
        [PgName("Push")]
        Push = 3
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\OnboardingStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum OnboardingStatus
    {
        [Description("Pending")]
        [PgName("Pending")]
        Pending = 1,

        [Description("Succeeded")]
        [PgName("Succeeded")]
        Succeeded = 2,

        [Description("WaitingForKycApproval")]
        [PgName("WaitingForKycApproval")]
        WaitingForKycManualApproval = 3,

        [Description("Processing")]
        [PgName("Processing")]
        Processing = 4,

        [Description("Completed")]
        [PgName("Completed")]
        Completed = 5,

        [Description("Failed")]
        [PgName("Failed")]
        Failed = 6
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\OtpStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum OtpStatus
    {
        [Description("Initialized")]
        [PgName("Initialized")]
        Initialized = 1,

        [Description("Confirmed")]
        [PgName("Confirmed")]
        Confirmed = 2,

        [Description("Expired")]
        [PgName("Expired")]
        Expired = 3,

        [Description("Failed")]
        [PgName("Failed")]
        Failed = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\OtpType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum OtpType
    {
        [Description("Sms")]
        [PgName("Sms")]
        Sms = 1,

        [Description("Email")]
        [PgName("Email")]
        Email = 2,

        [Description("Push")]
        [PgName("Push")]
        Push = 3,

        [Description("WhatsApp")]
        [PgName("WhatsApp")]
        WhatsApp = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\ProductType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum ProductType
{
    [Description("Account")]
    [PgName("Account")]
    Account = 1,

    [Description("Card")]
    [PgName("Card")]
    Card = 2,

    [Description("Loan")]
    [PgName("Loan")]
    Loan = 3,

    [Description("CreditCard")]
    [PgName("CreditCard")]
    CreditCard = 4,

    [Description("Insurance")]
    [PgName("Insurance")]
    Insurance = 5
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\QuickActionCategory.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum QuickActionCategory
    {
        [Description("Account")]
        [PgName("Account")]
        Account = 1,

        [Description("Insurance")]
        [PgName("Insurance")]
        Insurance = 2,

        [Description("Credit")]
        [PgName("Credit")]
        Credit = 3,

        [Description("Loan")]
        [PgName("Loan")]
        Loan = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\QuickActionType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum QuickActionType
    {
        [Description("Screen")]
        [PgName("Screen")]
        Screen = 1,

        [Description("Modal")]
        [PgName("Modal")]
        Modal = 2
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\RedirectionBehavior.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum RedirectionBehavior
{
    [Description("INT")]
    [PgName("Internal")]
    Internal = 1,

    [Description("EXT")]
    [PgName("External")]
    External = 2,

    [Description("NON")]
    [PgName("None")]
    None = 3,
}


```

### FILE: src\DXP.Core.Database.Domain\Enums\RedirectTo.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum RedirectTo
    {
        [Description("Screen")]
        [PgName("Screen")]
        Screen = 1,

        [Description("Url")]
        [PgName("Url")]
        Url = 2,

        [Description("TransactionScreen")]
        [PgName("TransactionScreen")]
        TransactionScreen = 3
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\RequestStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum RequestStatus
{
    [Description("Initialized")]
    [PgName("Initialized")]
    Initialized = 1,

    [Description("Processing")]
    [PgName("Processing")]
    Processing = 2,

    [Description("Pending")]
    [PgName("Pending")]
    Pending = 3,

    [Description("Completed")]
    [PgName("Completed")]
    Completed = 4,

    [Description("Failed")]
    [PgName("Failed")]
    Failed = 5
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\RequestType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum RequestType
{
    [Description("NewProduct")]
    [PgName("NewProduct")]
    NewProduct = 1,

    [Description("PINChange")]
    [PgName("PinChange")]
    PinChange = 2,

    [Description("CardActivation")]
    [PgName("CardActivation")]
    CardActivation = 3,

    [Description("CardRevocation")]
    [PgName("CardRevocation")]
    CardRevocation = 4,

    [Description("PhysicalCardRequest")]
    [PgName("PhysicalCardRequest")]
    PhysicalCardRequest = 5,

    [Description("CardResendShipping")]
    [PgName("CardResendShipping")]
    CardResendShipping = 6,

    [Description("FullCardCreation")]
    [PgName("FullCardCreation")]
    FullCardCreation = 7,

    [Description("PendingNewProduct")]
    [PgName("PendingNewProduct")]
    PendingNewProduct = 8,

    [Description("SignedDocumentCreation")]
    [PgName("SignedDocumentCreation")]
    SignedDocumentCreation = 9
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\ResourceType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    /// <summary>
    /// Enum que define los tipos de recursos disponibles.
    /// </summary>
    public enum ResourceType
    {
        [Description("Terms and Conditions")]
        [PgName("TermsAndConditions")]
        TermsAndConditions = 1,

        [Description("Privacy Policy")]
        [PgName("PrivacyPolicy")]
        PrivacyPolicy = 2,

        [Description("Lafise Digital Contract")]
        [PgName("LafiseDigitalContract")]
        LafiseDigitalContract = 3,

        [Description("Account Contract")]
        [PgName("AccountContract")]
        AccountContract = 4,

        [Description("Account Digital Rules")]
        [PgName("AccountDigitalRules")]
        AccountDigitalRules = 5,

        [Description("Salary Advance Contract")]
        [PgName("SalaryAdvanceContract")]
        SalaryAdvanceContract = 6,

        [Description("Account Avanz Rules")]
        [PgName("AccountAvanzRules")]
        AccountAvanzRules = 7,

        [Description("Splash Content")]
        [PgName("SplashContent")]
        SplashContent = 8,

        [Description("Own Accounts Terms and Conditions")]
        [PgName("OwnAccountsTermsAndConditions")]
        OwnAccountsTermsAndConditions = 9,

        [Description("Local Banks Terms and Conditions")]
        [PgName("LocalBanksTermsAndConditions")]
        LocalBanksTermsAndConditions = 10,

        [Description("Third Party Accounts Terms and Conditions")]
        [PgName("ThirdPartyAccountsTermsAndConditions")]
        ThirdPartyAccountsTermsAndConditions = 11,

        [Description("International Terms and Conditions")]
        [PgName("InternationalTermsAndConditions")]
        InternationalTermsAndConditions = 12,

        [Description("Service Payments Terms and Conditions")]
        [PgName("ServicePaymentsTermsAndConditions")]
        ServicePaymentsTermsAndConditions = 13,

        [Description("Credit Card Payment Terms and Conditions")]
        [PgName("CreditCardPaymentTermsAndConditions")]
        CreditCardPaymentTermsAndConditions = 14,

        [Description("Third Party Credit Card Payment Terms and Conditions")]
        [PgName("ThirdPartyCreditCardPaymentTermsAndConditions")]
        ThirdPartyCreditCardPaymentTermsAndConditions = 15,

        [Description("Supplier Payments Terms and Conditions")]
        [PgName("SupplierPaymentsTermsAndConditions")]
        SupplierPaymentsTermsAndConditions = 16,

        [Description("Fast Shipping Terms and Conditions")]
        [PgName("FastShippingTermsAndConditions")]
        FastShippingTermsAndConditions = 17,

        [Description("Salary Advance Terms and Conditions")]
        [PgName("SalaryAdvanceTermsAndConditions")]
        SalaryAdvanceTermsAndConditions = 18,

        [Description("Deposit Terms and Conditions")]
        [PgName("DepositTermsAndConditions")]
        DepositTermsAndConditions = 19,

        [Description("Withdrawal Terms and Conditions")]
        [PgName("WithdrawalTermsAndConditions")]
        WithdrawalTermsAndConditions = 20,

        [Description("Remittances Terms and Conditions")]
        [PgName("RemittancesTermsAndConditions")]
        RemittancesTermsAndConditions = 21,

        [Description("Cardless Withdrawal Terms and Conditions")]
        [PgName("CardlessWithdrawalTermsAndConditions")]
        CardlessWithdrawalTermsAndConditions = 22,

        [Description("Local Banks Credit Card Terms And Conditions")]
        [PgName("LocalBanksCreditCardTermsAndConditions")]
        LocalBanksCreditCardTermsAndConditions = 23,

        [Description("Local Banks Transfer Terms and Conditions")]
        [PgName("LocalBanksTransferTermsAndConditions")]
        LocalBanksTransferTermsAndConditions = 24,

        [Description("Insurance Terms and Conditions")]
        [PgName("InsuranceTermsAndConditions")]
        InsuranceTermsAndConditions = 25,

        [Description("Service rates and applicable conditions")]
        [PgName("ServicesRates")]
        ServicesRates = 26
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\TransactionStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum TransactionStatus
{
    [Description("Validated")]
    [PgName("Validated")]
    Validated = 1,

    [Description("Failed")]
    [PgName("Failed")]
    Failed = 2,

    [Description("Successful")]
    [PgName("Successful")]
    Successful = 3,

    [Description("InProgress")]
    [PgName("InProgress")]
    InProgress = 4,

    [Description("Reversed")]
    [PgName("Reversed")]
    Reversed = 5
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\TransactionSubStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum TransactionSubStatus
{
    [Description("Pending")]
    [PgName("Pending")]
    Pending = 1,

    [Description("Completed")]
    [PgName("Completed")]
    Completed = 2,

    [Description("Failed")]
    [PgName("Failed")]
    Failed = 3,
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\TransactionType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum TransactionType
    {
        [Description("OwnAccounts")]
        [PgName("OwnAccounts")]
        OwnAccounts = 1,

        [Description("LocalBanks")]
        [PgName("LocalBanks")]
        LocalBanks = 2,

        [Description("ThirdPartyAccounts")]
        [PgName("ThirdPartyAccounts")]
        ThirdPartyAccounts = 3,

        [Description("International")]
        [PgName("International")]
        International = 4,

        [Description("ServicePayments")]
        [PgName("ServicePayments")]
        ServicePayments = 5,

        [Description("CreditCardPayment")]
        [PgName("CreditCardPayment")]
        CreditCardPayment = 6,

        [Description("Loans")]
        [PgName("Loans")]
        Loans = 7,

        [Description("ThirdPartyLoanPayment")]
        [PgName("ThirdPartyLoanPayment")]
        ThirdPartyLoanPayment = 8,

        [Description("ThirdPartyCreditCardPayment")]
        [PgName("ThirdPartyCreditCardPayment")]
        ThirdPartyCreditCardPayment = 9,

        [Description("SupplierPayments")]
        [PgName("SupplierPayments")]
        SupplierPayments = 10,

        [Description("ThirdPartyCashAdvance")]
        [PgName("ThirdPartyCashAdvance")]
        ThirdPartyCashAdvance = 11,

        [Description("SalaryPayments")]
        [PgName("SalaryPayments")]
        SalaryPayments = 12,

        [Description("DebiNet")]
        [PgName("DebiNet")]
        DebiNet = 13,

        [Description("FastShipping")]
        [PgName("FastShipping")]
        FastShipping = 14,

        [Description("SalaryAdvance")]
        [PgName("SalaryAdvance")]
        SalaryAdvance = 15,

        [Description("ECCAPPS")]
        [PgName("Eccaps")]
        Eccaps = 16,

        [Description("ManagementWithdrawCheckRequest")]
        [PgName("ManagementWithdrawCheckRequest")]
        ManagementWithdrawCheckRequest = 17,

        [Description("CreditCardBalanceAdvance")]
        [PgName("CreditCardBalanceAdvance")]
        CreditCardBalanceAdvance = 18,

        [Description("CreditCardPrepaidRecharge")]
        [PgName("CreditCardPrepaidRecharge")]
        CreditCardPrepaidRecharge = 19,

        [Description("ThirdPartyCreditCardPrepaidRecharge")]
        [PgName("ThirdPartyCreditCardPrepaidRecharge")]
        ThirdPartyCreditCardPrepaidRecharge = 20,

        [Description("CancelCheck")]
        [PgName("CancelCheck")]
        CancelCheck = 21,

        [Description("InGroup")]
        [PgName("InGroup")]
        InGroup = 22,

        [Description("LocalRemittance")]
        [PgName("LocalRemittance")]
        LocalRemittance = 23,

        [Description("Deposit")]
        [PgName("Deposit")]
        Deposit = 24,

        [Description("Withdrawal")]
        [PgName("Withdrawal")]
        Withdrawal = 25,

        [Description("Remittances")]
        [PgName("Remittances")]
        Remittances = 26,

        [Description("LoanDisbursements")]
        [PgName("LoanDisbursements")]
        LoanDisbursements = 27,

        [Description("CardlessWithdrawal")]
        [PgName("CardlessWithdrawal")]
        CardlessWithdrawal = 28,

        [Description("Payroll")]
        [PgName("Payroll")]
        Payroll = 29,

        [Description("Alias")]
        [PgName("Alias")]
        Alias = 30,
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\TutorialCategory.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum TutorialCategory
    {
        [Description("SendAndReceiveMoney")]
        [PgName("SendAndReceiveMoney")]
        SendAndReceiveMoney = 1,

        [Description("PayForServices")]
        [PgName("PayForServices")]
        PayForServices = 2,

        [Description("Others")]
        [PgName("Others")]
        Others = 3,

        [Description("SettingsAndSecurity")]
        [PgName("SettingsAndSecurity")]
        SettingsAndSecurity = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\UiGroupType.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum UiGroupType
    {
        [Description("Modal")]
        [PgName("Modal")]
        Modal = 1,

        [Description("Drawer")]
        [PgName("Drawer")]
        Drawer = 2,

        [Description("Card")]
        [PgName("Card")]
        Card = 3,

        [Description("Carousel")]
        [PgName("Carousel")]
        Carousel = 4
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\UserFeatureCategory.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum UserFeatureCategory
    {
        [Description("FirstDepositBanner")]
        [PgName("FirstDepositBanner")]
        FirstDepositBanner = 0,

        [Description("NewFeaturesBanner")]
        [PgName("NewFeaturesBanner")]
        NewFeaturesBanner = 1,

        [Description("FirstAccountBanner")]
        [PgName("FirstAccountBanner")]
        FirstAccountBanner = 2,
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\UserFeatureStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums;

public enum UserFeatureStatus
{
    [Description("Active")]
    [PgName("Active")]
    Active = 0,

    [Description("Hidden")]
    [PgName("Hidden")]
    Hidden = 1,

    [Description("Completed")]
    [PgName("Completed")]
    Completed = 2,
}

```

### FILE: src\DXP.Core.Database.Domain\Enums\UserStatus.cs
```csharp
using System.ComponentModel;
using NpgsqlTypes;

namespace DXP.Core.Database.Domain.Enums
{
    public enum UserStatus
    {
        [Description("Created")]
        [PgName("Created")]
        Created = 1,

        [Description("InProgress")]
        [PgName("InProgress")]
        InProgress = 2,

        [Description("Completed")]
        [PgName("Completed")]
        Completed = 3,

        [Description("Blocked")]
        [PgName("Blocked")]
        Blocked = 4,

        [Description("Deleted")]
        [PgName("Deleted")]
        Deleted = 5
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Interfaces\IVersionable.cs
```csharp
namespace DXP.Core.Database.Domain.Interfaces;

public interface IVersionable
{
    string MinVersion { get; set; }
    string? MaxVersion { get; set; }
}


```

### FILE: src\DXP.Core.Database.Infrastructure\Cache\CustomCacheService.cs
```csharp
using DXP.Core.Application.Common.Policies;
using DXP.Core.Database.Domain.Constants;
using EasyCaching.Core;
using EasyCaching.Core.Configurations;
using EasyCaching.Redis;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Polly.Wrap;

namespace DXP.Core.Database.Infrastructure.Cache
{
    public class CustomCacheService : ICacheService
    {
        private readonly IEasyCachingProvider _readCache;
        private readonly IEasyCachingProvider _writeCache;
        private readonly ILogger<CustomCacheService> _logger;
        public CustomCacheService(
            IEasyCachingProviderFactory factory,
            ILogger<CustomCacheService> logger,
            IOptionsMonitor<EasyCachingOptions> cacheOptions,
            IServiceProvider serviceProvider)
        {
            _readCache = factory.GetCachingProvider(CacheProvider.RedisRead);
            _writeCache = factory.GetCachingProvider(CacheProvider.RedisWrite);

            var redisOptions = serviceProvider.GetRequiredService<IOptionsMonitor<RedisOptions>>();
            var redisWriteOptions = redisOptions?.Get(CacheProvider.RedisWrite);

            _logger = logger;
        }

        public async Task<T> GetAsync<T>(string key, CancellationToken token = default)
        {
            return await GetInternalAsync<T>(key, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, null, null, null, factory, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, TimeSpan slidingExpiration, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, slidingExpiration, null, null, factory, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, DateTimeOffset absoluteExpiration, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, null, absoluteExpiration, null, factory, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, TimeSpan slidingExpiration, DateTimeOffset absoluteExpiration, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, slidingExpiration, absoluteExpiration, null, factory, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, TimeSpan slidingExpiration, TimeSpan absoluteExpirationRelativeToNow, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, slidingExpiration, null, absoluteExpirationRelativeToNow, factory, token);
        }

        public async Task<T> GetOrCreateAsync<T>(string key, TimeSpan? slidingExpiration, DateTimeOffset? absoluteExpiration, TimeSpan? absoluteExpirationRelativeToNow, Func<Task<T>> factory, CancellationToken token = default)
        {
            return await GetOrCreateInternalAsync(key, slidingExpiration, absoluteExpiration, absoluteExpirationRelativeToNow, factory, token);
        }

        public async Task SetAsync<T>(string key, T value, CancellationToken token = default)
        {
            await SetInternalAsync(key, value, null, null, null, token);
        }

        public async Task SetAsync<T>(string key, T value, DateTimeOffset absoluteExpiration,
            CancellationToken token = default)
        {
            await SetInternalAsync(key, value, null, absoluteExpiration, null, token);
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan slidingExpiration,
            CancellationToken token = default)
        {
            await SetInternalAsync(key, value, slidingExpiration, null, null, token);
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan? slidingExpiration, DateTimeOffset? absoluteExpiration,
            CancellationToken token = default)
        {
            await SetInternalAsync(key, value, slidingExpiration, absoluteExpiration, null, token);
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan? slidingExpiration, TimeSpan? absoluteExpirationRelativeToNow,
            CancellationToken token = default)
        {
            await SetInternalAsync(key, value, slidingExpiration, null, absoluteExpirationRelativeToNow, token);
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan? slidingExpiration, DateTimeOffset? absoluteExpiration,
            TimeSpan? absoluteExpirationRelativeToNow, CancellationToken token = default)
        {
            await SetInternalAsync(key, value, slidingExpiration, absoluteExpiration, absoluteExpirationRelativeToNow, token);
        }

        public async Task RemoveAsync(string key, CancellationToken token = default)
        {
            try
            {

                await _writeCache.RemoveAsync(key, token);

            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Cache remove failed for {Key}", key);
            }
        }

        public async Task RemoveByPrefixAsync(string keyPrefix, CancellationToken token = default)
        {
            try
            {
                _logger.LogInformation($"Removing keys from cache by prefix {keyPrefix}");

                await _writeCache.RemoveByPrefixAsync(keyPrefix, token);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Cache by prefixes remove failed for {Key}", keyPrefix);
            }
        }

        private async Task<T> GetInternalAsync<T>(string key, CancellationToken token = default)
        {
            try
            {
                var cacheValue = await _readCache.GetAsync<T>(key, token);

                return cacheValue.Value;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Cache GET failed for {Key}", key);
                return default;
            }
        }

        private async Task<T> GetOrCreateInternalAsync<T>(string key, TimeSpan? slidingExpiration, DateTimeOffset? absoluteExpiration, TimeSpan? absoluteExpirationRelativeToNow, Func<Task<T>> factory, CancellationToken token = default)
        {
            var value = await GetInternalAsync<T>(key, token);

            if (value != null) return value;

            value = await factory();

            if (value != null)
            {
                await SetInternalAsync(key, value, slidingExpiration, absoluteExpiration, absoluteExpirationRelativeToNow, token);
            }

            return value;
        }

        private async Task SetInternalAsync<T>(string key, T value, TimeSpan? slidingExpiration, DateTimeOffset? absoluteExpiration, TimeSpan? absoluteExpirationRelativeToNow,
        CancellationToken token = default)
        {
            var cacheEntryOptions = new DistributedCacheEntryOptions();

            if (slidingExpiration.HasValue)
            {
                cacheEntryOptions.SlidingExpiration = slidingExpiration.Value;
            }

            if (absoluteExpiration.HasValue)
            {
                cacheEntryOptions.AbsoluteExpiration = absoluteExpiration.Value;
            }

            if (absoluteExpirationRelativeToNow.HasValue)
            {
                cacheEntryOptions.AbsoluteExpirationRelativeToNow = absoluteExpirationRelativeToNow.Value;
            }

            if (!slidingExpiration.HasValue && !absoluteExpiration.HasValue && !absoluteExpirationRelativeToNow.HasValue)
            {
                cacheEntryOptions.SetSlidingExpiration(TimeSpan.FromMinutes(10));
                cacheEntryOptions.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30);
            }

            try
            {
                await _writeCache.SetAsync(key, value, cacheEntryOptions!.SlidingExpiration!.Value, token);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Cache SET failed for {Key}", key);
            }
        }

        public string GetCacheKey(string key)
        {
            return key;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Common\PostgresContextExtensions.cs
```csharp
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Npgsql;

namespace DXP.Core.Database.Infrastructure.Common
{
    public static class PostgresContextExtensions
    {
        public static void MapEnumsToDataSource(this NpgsqlDataSourceBuilder builder)
        {
            builder
                .MapEnum<BeneficiaryType>("dxp_app.beneficiary_type")
                .MapEnum<CertificateType>("dxp_app.certificate_type")
                .MapEnum<ConfigurationType>("dxp_app.configuration_type")
                .MapEnum<EmploymentStatus>("dxp_app.employment_status")
                .MapEnum<KycStatus>("dxp_app.kyc_status")
                .MapEnum<NotificationType>("dxp_app.notification_type")
                .MapEnum<OnboardingStatus>("dxp_app.onboarding_status")
                .MapEnum<OtpStatus>("dxp_app.otp_status")
                .MapEnum<OtpType>("dxp_app.otp_type")
                .MapEnum<TransactionType>("dxp_app.transaction_type")
                .MapEnum<UserStatus>("dxp_app.user_status")
                .MapEnum<RequestType>("dxp_app.request_type")
                .MapEnum<RequestStatus>("dxp_app.request_status")
                .MapEnum<ProductType>("dxp_app.product_type")
                .MapEnum<GroupType>("dxp_app.group_type")
                .MapEnum<NotificationStatus>("dxp_app.notification_status")
                .MapEnum<ResourceType>("dxp_app.resource_type")
                .MapEnum<ProcessType>("dxp_app.process_type")
                .MapEnum<TransactionStatus>("dxp_app.transaction_status")
                .MapEnum<TransactionSubStatus>("dxp_app.transaction_sub_status")
                .MapEnum<AuthenticationMethod>("dxp_app.authentication_method")
                .MapEnum<TutorialCategory>("dxp_app.tutorial_category")
                .MapEnum<AddressType>("dxp_app.address_type")
                .MapEnum<CardSubStatus>("dxp_app.card_sub_status")
                .MapEnum<AdvertisingType>("dxp_app.advertising_type")
                .MapEnum<RedirectTo>("dxp_app.redirect_to")
                .MapEnum<QuickActionType>("dxp_app.quick_action_type")
                .MapEnum<QuickActionCategory>("dxp_app.quick_action_category")
                .MapEnum<LocalBankProductType>("dxp_app.local_bank_product_type")
                .MapEnum<RedirectionBehavior>("dxp_app.redirection_behavior")
                .MapEnum<AdvertisingModule>("dxp_app.advertising_module")
                .MapEnum<UiGroupType>("dxp_app.ui_group_type")
                .MapEnum<CategoryType>("dxp_app.category_type")
                .MapEnum<CurrentStage>("dxp_app.current_stage")
                .MapEnum<UserFeatureCategory>("dxp_app.user_feature_category")
                .MapEnum<CardDeliveryStatus>("dxp_app.card_delivery_status")
                .MapEnum<UserFeatureStatus>("dxp_app.user_feature_status")
                .MapEnum<FlowType>("dxp_app.flow_type");
        }

        public static void RegisterEnums(this ModelBuilder builder)
        {
            builder
                .HasPostgresEnum<BeneficiaryType>("dxp_app", "beneficiary_type")
                .HasPostgresEnum<CertificateType>("dxp_app", "certificate_type")
                .HasPostgresEnum<ConfigurationType>("dxp_app", "configuration_type")
                .HasPostgresEnum<EmploymentStatus>("dxp_app", "employment_status")
                .HasPostgresEnum<KycStatus>("dxp_app", "kyc_status")
                .HasPostgresEnum<NotificationType>("dxp_app", "notification_type")
                .HasPostgresEnum<OnboardingStatus>("dxp_app", "onboarding_status")
                .HasPostgresEnum<OtpStatus>("dxp_app", "otp_status")
                .HasPostgresEnum<OtpType>("dxp_app", "otp_type")
                .HasPostgresEnum<TransactionType>("dxp_app", "transaction_type")
                .HasPostgresEnum<UserStatus>("dxp_app", "user_status")
                .HasPostgresEnum<RequestType>("dxp_app", "request_type")
                .HasPostgresEnum<RequestStatus>("dxp_app", "request_status")
                .HasPostgresEnum<ProductType>("dxp_app", "product_type")
                .HasPostgresEnum<GroupType>("dxp_app", "group_type")
                .HasPostgresEnum<NotificationStatus>("dxp_app", "notification_status")
                .HasPostgresEnum<ResourceType>("dxp_app", "resource_type")
                .HasPostgresEnum<ProcessType>("dxp_app", "process_type")
                .HasPostgresEnum<TransactionStatus>("dxp_app", "transaction_status")
                .HasPostgresEnum<TransactionSubStatus>("dxp_app", "transaction_sub_status")
                .HasPostgresEnum<AuthenticationMethod>("dxp_app", "authentication_method")
                .HasPostgresEnum<TutorialCategory>("dxp_app", "tutorial_category")
                .HasPostgresEnum<AddressType>("dxp_app", "address_type")
                .HasPostgresEnum<CardSubStatus>("dxp_app", "card_sub_status")
                .HasPostgresEnum<AdvertisingType>("dxp_app", "advertising_type")
                .HasPostgresEnum<RedirectTo>("dxp_app", "redirect_to")
                .HasPostgresEnum<QuickActionType>("dxp_app", "quick_action_type")
                .HasPostgresEnum<QuickActionCategory>("dxp_app", "quick_action_category")
                .HasPostgresEnum<LocalBankProductType>("dxp_app", "local_bank_product_type")
                .HasPostgresEnum<RedirectionBehavior>("dxp_app", "redirection_behavior")
                .HasPostgresEnum<AdvertisingModule>("dxp_app", "advertising_module")
                .HasPostgresEnum<UiGroupType>("dxp_app", "ui_group_type")
                .HasPostgresEnum<CategoryType>("dxp_app", "category_type")
                .HasPostgresEnum<CurrentStage>("dxp_app", "current_stage")
                .HasPostgresEnum<UserFeatureCategory>("dxp_app", "user_feature_category")
                .HasPostgresEnum<CardDeliveryStatus>("dxp_app", "card_delivery_status")
                .HasPostgresEnum<UserFeatureStatus>("dxp_app", "user_feature_status")
                .HasPostgresEnum<FlowType>("dxp_app", "flow_type");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Common\QueryableExtensions.cs
```csharp
using System.Linq.Expressions;
using DXP.Core.Domain.Common;
using DXP.Core.Domain.Common.Sorting;
using DXP.Core.Domain.Enums;

namespace DXP.Core.Database.Infrastructure.Common
{
    public static class QueryableExtensions
    {
        public static IQueryable<T> ApplyFilter<T, TSearch>(this IQueryable<T> query,
            IList<SearchFieldMutator<T, TSearch>>? supportedFilters, TSearch filter)
        {
            if (EqualityComparer<TSearch>.Default.Equals(filter, default) || supportedFilters == null || !supportedFilters.Any())
                return query;

            return supportedFilters.Aggregate(query,
                (current, searchFieldMutator) => searchFieldMutator.ApplyFilters(filter, current));
        }

        public static IQueryable<T> ApplySort<T>(this IQueryable<T>? query, List<SortingByColumn>? sorts)
        {
            if (query == null || sorts == null || sorts.Count == 0)
                return query ?? throw new ArgumentNullException(nameof(query), "Query cannot be null or empty.");

            var type = typeof(T);
            var paramExpr = Expression.Parameter(type, "val");

            IQueryable<T>? orderedQuery = null;
            bool sorted = false;

            foreach (var sort in sorts.Where(s => !string.IsNullOrWhiteSpace(s.ColumnName)))
            {
                var propertyInfo = type.GetProperty(sort.ColumnName);

                if (propertyInfo == null)
                    continue;

                var sortExpression = Expression.Lambda(Expression.Property(paramExpr, propertyInfo), paramExpr);

                string methodName;
                if (sort.SortDirection == SortDirection.Asc)
                {
                    methodName = sorted ? "ThenBy" : "OrderBy";
                }
                else
                {
                    methodName = sorted ? "ThenByDescending" : "OrderByDescending";
                }

                var method = typeof(Queryable).GetMethods()
                    .Single(m => m.Name == methodName
                                 && m.IsGenericMethodDefinition
                                 && m.GetParameters().Length == 2)
                    .MakeGenericMethod(type, propertyInfo.PropertyType);

                orderedQuery = method.Invoke(null, new object[] { query, sortExpression }) as IQueryable<T>;
                sorted = true;
            }

            return orderedQuery ?? throw new ArgumentException("Unable to apply sorting.", nameof(sorts));
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\BasePostgresContext.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Interfaces;
using DXP.Core.Database.Infrastructure.Common;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    public class BasePostgresContext<T> : DbContext where T : DbContext
    {
        private readonly IEnumerable<IInterceptor> _interceptors;

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.HasDefaultSchema("dxp_app");
            modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
            modelBuilder.RegisterEnums();

            // Recorremos todas las entidades cargadas para ver cuáles implementan la interfaz
            foreach (var entityType in modelBuilder.Model.GetEntityTypes())
            {
                // Si la entidad implementa IVersionable
                if (typeof(IVersionable).IsAssignableFrom(entityType.ClrType))
                {
                    var tableName = entityType.GetTableName(); // Obtiene el nombre real de la tabla (ej: quick_action)
                    var schema = entityType.GetSchema() ?? "dxp_app";

                    // Constraint 1: Formato de MinVersion (Ej: 1.0.2)
                    // Nota: No chequeamos NULL porque MinVersion ahora es obligatorio
                    modelBuilder.Entity(entityType.ClrType)
                        .ToTable(t => t.HasCheckConstraint($"CK_{schema}_{tableName}_Format_MinVer",
                            "\"min_version\" ~ '^[0-9]+(\\.[0-9]+)*$'"));

                    // Constraint 2: Formato de MaxVersion (Puede ser NULL)
                    modelBuilder.Entity(entityType.ClrType)
                        .ToTable(t => t.HasCheckConstraint($"CK_{schema}_{tableName}_Format_MaxVer",
                            "\"max_version\" IS NULL OR \"max_version\" ~ '^[0-9]+(\\.[0-9]+)*$'"));

                    // Constraint 3: Lógica Matemática (Max >= Min) usando Arrays de Postgres
                    modelBuilder.Entity(entityType.ClrType)
                        .ToTable(t => t.HasCheckConstraint($"CK_{schema}_{tableName}_MaxGeMinVer",
                            """
                            "max_version" IS NULL OR 
                            (string_to_array("max_version", '.')::int[] >= string_to_array("min_version", '.')::int[])
                            """));
                }
            }
            // Configurar filtros globales
            base.OnModelCreating(modelBuilder);
        }
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (_interceptors != null && _interceptors.Any())
            {
                optionsBuilder.AddInterceptors(_interceptors)
                .ConfigureWarnings(w =>
                {
                    w.Ignore(CoreEventId.ManyServiceProvidersCreatedWarning);
                });
            }
        }
        protected BasePostgresContext(
            DbContextOptions<T> options,
            IEnumerable<IInterceptor> interceptors) : base(options) => _interceptors = interceptors ?? throw new ArgumentNullException(nameof(interceptors));

        // Definición de DbSets para las nuevas entidades
        public virtual DbSet<User> Users { get; set; } = null!;
        public virtual DbSet<AppScreen> AppScreens { get; set; } = null!;
        public virtual DbSet<AppSectionCatalog> AppSectionCatalogs { get; set; } = null!;
        public virtual DbSet<Device> Devices { get; set; } = null!;
        public virtual DbSet<Kyc> Kycs { get; set; } = null!;
        public virtual DbSet<Onboarding> Onboardings { get; set; } = null!;
        public virtual DbSet<OnboardingHistory> OnboardingHistories { get; set; } = null!;
        public virtual DbSet<Otp> Otps { get; set; } = null!;
        public virtual DbSet<UserFavoriteFunctionality> UserFavoriteFunctionalities { get; set; } = null!;
        public virtual DbSet<Bank> Banks { get; set; } = null!;
        public virtual DbSet<NotificationConfig> NotificationConfigs { get; set; } = null!;
        public virtual DbSet<Notification> Notifications { get; set; } = null!;
        public virtual DbSet<NotificationHistory> NotificationHistories { get; set; } = null!;
        public virtual DbSet<CountryBank> CountryBanks { get; set; } = null!;
        public virtual DbSet<FavoriteTransaction> FavoriteTransactions { get; set; } = null!;
        public virtual DbSet<UserProfile> UserProfiles { get; set; } = null!;
        public virtual DbSet<UserRequest> UserRequests { get; set; } = null!;
        public virtual DbSet<AccountType> AccountTypes { get; set; } = null!;
        public virtual DbSet<FavoriteGroup> FavoriteGroups { get; set; } = null!;
        public virtual DbSet<FavoriteService> FavoriteServices { get; set; } = null!;
        public virtual DbSet<AppResource> AppResources { get; set; } = null!;
        public virtual DbSet<UserProduct> UserProducts { get; set; } = null!;
        public virtual DbSet<UserSubProduct> UserSubProducts { get; set; } = null!;
        public virtual DbSet<Functionality> Functionalities { get; set; } = null!;
        public virtual DbSet<UserFunctionality> UserFunctionalities { get; set; } = null!;
        public virtual DbSet<Transaction> Transactions { get; set; } = null!;
        public virtual DbSet<NotificationTexts> NotificationTexts { get; set; } = null!;
        public virtual DbSet<FrequentlyQuestions> FrequentlyQuestions { get; set; } = null!;
        public virtual DbSet<FrequentlyQuestionsDetail> FrequentlyQuestionsDetail { get; set; } = null!;
        public virtual DbSet<UserTutorials> UserTutorials { get; set; } = null!;
        public virtual DbSet<NotificationTextsDetail> NotificationTextsDetail { get; set; } = null!;
        public virtual DbSet<Tutorials> Tutorials { get; set; } = null!;
        public virtual DbSet<ProfileAddress> ProfileAddress { get; set; } = null!;
        public virtual DbSet<BiometricAccount> BiometricAccount { get; set; } = null!;
        public virtual DbSet<UserFailedAttempt> UserFailedAttempts { get; set; } = null!;
        public virtual DbSet<AppVersion> AppVersion { get; set; } = null!;
        public virtual DbSet<AppVersionDetail> AppVersionDetail { get; set; } = null!;
        public virtual DbSet<UserTransactionCondition> UserTransactionConditions { get; set; } = null!;
        public virtual DbSet<Advertising> Advertising { get; set; } = null!;
        public virtual DbSet<AdvertisingDetail> AdvertisingDetail { get; set; } = null!;
        public virtual DbSet<QuickAction> QuickActions { get; set; } = null!;
        public virtual DbSet<UserQuickAction> UserQuickActions { get; set; } = null!;
        public virtual DbSet<TransferMethod> TransferMethods { get; set; } = null!;
        public virtual DbSet<TransferMethodCurrency> TransferMethodCurrencies { get; set; } = null!;
        public virtual DbSet<TransferMethodProductType> TransferMethodProdutTypes { get; set; } = null!;
        public virtual DbSet<CountryBankProductTypeConfig> CountryBankProductTypeConfigs { get; set; } = null!;
        public virtual DbSet<TutorialProgress> TutorialProgress { get; set; } = null!;
        public virtual DbSet<TutorialAction> TutorialAction { get; set; } = null!;
        public virtual DbSet<UserCondition> UserCondition { get; set; } = null!;
        public virtual DbSet<TermsAndConditions> TermsAndConditions { get; set; } = null!;
        public virtual DbSet<UiGroup> UiGroups { get; set; } = null!;
        public virtual DbSet<OptionItem> OptionItems { get; set; } = null!;
        public virtual DbSet<UserOptionItem> UserOptionItems { get; set; } = null!;
        public virtual DbSet<FailedOpportunity> FailedOpportunity { get; set; } = null!;
        public virtual DbSet<FunFact> FunFact { get; set; } = null!;
        public virtual DbSet<FunFactDetail> FunFactDetail { get; set; } = null!;
        public virtual DbSet<UserFeatureState> UserFeatureStates { get; set; } = null!;

    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\DapperContext.cs
```csharp
using System.Data;
using Npgsql;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    public class DapperContext
    {
        private readonly string _readConnectionString;
        public DapperContext(string readOnlyConnectionString)
        {
            _readConnectionString = readOnlyConnectionString
                ?? throw new ArgumentNullException(nameof(readOnlyConnectionString), "Read only connection string not configured.");
        }

        /// <summary>
        /// Creates a connection to the read-only database.
        /// </summary>
        public IDbConnection CreateReadConnection()
        {
            return new NpgsqlConnection(_readConnectionString);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\PostgresContext.cs
```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    public partial class PostgresContext : BasePostgresContext<PostgresContext>
    {
        public PostgresContext(DbContextOptions<PostgresContext> options, IEnumerable<IInterceptor> interceptors) : base(options, interceptors)
        {
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\PostgresContextFactory.cs
```csharp

using DXP.Core.Database.Infrastructure.Common;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Npgsql;

namespace DXP.Core.Database.Infrastructure.Persistence;

public partial class PostgresContextFactory : IDesignTimeDbContextFactory<PostgresContext>
{
    public PostgresContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<PostgresContext>();

        var connectionString = args.FirstOrDefault() ??
                               "Host=10.11.35.84; Database=experienciadigitalde; Port=5432; User Id=experiencia-digital-user; Password=experiencia-digital-password;";
        var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);
        dataSourceBuilder.MapEnumsToDataSource();
        NpgsqlDataSource dataSource = dataSourceBuilder.Build();

        optionsBuilder.UseNpgsql(dataSource,
            npgsqlDbContextOptionsBuilder =>
                npgsqlDbContextOptionsBuilder
                    .MigrationsAssembly("DXP.Core.Database.EfMigrator")
                    .MigrationsHistoryTable("__EFMigrationsHistory", "public"));

        return new PostgresContext(optionsBuilder.Options, []);
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadPostgresContext.cs
```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    public class ReadPostgresContext : BasePostgresContext<ReadPostgresContext>
    {
        public ReadPostgresContext(DbContextOptions<ReadPostgresContext> options, IEnumerable<IInterceptor> interceptors) : base(options, interceptors)
        {
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadRepositoryAsync.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Domain.Entities.Common;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    public abstract class ReadRepositoryAsync<TEntity, TKey>(ReadPostgresContext context) : IReadRepositoryAsync<TEntity, TKey>
            where TEntity : BaseEntity<TKey>
            where TKey : IComparable
    {
        public IQueryable<TEntity> Query
            => context.Set<TEntity>().AsNoTracking();

        public virtual async Task<TEntity?> GetByIdAsync(TKey id)
        {
            var entityType = context.Model.FindEntityType(typeof(TEntity))!;
            var key = entityType.FindPrimaryKey()!;
            var keyProperty = key.Properties.Single();

            return await Query.FirstOrDefaultAsync(e =>
                EF.Property<TKey>(e, keyProperty.Name)!.Equals(id));
        }

        public virtual Task<List<TEntity>> GetAllAsync()
            => Query.ToListAsync();

    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadUnitOfWork.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    /// <summary>
    /// Unidad de trabajo para gestionar operaciones de bases de datos y transacciones para LECTURA.
    /// Implementa <see cref="IReadUnitOfWork"/> para manejar el ciclo de vida de los recursos.
    /// </summary>
    public sealed class ReadUnitOfWork : IReadUnitOfWork
    {
        private readonly ReadPostgresContext _postgresContext;
        private readonly ReadRepositorySettings _repositorySettings;
        private bool _disposed;

        /// <summary>
        /// Inicializa una nueva instancia de la clase <see cref="UnitOfWork"/>.
        /// </summary>
        /// <param name="postgresContext">El contexto de la base de datos.</param>
        /// <param name="repositorySettings">Configuraciones de los repositorios.</param>
        /// <exception cref="ArgumentNullException">Si <paramref name="postgresContext"/> o <paramref name="repositorySettings"/> es nulo.</exception>
        public ReadUnitOfWork(ReadPostgresContext postgresContext, ReadRepositorySettings repositorySettings)
        {
            _postgresContext = postgresContext ?? throw new ArgumentNullException(nameof(postgresContext));
            _repositorySettings = repositorySettings ?? throw new ArgumentNullException(nameof(repositorySettings));
        }

        public IROUserRepository Users =>
            _repositorySettings.Users ?? throw new InvalidOperationException("El repositorio de AppScreens no está configurado.");

        public IROBankRepository Banks =>
            _repositorySettings.Banks ?? throw new InvalidOperationException("El repositorio de Banks no está configurado.");

        public IROAppVersionRepository AppVersions =>
            _repositorySettings.AppVersions ?? throw new InvalidOperationException("El repositorio de AppVersions no está configurado.");

        public IROAdvertisingRepository Advertisings =>
             _repositorySettings.Advertisings ?? throw new InvalidOperationException("El repositorio de Advertisings no está configurado.");

        public IROUserProfileRepository UserProfiles =>
            _repositorySettings.UserProfiles ?? throw new InvalidOperationException("El repositorio de UserProfiles no está configurado.");

        public IROOnboardingRepository Onboarding =>
            _repositorySettings.Onboarding ?? throw new InvalidOperationException("El repositorio de Onboarding no está configurado.");

        public IROAppResourceRepository AppResources =>
            _repositorySettings.AppResources ?? throw new InvalidOperationException("El repositorio de AppResources no está configurado.");

        public IROTutorialsRepository Tutorials =>
            _repositorySettings.Tutorials ?? throw new InvalidOperationException("El repositorio de Tutorials no está configurado.");

        public IROUserRequestRepository UserRequests =>
            _repositorySettings.UserRequests ?? throw new InvalidOperationException("El repositorio de UserRequest no está configurado.");

        public IROCountryBankRepository CountryBanks =>
            _repositorySettings.CountryBanks ?? throw new InvalidOperationException("El repositorio de CountryBank no está configurado.");

        public IROCountryBankProductTypeConfigRepository CountryBankProductTypeConfig =>
            _repositorySettings.CountryBankProductTypeConfig ?? throw new InvalidOperationException("El repositorio de CountryBankProductTypeConfig no está configurado.");

        public IROTransferMethodCurrencyRepository TransferMethodCurrency =>
            _repositorySettings.TransferMethodCurrency ?? throw new InvalidOperationException("El repositorio de TransferMethodCurrency no está configurado.");

        public IROTransferMethodProductTypeRepository TransferMethodProductType =>
            _repositorySettings.TransferMethodProductType ?? throw new InvalidOperationException("El repositorio de TransferMethodProductType no está configurado.");

        public IROTransferMethodRepository TransferMethods =>
            _repositorySettings.TransferMethods ?? throw new InvalidOperationException("El repositorio de TransferMethod no está configurado.");

        public IROTutorialProgressRepository TutorialProgress =>
            _repositorySettings.TutorialProgress ?? throw new InvalidOperationException("El repositorio de TutorialProgress no está configurado.");

        public IROAccountTypeRepository AccountType =>
            _repositorySettings.AccountType ?? throw new InvalidOperationException("El repositorio de AccountType no está configurado.");

        public IROOtpRepository Otp =>
            _repositorySettings.Otp ?? throw new InvalidOperationException("El repositorio de Otp no está configurado.");

        public IROTermsAndConditionsRepository TermsAndConditions =>
            _repositorySettings.TermsAndConditions ?? throw new InvalidOperationException("El repositorio de TermsAndConditions no está configurado.");

        public IROAdvertisingDetailRepository AdvertisingDetails =>
            _repositorySettings.AdvertisingDetails ?? throw new InvalidOperationException("El repositorio de AdvertisingDetail no está configurado.");

        public IROAppScreenRepository AppScreens =>
            _repositorySettings.AppScreens ?? throw new InvalidOperationException("El repositorio de AppScreen no está configurado.");

        public IROAppSectionCatalogRepository AppSectionCatalogs =>
            _repositorySettings.AppSectionCatalogs ?? throw new InvalidOperationException("El repositorio de AppSectionCatalog no está configurado.");

        public IROFunFactDetailRepository FunFactDetails =>
            _repositorySettings.FunFactDetails ?? throw new InvalidOperationException("El repositorio de FunFactDetail no está configurado.");

        public IRONotificationTextDetailRepository NotificationTextsDetails =>
            _repositorySettings.NotificationTextsDetails ?? throw new InvalidOperationException("El repositorio de NotificationTextsDetail no está configurado.");

        public IROTutorialActionRepository TutorialActions =>
            _repositorySettings.TutorialActions ?? throw new InvalidOperationException("El repositorio de TutorialAction no está configurado.");

        public IROUiGroupRepository UiGroups =>
            _repositorySettings.UiGroups ?? throw new InvalidOperationException("El repositorio de UiGroup no está configurado.");

        public IROUserConditionRepository UserConditions =>
            _repositorySettings.UserConditions ?? throw new InvalidOperationException("El repositorio de UserCondition no está configurado.");

        public IROUserFailedAttemptRepository UserFailedAttempts =>
            _repositorySettings.UserFailedAttempts ?? throw new InvalidOperationException("El repositorio de UserFailedAttempt no está configurado.");

        public IROUserTransactionConditionRepository UserTransactionConditions =>
            _repositorySettings.UserTransactionConditions ?? throw new InvalidOperationException("El repositorio de UserTransactionCondition no está configurado.");

        public IRODeviceRepository Devices =>
            _repositorySettings.Devices ?? throw new InvalidOperationException("El repositorio de Devices no está configurado.");

        public IROFavoritesRepository Favorites =>
            _repositorySettings.Favorites ?? throw new InvalidOperationException("El repositorio de Favorites no está configurado.");

        public IROFrequentlyQuestionsRepository FrequentlyQuestions =>
            _repositorySettings.FrequentlyQuestions ?? throw new InvalidOperationException("El repositorio de FrequentlyQuestions no está configurado.");

        public IROFrequentlyQuestionsDetailRepository FrequentlyQuestionsDetails =>
            _repositorySettings.FrequentlyQuestionsDetails ?? throw new InvalidOperationException("El repositorio de FrequentlyQuestionsDetail no está configurado.");

        public IROFunctionalityRepository Functionalities =>
            _repositorySettings.Functionalities ?? throw new InvalidOperationException("El repositorio de Functionality no está configurado.");

        public IROFunFactRepository FunFacts =>
            _repositorySettings.FunFacts ?? throw new InvalidOperationException("El repositorio de FunFact no está configurado.");

        public IRONotificationRepository Notifications =>
            _repositorySettings.Notifications ?? throw new InvalidOperationException("El repositorio de Notification no está configurado.");

        public IROOptionItemRepository OptionItems =>
            _repositorySettings.OptionItems ?? throw new InvalidOperationException("El repositorio de OptionItem no está configurado.");

        public IROProfileAddressRepository ProfileAddresses =>
            _repositorySettings.ProfileAddresses ?? throw new InvalidOperationException("El repositorio de ProfileAddress no está configurado.");

        public IROQuickActionRepository QuickActions =>
            _repositorySettings.QuickActions ?? throw new InvalidOperationException("El repositorio de QuickActions no está configurado.");

        public IROUserQuickActionRepository UserQuickActions =>
            _repositorySettings.UserQuickActions ?? throw new InvalidOperationException("El repositorio de UserQuickActions no está configurado.");

        public IROAppVersionDetailRepository AppVersionDetails =>
            _repositorySettings.AppVersionDetails ?? throw new InvalidOperationException("El repositorio de AppVersionDetail no está configurado.");

        public IROBiometricAccountRepository BiometricAccounts =>
            _repositorySettings.BiometricAccounts ?? throw new InvalidOperationException("El repositorio de BiometricAccount no está configurado.");

        public IROFailedOpportunityRepository FailedOpportunities =>
            _repositorySettings.FailedOpportunities ?? throw new InvalidOperationException("El repositorio de FailedOpportunity no está configurado.");

        public IROUserFavoriteFunctionalityRepository UserFavoriteFunctionalities =>
            _repositorySettings.UserFavoriteFunctionalities ?? throw new InvalidOperationException("El repositorio de UserfavoriteFunctionality no está configurado.");

        public IROUserFeatureStateRepository UserFeatureStates =>
            _repositorySettings.UserFeatureStates ?? throw new InvalidOperationException("El repositorio de UserFeatureState no está configurado.");

        public IROUserFunctionalityRepository UserFunctionalities =>
            _repositorySettings.UserFunctionalities ?? throw new InvalidOperationException("El repositorio de UserFunctionality no está configurado.");

        public IROUserOptionItemRepository UserOptionItems =>
            _repositorySettings.UserOptionItems ?? throw new InvalidOperationException("El repositorio de UserOptionItem no está configurado.");

        public IROUserProductRepository UserProducts =>
            _repositorySettings.UserProducts ?? throw new InvalidOperationException("El repositorio de UserProducts no está configurado.");

        public IROUserSubProductRepository UserSubProducts =>
            _repositorySettings.UserSubProducts ?? throw new InvalidOperationException("El repositorio de UserSubProducts no está configurado.");

        public IROUserTutorialsRepository UserTutorials =>
            _repositorySettings.UserTutorials ?? throw new InvalidOperationException("El repositorio de UserTutorial no está configurado.");

        public IROKycRepository Kycs =>
            _repositorySettings.Kycs ?? throw new InvalidOperationException("El repositorio de Kyc no está configurado.");

        public IRONotificationConfigRepository NotificationConfigs =>
            _repositorySettings.NotificationConfigs ?? throw new InvalidOperationException("El repositorio de NotificationConfigs no está configurado.");

        public IRONotificationHistoryRepository NotificationHistories =>
            _repositorySettings.NotificationHistories ?? throw new InvalidOperationException("El repositorio de NotificationHistory no está configurado.");

        public IRONotificationTextsRepository NotificationTexts =>
            _repositorySettings.NotificationTexts ?? throw new InvalidOperationException("El repositorio de NotificationTexts no está configurado.");

        public IROOnboardingHistoryRepository OnboardingHistories =>
            _repositorySettings.OnboardingHistories ?? throw new InvalidOperationException("El repositorio de OnboardingHistory no está configurado.");

        public IROTransactionRepository Transactions =>
            _repositorySettings.Transactions ?? throw new InvalidOperationException("El repositorio de Transaction no está configurado.");

        /// <summary>
        /// Libera los recursos utilizados por la instancia de <see cref="UnitOfWork"/>.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
            {
                // Dispose of managed resources
                _postgresContext.Dispose();
            }

            // Mark as disposed
            _disposed = true;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\RepositoryAsync.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Database.Infrastructure.Common;
using DXP.Core.Domain.Common;
using DXP.Core.Domain.Common.Sorting;
using DXP.Core.Domain.Utils;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence;

public abstract class RepositoryAsync<TEntity, TId>(PostgresContext postgresContext) : IRepositoryAsync<TEntity, TId>
    where TEntity : BaseEntity<TId>
    where TId : IComparable
{
    #region Interface implementation

    public IQueryable<TEntity> Entities => postgresContext.Set<TEntity>();
    public DbSet<TEntity> DbEntities => postgresContext.Set<TEntity>();

    public async Task<TEntity> InsertAsync(TEntity entity)
    {
        await postgresContext.AddAsync(entity);
        return entity;
    }

    public Task DeleteAsync(TEntity entity)
    {
        postgresContext.Remove(entity);
        return Task.CompletedTask;
    }

    public Task DeletePhysicallyAsync(TEntity entity)
    {
        DeleteMode.EnablePhysicalDelete();
        postgresContext.Remove(entity);
        DeleteMode.DisablePhysicalDelete();

        return Task.CompletedTask;
    }

    public Task DeleteRangeAsync(IEnumerable<TEntity> entities)
    {
        postgresContext.RemoveRange(entities);
        return Task.CompletedTask;
    }

    public Task DeleteRangePhysicallyAsync(IEnumerable<TEntity> entities)
    {
        DeleteMode.EnablePhysicalDelete();
        postgresContext.RemoveRange(entities);
        DeleteMode.DisablePhysicalDelete();

        return Task.CompletedTask;
    }

    public Task BulkInsertAsync(IEnumerable<TEntity> entities)
    {
        return postgresContext.AddRangeAsync(entities);
    }

    public virtual Task<TEntity> UpdateAsync(TEntity entity)
    {
        var result = postgresContext.Update(entity);
        return Task.FromResult(result.Entity);
    }

    public Task BulkUpdateAsync(IEnumerable<TEntity> entities)
    {
        postgresContext.UpdateRange(entities);
        return Task.CompletedTask;
    }

    public virtual async Task<TEntity?> GetByIdAsync(params object?[]? keyValues)
    {
        return await postgresContext.Set<TEntity>().FindAsync(keyValues);
    }

    public Task<List<TEntity>> GetAllAsync()
    {
        return postgresContext.Set<TEntity>().AsNoTracking().ToListAsync();
    }

    public Task<List<TEntity>> GetPaginatedResponseAsync(int pageNumber, int pageSize)
    {
        return postgresContext
            .Set<TEntity>()
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .AsNoTracking()
            .ToListAsync();
    }

    public IQueryable<TEntity>? GetQueryableAsNoTracking<TFilter>(SearchFilter<TEntity, TFilter>? filter,
        List<SortingByColumn> sorts)
    {
        var originalQuery = postgresContext.Set<TEntity>().AsNoTracking().ApplySort(sorts);
        return filter == null
            ? originalQuery
            : originalQuery!.ApplyFilter(filter.SupportedFilters!, filter.Filter);
    }

    public virtual void Attach(TEntity entity)
    {
        postgresContext.Attach(entity);
    }

    #endregion
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\UnitOfWork.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Infrastructure.Persistence.Repositories;
using Microsoft.EntityFrameworkCore.Storage;

namespace DXP.Core.Database.Infrastructure.Persistence
{
    /// <summary>
    /// Unidad de trabajo para gestionar operaciones de bases de datos y transacciones.
    /// Implementa <see cref="IUnitOfWork"/> para manejar el ciclo de vida de los recursos.
    /// </summary>
    public sealed class UnitOfWork : IUnitOfWork
    {
        private readonly PostgresContext _postgresContext;
        private readonly RepositorySettings _repositorySettings;
        private bool _disposed;

        /// <summary>
        /// Inicializa una nueva instancia de la clase <see cref="UnitOfWork"/>.
        /// </summary>
        /// <param name="postgresContext">El contexto de la base de datos.</param>
        /// <param name="repositorySettings">Configuraciones de los repositorios.</param>
        /// <exception cref="ArgumentNullException">Si <paramref name="postgresContext"/> o <paramref name="repositorySettings"/> es nulo.</exception>
        public UnitOfWork(PostgresContext postgresContext, RepositorySettings repositorySettings)
        {
            _postgresContext = postgresContext ?? throw new ArgumentNullException(nameof(postgresContext));
            _repositorySettings = repositorySettings ?? throw new ArgumentNullException(nameof(repositorySettings));
        }

        #region Entidades

        // Repositorios de la unidad de trabajo
        public IAppScreenRepository AppScreens =>
            _repositorySettings.AppScreens ?? throw new InvalidOperationException("El repositorio de AppScreens no está configurado.");

        public IAppSectionCatalogRepository AppSectionCatalogs =>
            _repositorySettings.AppSectionCatalogs ?? throw new InvalidOperationException("El repositorio de AppSectionCatalogs no está configurado.");

        public IDeviceRepository Devices =>
            _repositorySettings.Devices ?? throw new InvalidOperationException("El repositorio de Devices no está configurado.");

        public IOnboardingRepository Onboardings =>
            _repositorySettings.Onboardings ?? throw new InvalidOperationException("El repositorio de Onboardings no está configurado.");

        public IOnboardingHistoryRepository OnboardingHistories =>
            _repositorySettings.OnboardingHistories ?? throw new InvalidOperationException("El repositorio de OnboardingHistories no está configurado.");

        public IOtpRepository Otps =>
            _repositorySettings.Otps ?? throw new InvalidOperationException("El repositorio de Otps no está configurado.");

        public IUserFavoriteFunctionalityRepository UserFavoriteFunctionalities =>
            _repositorySettings.UserFavoriteFunctionalities ?? throw new InvalidOperationException("El repositorio de UserFavoriteFunctionalities no está configurado.");

        public IUserRepository Users =>
            _repositorySettings.Users ?? throw new InvalidOperationException("El repositorio de Users no está configurado.");

        public IKycRepository Kycs =>
            _repositorySettings.Kycs ?? throw new InvalidOperationException("El repositorio de Kycs no está configurado.");

        public IBankRepository Banks =>
            _repositorySettings.Banks ?? throw new InvalidOperationException("El repositorio de Banks no está configurado.");

        public INotificationConfigRepository NotificationConfigs =>
            _repositorySettings.NotificationConfigs ?? throw new InvalidOperationException("El repositorio de NotificationConfigs no está configurado.");

        public INotificationRepository Notifications =>
            _repositorySettings.Notifications ?? throw new InvalidOperationException("El repositorio de Notifications no está configurado.");

        public INotificationHistoryRepository NotificationHistories =>
            _repositorySettings.NotificationHistories ?? throw new InvalidOperationException("El repositorio de NotificationHistories no está configurado.");

        public ICountryBankRepository CountryBanks =>
            _repositorySettings.CountryBanks ?? throw new InvalidOperationException("El repositorio de CountryBanks no está configurado.");

        public IProfileRepository Profiles =>
            _repositorySettings.UserProfiles ?? throw new InvalidOperationException("El repositorio de Profiles no está configurado.");

        public IUserRequestRepository UserRequests =>
            _repositorySettings.UserRequests ?? throw new InvalidOperationException("El repositorio de UserRequests no está configurado");

        public IAccountTypeRepository AccountTypes =>
            _repositorySettings.AccountTypes ?? throw new InvalidOperationException("El repositorio de AccountTypes no está configurado");

        public IFavoritesRepository FavoritesRepository =>
              _repositorySettings.FavoritesRepository ?? throw new InvalidOperationException("El repositorio de FavoritesRepository no está configurado.");

        public IAppResourceRepository AppResources =>
              _repositorySettings.AppResources ?? throw new InvalidOperationException("El repositorio de AppResource no está configurado.");

        public IUserProductRepository UserProducts =>
            _repositorySettings.UserProducts ?? throw new InvalidOperationException("El repositorio de UserProducts no está configurado.");

        public IUserSubProductRepository UserSubProducts =>
            _repositorySettings.UserSubProducts ?? throw new InvalidOperationException("El repositorio de UserSubProducts no está configurado.");

        public IFunctionalityRepository Functionalities =>
           _repositorySettings.Functionalities ?? throw new InvalidOperationException("El repositorio de Functionalities no está configurado.");

        public IUserFunctionalityRepository UserFunctionality =>
           _repositorySettings.UserFunctionalities ?? throw new InvalidOperationException("El repositorio de UserFunctionalities no está configurado.");

        public ITransactionRepository Transactions =>
            _repositorySettings.Transactions ?? throw new InvalidOperationException("El repositorio de Transactions no está configurado.");

        public INotificationTextsRepository NotificationTexts =>
            _repositorySettings.NotificationTexts ?? throw new InvalidOperationException("El repositorio de NotificationTexts no está configurado.");

        public IFrequentlyQuestionsRepository FrequentlyQuestions =>
            _repositorySettings.FrequentlyQuestions ?? throw new InvalidOperationException("El repositorio de FrequentlyQuestions no está configurado.");

        public IFrequentlyQuestionsDetailRepository FrequentlyQuestionsDetail =>
            _repositorySettings.FrequentlyQuestionsDetail ?? throw new InvalidOperationException("El repositorio de FrequentlyQuestionsDetail no está configurado.");

        public IUserTutorialsRepository UserTutorials =>
            _repositorySettings.UserTutorials ?? throw new InvalidOperationException("El repositorio de UserTutorials no está configurado.");

        public INotificationTextsDetailRepository NotificationTextsDetail =>
            _repositorySettings.NotificationTextsDetail ?? throw new InvalidOperationException("El repositorio de NotificationTextsDetail no está configurado.");

        public ITutorialsRepository Tutorials =>
            _repositorySettings.Tutorials ?? throw new InvalidOperationException("El repositorio de Tutorials no está configurado.");

        public IProfileAddressRepository ProfileAddress =>
            _repositorySettings.ProfileAddress ?? throw new InvalidOperationException("El repositorio de ProfileAddress no está configurado.");

        public IBiometricAccountRepository BiometricAccount =>
            _repositorySettings.BiometricAccount ?? throw new InvalidOperationException("El repositorio de BiometricAccount no está configurado.");

        public IUserFailedAttemptRepository UserFailedAttempts =>
            _repositorySettings.UserFailedAttempts ?? throw new InvalidOperationException("El repositorio de UserFailedAttempt no está configurado.");

        public IAppVersionRepository AppVersion =>
            _repositorySettings.AppVersion ?? throw new InvalidOperationException("El repositorio de AppVersion no está configurado.");

        public IAppVersionDetailRepository AppVersionDetail =>
            _repositorySettings.AppVersionDetail ?? throw new InvalidOperationException("El repositorio de AppVersionDetail no está configurado.");

        public IUserTransactionConditionRepository UserTransactionConditions =>
            _repositorySettings.UserTransactionConditions ?? throw new InvalidOperationException("El repositorio de UserTransactionCondition no está configurado.");

        public IAdvertisingRepository Advertising =>
            _repositorySettings.Advertising ?? throw new InvalidOperationException("El repositorio de Advertising no está configurado.");

        public IAdvertisingDetailRepository AdvertisingDetail =>
            _repositorySettings.AdvertisingDetail ?? throw new InvalidOperationException("El repositorio de AdvertisingDetail no está configurado.");

        public IQuickActionRepository QuickActions =>
            _repositorySettings.QuickActions ?? throw new InvalidOperationException("El repositorio de QuickAction no está configurado.");

        public IUserQuickActionRepository UserQuickActions =>
            _repositorySettings.UserQuickActions ?? throw new InvalidOperationException("El repositorio de UserQuickAction no está configurado.");

        public ITransferMethodRepository TransferMethods =>
            _repositorySettings.TransferMethods ?? throw new InvalidOperationException("El repositorio de TransferMethod no está configurado.");

        public ITransferMethodCurrencyRepository TransferMethodCurrencies =>
            _repositorySettings.TransferMethodCurrencies ?? throw new InvalidOperationException("El repositorio de TransferMethodCurrency no está configurado.");

        public ITransferMethodProductTypeRepository TransferMethodProductTypes =>
            _repositorySettings.TransferMethodProductTypes ?? throw new InvalidOperationException("El repositorio de TransferMethodProductType no está configurado.");

        public ICountryBankProductTypeConfigRepository CountryBankProductTypeConfigs =>
            _repositorySettings.CountryBankProductTypeConfigs ?? throw new InvalidOperationException("El repositorio de CountryBankProductTypeConfig no está configurado.");

        public ITutorialProgressRepository TutorialProgress =>
            _repositorySettings.TutorialProgress ?? throw new InvalidOperationException("El repositorio de TutorialProgress no está configurado.");

        public ITutorialActionRepository TutorialAction =>
            _repositorySettings.TutorialAction ?? throw new InvalidOperationException("El repositorio de TutorialAction no está configurado.");

        public IUserConditionRepository UserCondition =>
            _repositorySettings.UserCondition ?? throw new InvalidOperationException("El repositorio de UserCondition no está configurado.");

        public ITermsAndConditionsRepository TermsAndConditions =>
            _repositorySettings.TermsAndConditions ?? throw new InvalidOperationException("El repositorio de TermsAndConditions no está configurado.");

        public IUiGroupRepository UiGroups =>
            _repositorySettings.UiGroups ?? throw new InvalidOperationException("El repositorio de UiGroups no está configurado.");

        public IOptionItemRepository OptionItems =>
            _repositorySettings.OptionItems ?? throw new InvalidOperationException("El repositorio de OptionItems no está configurado.");

        public IUserOptionItemRepository UserOptionItems =>
            _repositorySettings.UserOptionItems ?? throw new InvalidOperationException("El repositorio de UserOptionItems no está configurado.");
        public IFailedOpportunityRepository FailedOpportunity =>
            _repositorySettings.FailedOpportunity ?? throw new InvalidOperationException("El repositorio de FailedOpportunity no está configurado.");
        public IFunFactRepository FunFactItems =>
            _repositorySettings.FunFactItems ?? throw new InvalidOperationException("El repositorio de FunFactItems no está configurado.");
        public IFunFactDetailRepository FunFactDetailItems =>
            _repositorySettings.FunFactDetailItems ?? throw new InvalidOperationException("El repositorio de FunFactDetail no está configurado.");
        public IUserFeatureStateRepository UserFeatureStates =>
            _repositorySettings.UserFeatureStates ?? throw new InvalidOperationException("El repositorio de UserFeatureState no está configurado.");

        #endregion Entidades

        /// <summary>
        /// Guarda los cambios asincrónicamente en el contexto de la base de datos.
        /// </summary>
        /// <param name="cancellationToken">Token para cancelar la operación.</param>
        /// <returns>El número de entidades que se han modificado.</returns>
        public Task<int> SaveChangesAsync(CancellationToken cancellationToken) =>
            _postgresContext.SaveChangesAsync(cancellationToken);

        /// <summary>
        /// Inicia una nueva transacción en el contexto de la base de datos.
        /// </summary>
        /// <returns>Una instancia de <see cref="IDbContextTransaction"/> para la transacción.</returns>
        public IDbContextTransaction BeginTransaction() =>
            _postgresContext.Database.BeginTransaction();

        /// <summary>
        /// Libera los recursos utilizados por la instancia de <see cref="UnitOfWork"/>.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
            {
                // Dispose of managed resources
                _postgresContext.Dispose();
            }

            // Mark as disposed
            _disposed = true;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\IReadRepositoryAsync.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;

namespace DXP.Core.Database.Application.Common.Interfaces
{
    public interface IReadRepositoryAsync<TEntity, TKey> where TEntity : BaseEntity<TKey> where TKey : IComparable
    {
        IQueryable<TEntity> Query { get; }

        Task<TEntity?> GetByIdAsync(TKey id);

        Task<List<TEntity>> GetAllAsync();
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\IReadUnitOfWork.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;

namespace DXP.Core.Database.Application.Common.Interfaces
{
    public interface IReadUnitOfWork : IDisposable
    {
        IROUserRepository Users { get; }
        IROBankRepository Banks { get; }
        IROAppVersionRepository AppVersions { get; }
        IROAdvertisingRepository Advertisings { get; }
        IROUserProfileRepository UserProfiles { get; }
        IROOnboardingRepository Onboarding { get; }
        IROTutorialsRepository Tutorials { get; }
        IROAppResourceRepository AppResources { get; }
        IROUserRequestRepository UserRequests { get; }
        IROCountryBankRepository CountryBanks { get; }
        IROCountryBankProductTypeConfigRepository CountryBankProductTypeConfig { get; }
        IROTransferMethodCurrencyRepository TransferMethodCurrency { get; }
        IROTransferMethodProductTypeRepository TransferMethodProductType { get; }
        IROTransferMethodRepository TransferMethods { get; }
        IROTutorialProgressRepository TutorialProgress { get; }
        IROAccountTypeRepository AccountType { get; }
        IROOtpRepository Otp { get; }
        IROTermsAndConditionsRepository TermsAndConditions { get; }
        IROAdvertisingDetailRepository AdvertisingDetails { get; }
        IROAppScreenRepository AppScreens { get; }
        IROAppSectionCatalogRepository AppSectionCatalogs { get; }
        IROFunFactDetailRepository FunFactDetails { get; }
        IRONotificationTextDetailRepository NotificationTextsDetails { get; }
        IROTutorialActionRepository TutorialActions { get; }
        IROUiGroupRepository UiGroups { get; }
        IROUserConditionRepository UserConditions { get; }
        IROUserFailedAttemptRepository UserFailedAttempts { get; }
        IROUserTransactionConditionRepository UserTransactionConditions { get; }
        IRODeviceRepository Devices { get; }
        IROFavoritesRepository Favorites { get; }
        IROFrequentlyQuestionsRepository FrequentlyQuestions { get; }
        IROFrequentlyQuestionsDetailRepository FrequentlyQuestionsDetails { get; }
        IROFunctionalityRepository Functionalities { get; }
        IROFunFactRepository FunFacts { get; }
        IRONotificationRepository Notifications { get; }
        IROOptionItemRepository OptionItems { get; }
        IROProfileAddressRepository ProfileAddresses { get; }
        IROQuickActionRepository QuickActions { get; }
        IROUserQuickActionRepository UserQuickActions { get; }
        IROAppVersionDetailRepository AppVersionDetails { get; }
        IROBiometricAccountRepository BiometricAccounts { get; }
        IROFailedOpportunityRepository FailedOpportunities { get; }
        IROUserFavoriteFunctionalityRepository UserFavoriteFunctionalities { get; }
        IROUserFeatureStateRepository UserFeatureStates { get; }
        IROUserFunctionalityRepository UserFunctionalities { get; }
        IROUserOptionItemRepository UserOptionItems { get; }
        IROUserProductRepository UserProducts { get; }
        IROUserSubProductRepository UserSubProducts { get; }
        IROUserTutorialsRepository UserTutorials { get; }
        IROKycRepository Kycs { get; }
        IRONotificationConfigRepository NotificationConfigs { get; }
        IRONotificationHistoryRepository NotificationHistories { get; }
        IRONotificationTextsRepository NotificationTexts { get; }
        IROOnboardingHistoryRepository OnboardingHistories { get; }
        IROTransactionRepository Transactions { get; }
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\IRepositoryAsync.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Domain.Common;
using DXP.Core.Domain.Common.Sorting;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Application.Common.Interfaces
{
    public interface IRepositoryAsync<TEntity, TId>
    where TEntity : BaseEntity<TId>
    where TId : IComparable
    {
        IQueryable<TEntity> Entities { get; }
        DbSet<TEntity> DbEntities { get; }

        Task<TEntity> InsertAsync(TEntity entity);

        Task BulkInsertAsync(IEnumerable<TEntity> entities);

        Task<TEntity> UpdateAsync(TEntity entity);

        Task BulkUpdateAsync(IEnumerable<TEntity> entities);

        Task DeleteAsync(TEntity entity);

        Task DeleteRangeAsync(IEnumerable<TEntity> entities);

        Task<TEntity?> GetByIdAsync(params object?[]? keyValues);

        Task<List<TEntity>> GetAllAsync();

        Task<List<TEntity>> GetPaginatedResponseAsync(int pageNumber, int pageSize);

        IQueryable<TEntity>? GetQueryableAsNoTracking<TFilter>(SearchFilter<TEntity, TFilter> filter,
            List<SortingByColumn> sorts);

        void Attach(TEntity entity);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\IUnitOfWork.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using Microsoft.EntityFrameworkCore.Storage;

namespace DXP.Core.Database.Application.Common.Interfaces
{
    public interface IUnitOfWork : IDisposable
    {
        #region Entidades
        IAppScreenRepository AppScreens { get; }
        IAppSectionCatalogRepository AppSectionCatalogs { get; }
        IDeviceRepository Devices { get; }
        IOnboardingHistoryRepository OnboardingHistories { get; }
        IOnboardingRepository Onboardings { get; }
        IOtpRepository Otps { get; }
        IUserFavoriteFunctionalityRepository UserFavoriteFunctionalities { get; }
        IUserRepository Users { get; }
        IKycRepository Kycs { get; }
        IBankRepository Banks { get; }
        INotificationConfigRepository NotificationConfigs { get; }
        INotificationRepository Notifications { get; }
        INotificationHistoryRepository NotificationHistories { get; }
        INotificationTextsRepository NotificationTexts { get; }
        ICountryBankRepository CountryBanks { get; }
        IProfileRepository Profiles { get; }
        IUserRequestRepository UserRequests { get; }
        IAccountTypeRepository AccountTypes { get; }
        IFavoritesRepository FavoritesRepository { get; }
        IAppResourceRepository AppResources { get; }
        IUserProductRepository UserProducts { get; }
        IUserSubProductRepository UserSubProducts { get; }
        IFunctionalityRepository Functionalities { get; }
        ITransactionRepository Transactions { get; }
        IFrequentlyQuestionsRepository FrequentlyQuestions { get; }
        IFrequentlyQuestionsDetailRepository FrequentlyQuestionsDetail { get; }
        IUserFunctionalityRepository UserFunctionality { get; }
        IUserTutorialsRepository UserTutorials { get; }
        INotificationTextsDetailRepository NotificationTextsDetail { get; }
        ITutorialsRepository Tutorials { get; }
        IProfileAddressRepository ProfileAddress { get; }
        IBiometricAccountRepository BiometricAccount { get; }
        IUserFailedAttemptRepository UserFailedAttempts { get; }
        IAppVersionRepository AppVersion { get; }
        IAppVersionDetailRepository AppVersionDetail { get; }
        IUserTransactionConditionRepository UserTransactionConditions { get; }
        IAdvertisingRepository Advertising { get; }
        IAdvertisingDetailRepository AdvertisingDetail { get; }
        IQuickActionRepository QuickActions { get; }
        IUserQuickActionRepository UserQuickActions { get; }
        ITransferMethodRepository TransferMethods { get; }
        ITransferMethodCurrencyRepository TransferMethodCurrencies { get; }
        ITransferMethodProductTypeRepository TransferMethodProductTypes { get; }
        ICountryBankProductTypeConfigRepository CountryBankProductTypeConfigs { get; }
        ITutorialProgressRepository TutorialProgress { get; }
        ITutorialActionRepository TutorialAction { get; }
        IUserConditionRepository UserCondition { get; }
        ITermsAndConditionsRepository TermsAndConditions { get; }
        IUiGroupRepository UiGroups { get; }
        IOptionItemRepository OptionItems { get; }
        IUserOptionItemRepository UserOptionItems { get; }
        IFailedOpportunityRepository FailedOpportunity { get; }
        IFunFactRepository FunFactItems { get; }
        IFunFactDetailRepository FunFactDetailItems { get; }
        IUserFeatureStateRepository UserFeatureStates { get; }

        #endregion Entidades

        Task<int> SaveChangesAsync(CancellationToken cancellationToken);
        IDbContextTransaction BeginTransaction();
    }
}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Common\BaseAuditableEntity.cs
```csharp
using System.ComponentModel.DataAnnotations;

namespace DXP.Core.Database.Domain.Entities.Common
{
    /// <summary>
    /// Clase base para entidades auditables.
    /// </summary>
    /// <typeparam name="TId">Tipo del identificador de la entidad.</typeparam>
    public abstract class BaseAuditableEntity<T> : BaseEntity<T> where T : IComparable
    {
        private DateTime _createdAt;
        private DateTime? _updatedAt;

        /// <summary>
        /// Fecha y hora de creación del registro.
        /// </summary>
        [Required]
        public DateTime CreatedAt
        {
            get => _createdAt;
            set => _createdAt = DateTime.UtcNow;
        }

        /// <summary>
        /// Fecha y hora de la última actualización del registro.
        /// </summary>
        public DateTime? UpdatedAt
        {
            get => _updatedAt;
            set => _updatedAt = value.HasValue ? DateTime.UtcNow : value;
        }
    }

}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Common\BaseEntity.cs
```csharp
using System.ComponentModel.DataAnnotations;

namespace DXP.Core.Database.Domain.Entities.Common
{
    public class BaseEntity<TId> : SoftDeleteEntity
    where TId : IComparable
    {
        [Key] public TId Id { get; set; } = default!;
    }

}

```

### FILE: src\DXP.Core.Database.Domain\Entities\Common\SoftDeleteEntity.cs
```csharp
namespace DXP.Core.Database.Domain.Entities.Common
{
    public abstract class SoftDeleteEntity
    {
        private DateTime? _deletedAt;

        public DateTime? DeletedAt
        {
            get => _deletedAt;
            set => _deletedAt = value.HasValue ? DateTime.SpecifyKind(value.Value, DateTimeKind.Utc) : value;
        }

        public void UndoSoftDelete()
        {
            DeletedAt = null;
        }
    }

}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Interceptors\AuditableEntitySaveChangesInterceptor.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace DXP.Core.Database.Infrastructure.Persistence.Interceptors;

public class AuditableEntitySaveChangesInterceptor : SaveChangesInterceptor
{
    public override InterceptionResult<int> SavingChanges(
        DbContextEventData eventData,
        InterceptionResult<int> result)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChanges(eventData, result);
    }

    public override ValueTask<InterceptionResult<int>> SavingChangesAsync(
        DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    private static void UpdateEntities(DbContext? context)
    {
        if (context == null) return;
        foreach (var entry in context.ChangeTracker.Entries<BaseAuditableEntity<Guid>>())
        {
            switch (entry.State)
            {
                case EntityState.Added:
                    entry.Entity.CreatedAt = DateTime.UtcNow;
                    entry.Entity.UpdatedAt = DateTime.UtcNow;
                    break;
                case EntityState.Modified:
                    entry.Entity.UpdatedAt = DateTime.UtcNow;
                    break;
                case EntityState.Detached:
                case EntityState.Unchanged:
                case EntityState.Deleted:
                default:
                    break;
            }
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Interceptors\SoftDeleteInterceptor.cs
```csharp
using DXP.Core.Database.Domain.Entities.Common;
using DXP.Core.Domain.Utils;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace DXP.Core.Database.Infrastructure.Persistence.Interceptors;

public class SoftDeleteInterceptor : SaveChangesInterceptor
{
    public override InterceptionResult<int> SavingChanges(
        DbContextEventData eventData,
        InterceptionResult<int> result)
    {
        UpdateEntities(eventData.Context);
        return result;
    }

    public override ValueTask<InterceptionResult<int>> SavingChangesAsync(
        DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        UpdateEntities(eventData.Context);
        return ValueTask.FromResult(result);
    }

    private static void UpdateEntities(DbContext? context)
    {
        if (context is null) return;
        foreach (var entry in context.ChangeTracker.Entries<SoftDeleteEntity>())
        {
            if (entry is not { State: EntityState.Deleted }) continue;

            if (DeleteMode.IsPhysicalDeleteEnabled)
                continue;

            entry.State = EntityState.Modified;
            entry.Entity.DeletedAt = DateTime.UtcNow;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ReadRepositorySettings.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ReadRepositorySettings
    {
        public IROUserRepository? Users { get; set; }
        public IROBankRepository? Banks { get; set; }
        public IROAdvertisingRepository? Advertisings { get; set; }
        public IROAppVersionRepository? AppVersions { get; set; }
        public IROUserProfileRepository? UserProfiles { get; set; }
        public IROOnboardingRepository? Onboarding { get; set; }
        public IROTutorialsRepository? Tutorials { get; set; }
        public IROAppResourceRepository? AppResources { get; set; }
        public IROUserRequestRepository? UserRequests { get; set; }
        public IROCountryBankRepository? CountryBanks { get; set; }
        public IROCountryBankProductTypeConfigRepository? CountryBankProductTypeConfig { get; set; }
        public IROTransferMethodCurrencyRepository? TransferMethodCurrency { get; set; }
        public IROTransferMethodProductTypeRepository? TransferMethodProductType { get; set; }
        public IROTransferMethodRepository? TransferMethods { get; set; }
        public IROTutorialProgressRepository? TutorialProgress { get; set; }
        public IROAccountTypeRepository? AccountType { get; set; }
        public IROOtpRepository? Otp { get; set; }
        public IROTermsAndConditionsRepository? TermsAndConditions { get; set; }
        public IROAdvertisingDetailRepository? AdvertisingDetails { get; set; }
        public IROAppScreenRepository? AppScreens { get; set; }
        public IROAppSectionCatalogRepository? AppSectionCatalogs { get; set; }
        public IROFunFactDetailRepository? FunFactDetails { get; set; }
        public IRONotificationTextDetailRepository? NotificationTextsDetails { get; set; }
        public IROTutorialActionRepository? TutorialActions { get; set; }
        public IROUiGroupRepository? UiGroups { get; set; }
        public IROUserConditionRepository? UserConditions { get; set; }
        public IROUserFailedAttemptRepository? UserFailedAttempts { get; set; }
        public IROUserTransactionConditionRepository? UserTransactionConditions { get; set; }
        public IRODeviceRepository? Devices { get; set; }
        public IROFavoritesRepository? Favorites { get; set; }
        public IROFrequentlyQuestionsRepository? FrequentlyQuestions { get; set; }
        public IROFrequentlyQuestionsDetailRepository? FrequentlyQuestionsDetails { get; set; }
        public IROFunctionalityRepository? Functionalities { get; set; }
        public IROFunFactRepository? FunFacts { get; set; }
        public IRONotificationRepository? Notifications { get; set; }
        public IROOptionItemRepository? OptionItems { get; set; }
        public IROProfileAddressRepository? ProfileAddresses { get; set; }
        public IROQuickActionRepository? QuickActions { get; set; }
        public IROUserQuickActionRepository? UserQuickActions { get; set; }
        public IROAppVersionDetailRepository? AppVersionDetails { get; set; }
        public IROBiometricAccountRepository? BiometricAccounts { get; set; }
        public IROFailedOpportunityRepository? FailedOpportunities { get; set; }
        public IROUserFavoriteFunctionalityRepository? UserFavoriteFunctionalities { get; set; }
        public IROUserFeatureStateRepository? UserFeatureStates { get; set; }
        public IROUserFunctionalityRepository? UserFunctionalities { get; set; }
        public IROUserOptionItemRepository? UserOptionItems { get; set; }
        public IROUserProductRepository? UserProducts { get; set; }
        public IROUserSubProductRepository? UserSubProducts { get; set; }
        public IROUserTutorialsRepository? UserTutorials { get; set; }
        public IROKycRepository? Kycs { get; set; }
        public IRONotificationConfigRepository? NotificationConfigs { get; set; }
        public IRONotificationHistoryRepository? NotificationHistories { get; set; }
        public IRONotificationTextsRepository? NotificationTexts { get; set; }
        public IROOnboardingHistoryRepository? OnboardingHistories { get; set; }
        public IROTransactionRepository? Transactions { get; set; }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAccountTypeRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAccountTypeRepository(ReadPostgresContext context) : ReadRepositoryAsync<AccountType, int>(context), IROAccountTypeRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAdvertisingDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAdvertisingDetailRepository(ReadPostgresContext context) : ReadRepositoryAsync<AdvertisingDetail, int>(context), IROAdvertisingDetailRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAdvertisingRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAdvertisingRepository : ReadRepositoryAsync<Advertising, int>, IROAdvertisingRepository
    {
        private readonly ReadPostgresContext _postgresContext;

        public ROAdvertisingRepository(ReadPostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public async Task<List<Advertising>?> GetAdvertisings()
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive)).ToListAsync();

            return advertising;
        }

        public async Task<List<Advertising>?> GetAdvertisingsByType(AdvertisingType advertisingType)
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive && adv.Type.Equals(advertisingType)).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive)).ToListAsync();

            return advertising;
        }

        public async Task<List<Advertising>?> GetAdvertisingsByRedirectType(RedirectTo redirectTo)
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive && advd.RedirectTo.Equals(redirectTo))).ToListAsync();

            return advertising;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAppResourceRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using LAFISE.CrossCutting.Core.Extensions;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAppResourceRepository(ReadPostgresContext postgresContext, ICacheService cacheService) : ReadRepositoryAsync<AppResource, int>(postgresContext), IROAppResourceRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        public async Task<AppResource?> SearchResourcesByResourceType(ResourceType resourceType) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (resourceType != ResourceType.PrivacyPolicy && resourceType != ResourceType.TermsAndConditions)
                    throw new ArgumentException("El tipo de recurso no pertenece al grupo global");

                return await _postgresContext.AppResources!
                    .Where(r => r.ResourceType == resourceType)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByResourceTypeAndBankId(ResourceType resourceType, string bankId) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByResourceTypeWithBankIdAndProductType(ResourceType resourceType, string bankId, ProductType productType) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString(),
                    CacheGroup.Product.GetDescription(),
                    productType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                if (productType == default)
                    throw new ArgumentException("El tipo de producto no puede ser vacío");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId && r.ProductType == productType)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByProductTypeAndSubProductAsync(ResourceType resourceType, string bankId, ProductType productType, string subProduct) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString(),
                    CacheGroup.Product.GetDescription(),
                    productType.ToString(),
                    subProduct
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                if (string.IsNullOrEmpty(subProduct))
                    throw new ArgumentException("El subProducto es requerido para este método");

                if (productType == default)
                    throw new ArgumentException("El tipo de producto no puede ser vacío");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId && r.ProductType == productType && r.SubProduct == subProduct)
                    .FirstOrDefaultAsync();
            });
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAppScreenRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAppScreenRepository(ReadPostgresContext context) : ReadRepositoryAsync<AppScreen, string>(context), IROAppScreenRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAppSectionCatalogRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAppSectionCatalogRepository(ReadPostgresContext context) : ReadRepositoryAsync<AppSectionCatalog, int>(context), IROAppSectionCatalogRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAppVersionDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAppVersionDetailRepository(ReadPostgresContext context) : ReadRepositoryAsync<AppVersionDetail, int>(context), IROAppVersionDetailRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;
        public async Task<List<AppVersionDetail>> GetAppVersionDetailByAppVersion(string? appVersion)
        {
            var result = await _postgresContext.AppVersionDetail.Where(avd => avd.AppVersionId != null && avd.AppVersionId.Equals(appVersion)).ToListAsync();

            return result;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROAppVersionRepository.cs
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROAppVersionRepository : ReadRepositoryAsync<AppVersion, string>, IROAppVersionRepository
    {
        private readonly ReadPostgresContext _postgresContext;

        public ROAppVersionRepository(ReadPostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public async Task<AppVersion?> GetLastAppVersion()
        {
            var lastAppVersion = await _postgresContext.AppVersion.OrderByDescending(av => av.CreatedAt).Include(ap => ap.AppVersionDetail).FirstOrDefaultAsync();

            return lastAppVersion;
        }

        public async Task<AppVersion?> GetAppVersionById(string versionId)
        {
            var appVersion = await _postgresContext.AppVersion.Where(av => av.Id.Equals(versionId)).Include(ap => ap.AppVersionDetail).FirstOrDefaultAsync();

            return appVersion;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROBankRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROBankRepository : ReadRepositoryAsync<Bank, string>, IROBankRepository
    {
        private readonly ReadPostgresContext _postgresContext;

        public ROBankRepository(ReadPostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public async Task<List<Bank?>> GetAvailableBanks()
        {
            var availableBanks = await _postgresContext.Banks.Where(b => b.Active ?? false).ToListAsync<Bank?>();

            return availableBanks;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROBiometricAccountRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROBiometricAccountRepository(ReadPostgresContext context) : ReadRepositoryAsync<BiometricAccount, int>(context), IROBiometricAccountRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<User?> GetUserBiometricAccountsByUserId(Guid userId)
        {
            var userWithBiometricAccounts = await _postgresContext.Users.Include(u => u.BiometricAccounts.Where(ba => ba.IsActive)).FirstOrDefaultAsync(u => u.Id.Equals(userId));

            return userWithBiometricAccounts;
        }

        public async Task<List<BiometricAccount>?> GetBiometricAccountListByUserId(Guid userId)
        {
            var biometricAccountList = await _postgresContext.BiometricAccount.Where(ba => ba.UserId.Equals(userId) && ba.IsActive).ToListAsync();

            return biometricAccountList;
        }

        public async Task<List<BiometricAccount>?> GetAllBiometricAccountListByUserId(Guid userId)
        {
            var biometricAccountList = await _postgresContext.BiometricAccount.Where(ba => ba.UserId.Equals(userId)).ToListAsync();

            return biometricAccountList;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROCountryBankProductTypeConfigRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROCountryBankProductTypeConfigRepository(ReadPostgresContext context) : ReadRepositoryAsync<CountryBankProductTypeConfig, int>(context), IROCountryBankProductTypeConfigRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROCountryBankRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Caching.Services;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROCountryBankRepository(ReadPostgresContext postgresContext, ICacheService cacheService) : ReadRepositoryAsync<CountryBank, int>(postgresContext), IROCountryBankRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        /// <summary>
        /// Obtener Country Bank por medio de codigo swift
        /// </summary>
        /// <param name="swiftCode">Swift Code</param>
        /// <returns></returns>
        public async Task<CountryBank?> GetCountryBankBySwiftCode(string swiftCode)
        {
            return await _postgresContext.CountryBanks
                .Where(cb => cb.SwiftCode!.ToLower().Equals(swiftCode.ToLower()))
                .FirstOrDefaultAsync();
        }

        public async Task<List<CountryBank>?> GetActiveCountryBanksByBankId(CountryEnum bankId) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    bankId,
                    CacheGroup.Bank
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                var response = await _postgresContext.CountryBanks.Where(cb => cb.BankId == bankId.ToString() && cb.IsActive).ToListAsync();

                return response;
            });

        public async Task<CountryBank?> GetCountryBankByExternalReferenceAndBankId(CountryEnum bankId, string externalReference)
        {
            var BANK_ID = bankId.ToString();
            return await _postgresContext.CountryBanks
                .Where(
                    cb =>
                        cb.BankId == BANK_ID &&
                        cb.ExternalReference == externalReference)
                .FirstOrDefaultAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RODeviceRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Extensions;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RODeviceRepository(ReadPostgresContext postgresContext,
        ICacheService cacheService) : ReadRepositoryAsync<Device, int>(postgresContext), IRODeviceRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        public async Task<List<Device>> GetDevicesByUserIdAsync(Guid userId) =>
         await _cacheService.GetOrCreateAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, userId.ToString(), CacheGroup.Device.GetDescription()),
                TimeSpan.FromMinutes(15),
                async () =>
                {
                    return await _postgresContext.Devices
                        .Where(device => device.UserId == userId && device.IsActive)
                        .ToListAsync();
                });

        public async Task<List<Device>?> GetAllDevicesByUserIdAsync(Guid userId)
        {
            // El mismo método pero para obtener los dispositivos que están activos
            return await _postgresContext.Devices
                .Where(device => device.UserId == userId)
                .ToListAsync();
        }

        public async Task<List<Device>> GetActiveDevicesByUserIdAsync(Guid userId) //
        {
            // El mismo método pero para obtener los dispositivos que están activos
            return await _postgresContext.Devices
                .Where(device => device.UserId == userId && device.IsActive)
                .ToListAsync();
        }

        public async Task<Device?> GetDeviceByIdAsync(Guid userId, int deviceId)
        {
            return await _postgresContext.Devices
                .FirstOrDefaultAsync(device => device.UserId == userId && device.Id == deviceId);
        }

        public async Task<Device?> GetDeviceByUniqueDeviceId(string uniqueDeviceId, Guid userId)
        {
            return await _cacheService.GetOrCreateAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, userId.ToString(), CacheGroup.Device.GetDescription(), uniqueDeviceId),
                TimeSpan.FromMinutes(15),
                async () =>
                {
                    return await _postgresContext.Devices
                        .FirstOrDefaultAsync(device => device.UserId == userId && device.IsActive && device.UniqueDeviceId == uniqueDeviceId);
                });
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFailedOpportunityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFailedOpportunityRepository : ReadRepositoryAsync<FailedOpportunity, int>, IROFailedOpportunityRepository
    {
        private readonly ReadPostgresContext _postgresContext;
        private readonly int _limit;
        private readonly int _maxRetries;
        public ROFailedOpportunityRepository(ReadPostgresContext postgresContext, IConfiguration configuration) : base(postgresContext)
        {
            _postgresContext = postgresContext;
            _limit = configuration.GetValue<int>("RetryOpportunitySettings:MaxOpportunitiesPerBatch", 30); // Usamos 30 como fallback
            _maxRetries = configuration.GetValue<int>("RetryOpportunitySettings:MaxRetryAttempts", 3); // Usamos 3 como fallback
        }

        /// <summary>
        /// Retrieves failed opportunities that are pending retry, 
        /// prioritizing those with the fewest retry attempts.
        /// </summary>
        public async Task<List<FailedOpportunity>> GetPendingOpportunitiesAsync(CancellationToken cancellationToken)
        {
            // Access the DbSet<FailedOpportunity> from the DbContext
            return await _postgresContext.Set<FailedOpportunity>()

            // 1. FILTRO DE ESTADO (Inicial o En Progreso)
            .Where(fo => fo.CurrentStage == CurrentStage.Initial || fo.CurrentStage == CurrentStage.InProgress)

            // 2. FILTRO DE INTENTOS: Menor o igual al valor configurable (_maxRetries)
            .Where(fo => fo.RetriesNumber <= _maxRetries)

            // 3. ORDENAMIENTO: De menor a mayor por RetriesNumber
            .OrderBy(fo => fo.RetriesNumber)

            // 4. LÍMITE: Tomar el número configurable de registros (_limit)
            .Take(_limit)

            .ToListAsync(cancellationToken);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFavoritesRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFavoritesRepository(ReadPostgresContext context) : ReadRepositoryAsync<FavoriteGroup, int>(context), IROFavoritesRepository
    {
        private readonly ReadPostgresContext _context = context;

        public async Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserIdAsync(Guid userId, string bankid)
        {
            // Buscar el perfil del usuario
            var userProfile = await _context.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankid)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return [];

            // Obtener grupos activos y sus transacciones activas
            return await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfile.Id && g.IsActive && g.GroupType == GroupType.Transactions)
                .Include(g => g.FavoriteTransactions.Where(t => t.IsActive))
                    .ThenInclude(ft => ft.CountryBank)
                .Include(g => g.FavoriteTransactions.Where(t => t.IsActive))
                    .ThenInclude(ft => ft.UserDestination)
                .OrderByDescending(g => g.FavoriteTransactions.Max(ft => ft.UpdatedAt))
                .ToListAsync();
        }

        public async Task<List<FavoriteGroup>?> GetAllGroupsByUserProfileIdAsync(Guid userProfileId)
        {
            // Obtener grupos activos y sus transacciones activas
            return await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfileId)
                .Include(g => g.FavoriteTransactions)
                .Include(g => g.FavoriteServices)
                .ToListAsync();
        }

        public async Task<List<FavoriteGroup>> GetActiveGroupsAndServicesByUserIdAsync(Guid userId, string bankid)
        {
            // Buscar el perfil del usuario
            var userProfile = await _context.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankid)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return [];

            // Obtener grupos activos y sus servicios activos
            var groups = await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfile.Id && g.IsActive && g.GroupType == GroupType.Services)
                .Include(g => g.FavoriteServices
                    .Where(s => s.IsActive))
                .ToListAsync();

            return groups.OrderByDescending(g => g.FavoriteServices.Max(fs => fs.UpdatedAt)).ToList();
        }

        public async Task<List<FavoriteTransaction>> GetFavoriteTransactionsByActiveGroupIdAsync(int favoriteTransactionGroupId)
        {
            var favoriteTransactions = await _context.FavoriteGroups
                .Where(fg => fg.Id == favoriteTransactionGroupId && fg.GroupType == GroupType.Transactions && fg.IsActive)
                .SelectMany(f => f.FavoriteTransactions.Where(ft => ft.IsActive))
                .Include(ftcb => ftcb.CountryBank)
                .Include(ftcb => ftcb.UserDestination)
                .ToListAsync();

            // Obtener transacciones activas de un solo grupo
            return favoriteTransactions;
        }

        public async Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserDestinationIdAsync(Guid userDestinationId)
        {
            return await _context.FavoriteGroups
                .Where(g => g.GroupType == GroupType.Transactions)
                .Include(g => g.FavoriteTransactions
                    .Where(t => t.UserDestinationId == userDestinationId))
                .ToListAsync();
        }

        public async Task<List<FavoriteService>> GetFavoriteServicesByActiveGroupIdAsync(int favoriteServiceGroupId)
        {
            var favoriteServices = await _context.FavoriteGroups
                .Where(fg => fg.Id == favoriteServiceGroupId && fg.GroupType == GroupType.Services && fg.IsActive)
                .SelectMany(f => f.FavoriteServices.Where(fs => fs.IsActive))
                .ToListAsync();

            // Obtener servicios activos de un solo grupo
            return favoriteServices;
        }

        public async Task<List<FavoriteGroup>> GetAllFavoritesTransactionGroupsByAccountNumber(Guid profileId, string bankId, string accountNumber)
        {
            var favoriteGroups = await _context.FavoriteGroups
                .Where(fg => fg.IsActive && fg.GroupType == GroupType.Transactions && fg.ProfileId == profileId)
                .Where(fg => fg.FavoriteTransactions.Any(ft => ft.IsActive && ft.ProductNumber == accountNumber))
                .Include(fg => fg.FavoriteTransactions)
                .ToListAsync();

            return favoriteGroups;
        }

        public async Task<List<FavoriteGroup>> GetAllFavoritesServiceGroupsByServiceAndCategoryId(Guid profileId, string serviceId, string categoryId)
        {
            var favoriteGroups = await _context.FavoriteGroups
                .Where(fg => fg.IsActive && fg.GroupType == GroupType.Services && fg.ProfileId == profileId)
                .Where(fg => fg.FavoriteServices.Any(ft => ft.IsActive && ft.ServiceIdCore == serviceId && ft.ServiceCategoryId == categoryId))
                .Include(fg => fg.FavoriteServices)
                .ToListAsync();

            return favoriteGroups;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFrequentlyQuestionsDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFrequentlyQuestionsDetailRepository(ReadPostgresContext context) : ReadRepositoryAsync<FrequentlyQuestionsDetail, int>(context), IROFrequentlyQuestionsDetailRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<FrequentlyQuestionsDetail>> GetDetailByFrequentlyQuestionId(int frequentlyQuestionId)
        {
            var detail = await _postgresContext.FrequentlyQuestionsDetail.Where(x => x.FrequentlyQuestionsId == frequentlyQuestionId && x.IsActive).ToListAsync();

            return detail;
        }

        public async Task<FrequentlyQuestionsDetail> GetDetailByFrequentlyQuestionIdAndLanguage(int frequentlyQuestionId, string language)
        {
            var detail = await _postgresContext.FrequentlyQuestionsDetail.Where(x => x.FrequentlyQuestionsId == frequentlyQuestionId && x.IsActive && x.Language!.Equals(language)).FirstAsync();

            return detail;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFrequentlyQuestionsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFrequentlyQuestionsRepository(ReadPostgresContext context) : ReadRepositoryAsync<FrequentlyQuestions, int>(context), IROFrequentlyQuestionsRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        // Obtener preguntas frecuentes (activas)
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestions()
        {
            var activeFrequentlyQuestions = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive)
                .Include(x => x.FrequentlyQuestionsDetail.Where(faqd => faqd.IsActive))
                .ToListAsync();

            return activeFrequentlyQuestions;
        }

        // Obtener preguntas frecuentes (activas) por id del banco
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankId(CountryEnum bankId)
        {
            var frequentlyQuestionsBank = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive && x.BankId!.Equals(bankId.ToString()))
                .Include(x => x.FrequentlyQuestionsDetail.Where(faqd => faqd.IsActive))
                .ToListAsync();

            return frequentlyQuestionsBank;
        }

        // Obtener preguntas frecuentes (activas) por id del banco y lenguaje
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankIdAndLanguage(CountryEnum bankId, string language)
        {
            var frequentlyQuestionsBank = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive && x.BankId!.Equals(bankId.ToString()))
                .Include(x => x.FrequentlyQuestionsDetail.Where(d => d.Language!.Equals(language) && d.IsActive))
                .ToListAsync();

            return frequentlyQuestionsBank;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFunctionalityRepository(ReadPostgresContext context) : ReadRepositoryAsync<Functionality, int>(context), IROFunctionalityRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<Functionality>> GetActiveFunctionalitiesByUserIdAndBankAsync(Guid userId, string bank)
        {
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bank)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return new List<Functionality>();

            var activeFunctionalityIds = await _postgresContext.UserFunctionalities
                .Where(uf => uf.ProfileId == userProfile.Id && uf.IsActive)
                .Select(uf => uf.FunctionalityId)
                .ToListAsync();

            if (activeFunctionalityIds.Count == 0)
                return new List<Functionality>();

            var functionalities = await _postgresContext.Functionalities
                .Where(f => activeFunctionalityIds.Contains(f.Id) && f.IsActive)
                .ToListAsync();

            var functionalityDict = functionalities.ToDictionary(f => f.Id);

            var parentFunctionalityIds = functionalities
                .Where(f => f.ParentFunctionalityId == null || !functionalities.Exists(c => c.ParentFunctionalityId == f.Id))
                .Select(f => f.Id)
                .ToList();

            var parentFunctionalities = functionalities
                .Where(f => parentFunctionalityIds.Contains(f.Id))
                .ToList();

            BuildHierarchy(parentFunctionalities, functionalityDict);

            return parentFunctionalities;
        }

        public async Task<List<Functionality>> GetFunctionalitiesByBankAsync(string bankId)
        {
            return await _postgresContext.Functionalities
                .Where(f => f.BankId == bankId)
                .ToListAsync();
        }

        private static void BuildHierarchy(List<Functionality> parentFunctionalities, Dictionary<int, Functionality> functionalityDict)
        {
            foreach (var parent in parentFunctionalities)
            {
                var childFunctionalities = functionalityDict.Values
                    .Where(f => f.ParentFunctionalityId == parent.Id)
                    .ToList();

                foreach (var child in childFunctionalities)
                {
                    parent.ChildFunctionalities.Add(child);
                }

                BuildHierarchy(childFunctionalities, functionalityDict);
            }
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFunFactDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFunFactDetailRepository(ReadPostgresContext context) : ReadRepositoryAsync<FunFactDetail, int>(context), IROFunFactDetailRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROFunFactRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROFunFactRepository(ReadPostgresContext context) : ReadRepositoryAsync<FunFact, int>(context), IROFunFactRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        //Obtener todos los fun facts por tipo de categoria
        public async Task<List<FunFact>> GetAllFunFactByCategoryScreenAndBankId(CategoryType categoryType, string screenId, CountryEnum bankId)
        {
            var funFacts = await _postgresContext.FunFact
                .Include(f => f.FunFactDetail)
                .Where(f => f.IsActive &&
                            f.BankId == bankId.ToString() &&
                            f.CategoryType == categoryType &&
                            f.ScreenId == screenId)
                .ToListAsync();

            return funFacts;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROKycRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROKycRepository(ReadPostgresContext context) : ReadRepositoryAsync<Kyc, int>(context), IROKycRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<Kyc>?> GetAllKycsByUserId(Guid userId)
        {
            var kycs = await postgresContext.Kycs.Where(kyc => kyc.UserId == userId).ToListAsync();

            return kycs;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RONotificationConfigRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RONotificationConfigRepository(ReadPostgresContext context) : ReadRepositoryAsync<NotificationConfig, int>(context), IRONotificationConfigRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        /// <returns></returns>
        public async Task<User?> GetNotificationConfigsByUserId(Guid userId)
        {
            return await _postgresContext.Users.Where(u => u.Id.Equals(userId)).Include(ui => ui.NotificationConfigs).FirstOrDefaultAsync();
        }

        public async Task<List<NotificationConfig>?> GetAllNotificationConfigsByUserId(Guid userId)
        {
            return await _postgresContext.NotificationConfigs.Where(nc => nc.UserId == userId).ToListAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RONotificationHistoryRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RONotificationHistoryRepository(ReadPostgresContext context) : ReadRepositoryAsync<NotificationHistory, long>(context), IRONotificationHistoryRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<NotificationHistory>?> GetAllNotificationHistoriesByUserId(Guid userId)
        {
            var notificationHistory = await postgresContext.NotificationHistories.Where(nh => nh.UserId == userId).ToListAsync();
            return notificationHistory;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RONotificationRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RONotificationRepository(ReadPostgresContext context) : ReadRepositoryAsync<Notification, long>(context), IRONotificationRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<Notification>?> GetAllNotificationsByUserId(Guid userId)
        {
            var notifications = await postgresContext.Notifications.Where(n => n.UserId == userId).ToListAsync();

            return notifications;
        }

        public async Task<List<Notification>> GetNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null)
        {
            if (lastDays <= 0)
            {
                throw new ArgumentException("El número de días debe ser mayor a cero", nameof(lastDays));
            }

            var lastDaysDate = DateTime.UtcNow.AddDays(-lastDays);

            var notifications = await postgresContext.Notifications
                    .Where(n =>
                    n.UserId == userId &&
                    n.NotificationType == NotificationType.Push &&
                    n.CreatedAt >= lastDaysDate)
                    .OrderByDescending(n => n.CreatedAt)
                    .ToListAsync();

            if (limit != null && limit > 0)
            {
                notifications = notifications.Take(limit.Value).ToList();
            }

            return notifications;
        }

        public async Task<List<Notification>> GetUnreadNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null)
        {
            if (lastDays <= 0)
            {
                throw new ArgumentException("El número de días debe ser mayor a cero", nameof(lastDays));
            }

            var lastDaysDate = DateTime.UtcNow.AddDays(-lastDays);

            var unreadNotifications = await postgresContext.Notifications
                    .Where(n =>
                    n.UserId == userId &&
                    n.NotificationType == NotificationType.Push &&
                    n.Status != NotificationStatus.Read &&
                    n.CreatedAt >= lastDaysDate)
                    .OrderByDescending(n => n.CreatedAt)
                    .ToListAsync();

            if (limit != null || limit > 0)
            {
                unreadNotifications = unreadNotifications.Take(limit.Value).ToList();
            }

            return unreadNotifications;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RONotificationTextDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RONotificationTextDetailRepository(ReadPostgresContext context) : ReadRepositoryAsync<NotificationTextsDetail, int>(context), IRONotificationTextDetailRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\RONotificationTextsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class RONotificationTextsRepository(ReadPostgresContext context) : ReadRepositoryAsync<NotificationTexts, int>(context), IRONotificationTextsRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<NotificationTexts>> GetNotificationTextsByStatusAndTransactionType(TransactionType? transactionType,
        TransactionStatus? transactionStatus, string language, bool isDebitTransfer)
        {
            return await _postgresContext.NotificationTexts.Where(nt =>
                nt.TransactionType == transactionType
                && nt.TransactionStatus == transactionStatus
                && nt.IsDebit == isDebitTransfer
                && nt.Language == language).ToListAsync();
        }

        public async Task<NotificationTexts?> GetNotificationTextByEspecifiedData(TransactionType? transactionType,
            TransactionStatus? transactionStatus, string language, bool isDebitTransfer, string? externalId)
        {
            return await _postgresContext.NotificationTexts.Where(nt =>
                nt.TransactionType == transactionType
                && nt.TransactionStatus == transactionStatus
                && nt.IsDebit == isDebitTransfer
                && nt.Language == language
                && nt.ExternalId == externalId).FirstOrDefaultAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROOnboardingHistoryRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROOnboardingHistoryRepository(ReadPostgresContext context) : ReadRepositoryAsync<OnboardingHistory, Guid>(context), IROOnboardingHistoryRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<OnboardingHistory>?> GetAllOnboardingHistoriesByUserId(Guid userId)
        {
            var onboardingHistories = await postgresContext.OnboardingHistories.Where(oh => oh.UserId == userId).ToListAsync();

            return onboardingHistories;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROOnboardingRepository.cs
```csharp
using Dapper;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROOnboardingRepository : IROOnboardingRepository
    {
        private readonly DapperContext _context;
        public ROOnboardingRepository(DapperContext context)
        {
            _context = context;
        }

        public async Task<Onboarding?> GetOnboardingByIdentification(string documentNumber, bool includeHistories = false)
        {
            using var connection = _context.CreateReadConnection();

            const string onboardingSql = @"
                WITH user_profile_cte AS (
                    SELECT user_id
                    FROM dxp_app.user_profile
                    WHERE LOWER(document_number) = @DocumentNumber
                    LIMIT 1
                )
                SELECT 
                    o.onboarding_id AS Id,
                    o.user_id AS UserId,
                    o.bank_id AS BankId,
                    o.campaing_id AS CampaingId,
                    o.referenced AS Referenced,
                    o.cost_center AS CostCenter,
                    o.branch_code AS BranchCode,
                    o.official_code AS OfficialCode,
                    o.official_name AS OfficialName,
                    o.sub_official_code AS SubOfficialCode,
                    o.sub_official_name AS SubOfficialName,
                    o.onboard_status AS OnboardStatus,
                    o.created_at AS CreatedAt,
                    o.updated_at AS UpdatedAt,
                    o.deleted_at As DeletedAt
                FROM dxp_app.onboarding o
                WHERE o.user_id = (SELECT user_id FROM user_profile_cte)";

            const string onboardingWithHistoriesSql = @"
                WITH user_profile_cte AS (
                    SELECT user_id
                    FROM dxp_app.user_profile
                    WHERE LOWER(document_number) = @DocumentNumber
                    LIMIT 1
                )
                SELECT 
                    o.onboarding_id AS Id,
                    o.user_id AS UserId,
                    o.bank_id AS BankId,
                    o.campaing_id AS CampaingId,
                    o.referenced AS Referenced,
                    o.cost_center AS CostCenter,
                    o.branch_code AS BranchCode,
                    o.official_code AS OfficialCode,
                    o.official_name AS OfficialName,
                    o.sub_official_code AS SubOfficialCode,
                    o.sub_official_name AS SubOfficialName,
                    o.onboard_status AS OnboardStatus,
                    o.created_at AS CreatedAt,
                    o.updated_at AS UpdatedAt,
                    oh.history_id AS Id,
                    oh.user_id AS UserId,
                    oh.onboarding_id AS OnboardingId,
                    oh.screen_id AS ScreenId,
                    oh.screen_data AS ScreenData,
                    oh.created_at AS CreatedAt,
                    oh.updated_at AS UpdatedAt,
                    oh.deleted_at AS DeletedAt
                FROM dxp_app.onboarding o
                LEFT JOIN dxp_app.onboarding_history oh 
                    ON oh.onboarding_id = o.onboarding_id
                WHERE o.user_id = (SELECT user_id FROM user_profile_cte)
                ORDER BY oh.created_at DESC;";

            if (includeHistories)
            {
                var onboardingDict = new Dictionary<Guid, Onboarding>();

                var result = await connection.QueryAsync<Onboarding, OnboardingHistory, Onboarding>(
                    onboardingWithHistoriesSql,
                    (onboarding, history) =>
                    {
                        if (!onboardingDict.TryGetValue(onboarding.Id, out var onboardingEntry))
                        {
                            onboardingEntry = onboarding;
                            onboardingEntry.OnboardingHistories = new List<OnboardingHistory>();
                            onboardingDict.Add(onboarding.Id, onboardingEntry);
                        }

                        if (history != null)
                            onboardingEntry.OnboardingHistories.Add(history);

                        return onboardingEntry;
                    },
                    new { DocumentNumber = documentNumber.ToLower() },
                    splitOn: "Id"
                );

                return result.FirstOrDefault();
            }

            return await connection.QueryFirstOrDefaultAsync<Onboarding>(
               onboardingSql,
               new { DocumentNumber = documentNumber.ToLower() });
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROOptionItemRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROOptionItemRepository(ReadPostgresContext context) : ReadRepositoryAsync<OptionItem, Guid>(context), IROOptionItemRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<OptionItem>> GetOptionItemsByBankId(string bankId)
        {
            return await _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive && oi.UiGroup.BankId == bankId)
                .ToListAsync();
        }

        public async Task<List<OptionItem>> GetOptionItemsByBankIdAndCategoryId(string bankId, QuickActionCategory category)
        {
            return await _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive && oi.UiGroup.BankId == bankId && oi.Category == category)
                .ToListAsync();
        }

        public async Task<List<OptionItem>> GetOptionItemsByBankIdCategoryIdAndJsonPair(
            string? bankId,
            QuickActionCategory? category,
            string jsonKey,
            string jsonValue)
        {
            var query = _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive)
                .AsQueryable();

            if (!string.IsNullOrEmpty(bankId))
                query = query.Where(q => q.UiGroup.BankId == bankId);

            if (category.HasValue)
                query = query.Where(q => q.Category == category.Value);

            if (!string.IsNullOrEmpty(jsonKey) && !string.IsNullOrEmpty(jsonValue))
            {
                var jsonFragment = $"{{ \"{jsonKey}\": \"{jsonValue}\" }}";
                query = query.Where(q => EF.Functions.JsonContains(q.AdditionalData!, jsonFragment));
            }

            return await query.ToListAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROOtpRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROOtpRepository(ReadPostgresContext context) : ReadRepositoryAsync<Otp, int>(context), IROOtpRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROProfileAddressRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROProfileAddressRepository(ReadPostgresContext context) : ReadRepositoryAsync<ProfileAddress, int>(context), IROProfileAddressRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<ProfileAddress>> GetProfileAddressesByProfileId(Guid profileId)
        {
            var profileAddresses = await postgresContext.ProfileAddress.Where(pa => pa.ProfileId.Equals(profileId) && pa.IsActive).OrderBy(pa => pa.Id).ToListAsync();

            return profileAddresses;
        }

        public async Task<List<ProfileAddress>> GetAllProfileAddressesByProfileId(Guid profileId)
        {
            var profileAddresses = await postgresContext.ProfileAddress.Where(pa => pa.ProfileId.Equals(profileId)).ToListAsync();

            return profileAddresses;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROQuickActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROQuickActionRepository(ReadPostgresContext context) : ReadRepositoryAsync<QuickAction, Guid>(context), IROQuickActionRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<QuickAction>> GetQuickActionsByBankId(string bankId)
        {
            return await _postgresContext.QuickActions
                .Where(qa => qa.IsActive && qa.BankId != null && qa.BankId.Equals(bankId))
                .ToListAsync();
        }

        public async Task<List<QuickAction>> GetQuickActionsByBankIdAndCategoryId(string bankId, QuickActionCategory category)
        {
            return await _postgresContext.QuickActions
                .Where(qa => qa.IsActive && qa.BankId.Equals(bankId) && qa.Category == category)
                .ToListAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTermsAndConditionsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTermsAndConditionsRepository(ReadPostgresContext context) : ReadRepositoryAsync<TermsAndConditions, int>(context), IROTermsAndConditionsRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTransactionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTransactionRepository(ReadPostgresContext context) : ReadRepositoryAsync<Transaction, long>(context), IROTransactionRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<Transaction>?> GetOneTransactionByTransactionTypeAndProfile(UserProfile userProfile, TransactionType transactionType)
        {
            var transactions = await postgresContext.Transactions.Where(t => t.UserProfileId == userProfile.Id && t.TransactionType == transactionType).Take(1).ToListAsync();

            return transactions;
        }

        public async Task<List<TransactionType>?> GetTransactionTypeMadeByUserProfile(UserProfile userProfile)
        {
            var transactions = await postgresContext.Transactions
                .Where(t => t.UserProfileId == userProfile.Id)
                .Select(g => g.TransactionType)
                .Distinct()
                .ToListAsync();

            return transactions;
        }

        /// <summary>
        /// Función de repositorio que obtiene las transacciones en base al número de remesa en AdditionalData
        /// </summary>
        /// <returns></returns>
        public async Task<Transaction?> GetOneTransactionByRemittanceNumber(string remittanceNumber)
        {
            var transaction = await postgresContext.Transactions
                .FromSqlRaw(@"
            SELECT 
                *
            FROM dxp_app.transaction
            WHERE transaction_type = 'Remittances'
              AND additional_data IS NOT NULL
              AND additional_data ? 'Number'
              AND additional_data ->> 'Number' = @remittanceNumber
              AND transaction_status = 'InProgress'
            ORDER BY transaction_id DESC
            LIMIT 1
        ",
                new Npgsql.NpgsqlParameter("remittanceNumber", remittanceNumber)
                )
                .AsNoTracking()
                .SingleOrDefaultAsync();

            return transaction;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTransferMethodCurrencyRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTransferMethodCurrencyRepository(ReadPostgresContext context) : ReadRepositoryAsync<TransferMethodCurrency, int>(context), IROTransferMethodCurrencyRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTransferMethodProductTypeRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTransferMethodProductTypeRepository(ReadPostgresContext context) : ReadRepositoryAsync<TransferMethodProductType, int>(context), IROTransferMethodProductTypeRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTransferMethodRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTransferMethodRepository(ReadPostgresContext context) : ReadRepositoryAsync<TransferMethod, int>(context), IROTransferMethodRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTutorialActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTutorialActionRepository(ReadPostgresContext context) : ReadRepositoryAsync<TutorialAction, int>(context), IROTutorialActionRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTutorialProgressRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTutorialProgressRepository(ReadPostgresContext context) : ReadRepositoryAsync<TutorialProgress, int>(context), IROTutorialProgressRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROTutorialsRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROTutorialsRepository(ReadPostgresContext postgresContext, ICacheService cacheService) : ReadRepositoryAsync<Tutorials, int>(postgresContext), IROTutorialsRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        /// <summary>
        /// Obtiene los tutoriales por banco
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorialsByBank(CountryEnum bankId) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    bankId,
                    CacheGroup.Tutorials
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                return await _postgresContext.Tutorials.Where(t => t.IsActive && t.TutorialBankId.Equals(bankId.ToString())).ToListAsync();
            });

        /// <summary>
        /// Obtiene los tutoriales por banco y categoría
        /// </summary>
        /// <param name="category"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorialsByBankAndCategory(CountryEnum bankId, TutorialCategory category)
        =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    bankId,
                    CacheGroup.Tutorials,
                    category.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                return await _postgresContext.Tutorials.Where(t => t.IsActive && t.TutorialBankId.Equals(bankId.ToString()) && t.Category.Equals(category)).ToListAsync();
            });
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUiGroupRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUiGroupRepository(ReadPostgresContext context) : ReadRepositoryAsync<UiGroup, int>(context), IROUiGroupRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserConditionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserConditionRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserCondition, int>(context), IROUserConditionRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserFailedAttemptRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserFailedAttemptRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserFailedAttempt, int>(context), IROUserFailedAttemptRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserFavoriteFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserFavoriteFunctionalityRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserFavoriteFunctionality, int>(context), IROUserFavoriteFunctionalityRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<UserFavoriteFunctionality>?> GetAllUserFavoriteFunctionalityByUserId(Guid userId)
        {
            var userff = await postgresContext.UserFavoriteFunctionalities.Where(ff => ff.UserId == userId).ToListAsync();

            return userff;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserFeatureStateRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserFeatureStateRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserFeatureState, int>(context), IROUserFeatureStateRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<UserFeatureState>> GetUserFeatureStateByCategoryAndReferenceKey(Guid profileId, UserFeatureCategory category, string? referenceKey)
        {
            var userFeatureStates = await _postgresContext.UserFeatureStates.Where(ufs => ufs.UserProfileId == profileId && ufs.Category == category && ufs.ReferenceKey == referenceKey).ToListAsync();
            return userFeatureStates;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserFunctionalityRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserFunctionality, int>(context), IROUserFunctionalityRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;
        public async Task<List<UserFunctionality>> GetAllUserFunctionalitiesByUserProfileId(Guid? userProfileId)
        {
            var userFunctionality = await _postgresContext.UserFunctionalities.Where(uf => uf.ProfileId == userProfileId).ToListAsync();

            return userFunctionality;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserOptionItemRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserOptionItemRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserOptionItem, Guid>(context), IROUserOptionItemRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<UserOptionItem>?> GetAllUserOptionItemsByUserProfileId(Guid userProfileId)
        {
            var OptionItems = await _postgresContext.UserOptionItems
                .Include(uoi => uoi.OptionItem)
                .Include(uoi => uoi.OptionItem.UiGroup)
                .Where(uoi => uoi.UserProfileId == userProfileId).ToListAsync();

            return OptionItems;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserProductRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserProductRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserProduct, Guid>(context), IROUserProductRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfile(Guid userProfileId) =>
            await _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.IsActive)
                .Include(p => p.UserSubProducts
                    .Where(sp => sp.IsActive))
                .ToListAsync();

        public async Task<List<UserProduct>?> GetAllUserProductsAndSubProductsByUserProfileId(Guid userProfileId) =>
            await _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId)
                .Include(p => p.UserSubProducts)
                .ToListAsync();

        public async Task<UserProduct?> GetProductByAccountNumber(string accountNumber)
        {
            var result = await _postgresContext.UserProducts
                .Include(up => up.UserProfile)
                .ThenInclude(profile => profile.User)
                .ThenInclude(u => u.Devices)
                .FirstOrDefaultAsync(usp => usp.ProductNumber.Equals(accountNumber));

            return result;
        }

        public async Task<UserProduct?> GetUserProductByAccountNumber(string accountNumber)
        {
            // Buscar el UserProduct a través de SubProductNumber
            var userProductFromSubProduct = await _postgresContext.UserSubProducts
                .Include(x => x.UserProduct)
                    .ThenInclude(x => x.UserProfile)
                        .ThenInclude(x => x.User)
                .Where(x => x.SubProductNumber == accountNumber)
                .Select(x => x.UserProduct)
                .FirstOrDefaultAsync();

            if (userProductFromSubProduct != null)
            {
                return userProductFromSubProduct;
            }

            // Buscar el UserProduct a través de ProductNumber
            var userProductFromProduct = await _postgresContext.UserProducts
                .Include(x => x.UserProfile)
                    .ThenInclude(x => x.User)
                .Where(x => x.ProductNumber == accountNumber)
                .FirstOrDefaultAsync();

            return userProductFromProduct;
        }

        public async Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfileIdAndProductTypes(Guid userProfileId, params ProductType[] productTypes)
        {
            IQueryable<UserProduct> query = _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.IsActive);

            if (productTypes.Length > 0)
                query = query.Where(p => productTypes.Contains(p.ProductType));

            return await query
                .Include(p => p.UserSubProducts.Where(sp => sp.IsActive))
                .ToListAsync();
        }

        public async Task<UserProduct?> GetUserProductByProfileIdProductNumberAndProductType(Guid userProfileId, string productNumber, ProductType productType)
        {
            IQueryable<UserProduct> query = _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.ProductNumber == productNumber && p.IsActive && p.ProductType == productType);

            return await query.FirstOrDefaultAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserProfileRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserProfileRepository(
        ReadPostgresContext postgresContext,
        ICacheService cacheService
    ) : ReadRepositoryAsync<UserProfile, Guid>(postgresContext), IROUserProfileRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        public async Task<UserProfile?> GetCachedProfilesByUserIdAndBankIdAsync(
            Guid userId,
            string bankId
        ) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.TryParse(bankId, out CountryEnum bankInEnum)
                        ? bankInEnum
                        : CountryEnum.BLNI,
                    CacheGroup.UserProfile,
                    userId.ToString()
                ),
                TimeSpan.FromMinutes(5),
                async () =>
                {
                    return await _postgresContext
                        .UserProfiles.AsNoTracking()
                        .Include(x => x.User)
                        .FirstOrDefaultAsync(up => up.UserId == userId && up.BankID == bankId);
                }
            );

        public async Task<UserProfile?> GetProfileByCifAsync(string cif, string bankId) =>
            await _postgresContext
                .UserProfiles.Include(p => p.User)
                .FirstOrDefaultAsync(p => p.CIF == cif && p.BankID == bankId && p.IsActive);

        public async Task<UserProfile?> GetProfileByDocumentAsync(
            string documentType,
            string documentNumber,
            string bankId
        ) =>
            await _postgresContext
                .UserProfiles.Include(p => p.User)
                .SingleOrDefaultAsync(p =>
                    p.DocumentType.Equals(documentType.ToUpper())
                    && p.DocumentNumber.Equals(documentNumber.ToUpper())
                    && p.BankID == bankId
                    && p.IsActive
                );

        public async Task<UserProfile?> GetProfileByUserIdAndBankIdAsync(
            Guid userId,
            string bankId
        ) =>
            await _postgresContext
                .UserProfiles.Include(p => p.User)
                .SingleOrDefaultAsync(p => p.UserId == userId && p.BankID == bankId && p.IsActive);

        public async Task<List<UserProfile>> GetProfilesByEmailAsync(string email, string bankId) =>
            await _postgresContext
                .UserProfiles.Include(p => p.User)
                .Where(p =>
                    p.Email != null
                    && p.Email.ToLower().Equals(email.ToLower())
                    && p.BankID == bankId
                    && p.IsActive
                )
                .ToListAsync();
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserQuickActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserQuickActionRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserQuickAction, Guid>(context), IROUserQuickActionRepository
    {
        private readonly ReadPostgresContext _postgresContext = context;

        public async Task<List<UserQuickAction>?> GetAllUserQuickActionsByUserProfileId(Guid userProfileId)
        {
            var quickActions = await _postgresContext.UserQuickActions
                .Include(qa => qa.QuickAction)
                .Where(qa => qa.UserProfileId == userProfileId).ToListAsync();

            return quickActions;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserRepository : ReadRepositoryAsync<User, Guid>, IROUserRepository
    {
        // Contexto para conectar a la base de datos
        private readonly ReadPostgresContext _postgresContext;
        public ROUserRepository(ReadPostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public override async Task<User?> GetByIdAsync(Guid id)
        {
            return await _postgresContext.Users.FirstOrDefaultAsync(u => u.Id == id && u.UserStatus != UserStatus.Deleted);
        }

        public async Task<User?> GetUserByIdentityProviderId(string identityProviderId) =>
            await _postgresContext.Users.FirstOrDefaultAsync(u => u.Auth0UserId == identityProviderId && u.UserStatus != UserStatus.Deleted);
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserRequestRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserRequestRepository(ReadPostgresContext postgresContext) : ReadRepositoryAsync<UserRequest, int>(postgresContext), IROUserRequestRepository
    {
        private readonly ReadPostgresContext _postgresContext = postgresContext;

        public async Task<List<UserRequest>> GetUserRequestsByUserProfileId(Guid userProfileId) =>
        await _postgresContext.UserRequests
            .Where(x => x.UserProfileId.Equals(userProfileId))
            .AsNoTracking()
            .ToListAsync();
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserSubProductRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserSubProductRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserSubProduct, Guid>(context), IROUserSubProductRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<UserSubProduct>?> GetAllSubProductsByProductId(Guid productId)
        {
            var subProducts = await postgresContext.UserSubProducts.Where(usp => usp.ProductId == productId).ToListAsync();

            return subProducts;
        }

        public async Task<UserSubProduct?> GetSubProductByAccountNumber(string accountNumber)
        {
            var result = await postgresContext.UserSubProducts
                .Include(usp => usp.UserProduct)
                .ThenInclude(up => up.UserProfile)
                .ThenInclude(profile => profile.User)
                .ThenInclude(u => u.Devices)
                .FirstOrDefaultAsync(usp => usp.SubProductNumber.Equals(accountNumber));

            return result;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserTransactionConditionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserTransactionConditionRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserTransactionCondition, int>(context), IROUserTransactionConditionRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\ReadonlyRepositories\ROUserTutorialsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.ReadonlyRepositories
{
    public class ROUserTutorialsRepository(ReadPostgresContext context) : ReadRepositoryAsync<UserTutorials, int>(context), IROUserTutorialsRepository
    {
        private readonly ReadPostgresContext postgresContext = context;

        public async Task<List<UserTutorials>> GetUserTutorialsByUserId(Guid userId)
        {
            var userTutorials = await postgresContext.UserTutorials.Where(ut => ut.UserId == userId).ToListAsync();

            return userTutorials;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AccountTypeRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class AccountTypeRepository(PostgresContext postgresContext)
    : RepositoryAsync<AccountType, int>(postgresContext), IAccountTypeRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AdvertisingDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class AdvertisingDetailRepository(PostgresContext postgresContext) : RepositoryAsync<AdvertisingDetail, int>(postgresContext), IAdvertisingDetailRepository;
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AdvertisingRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class AdvertisingRepository : RepositoryAsync<Advertising, int>, IAdvertisingRepository
    {
        private readonly PostgresContext _postgresContext;

        public AdvertisingRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        #region Get

        public async Task<List<Advertising>?> GetAdvertisings()
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive)).ToListAsync();

            return advertising;
        }

        public async Task<List<Advertising>?> GetAdvertisingsByType(AdvertisingType advertisingType)
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive && adv.Type.Equals(advertisingType)).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive)).ToListAsync();

            return advertising;
        }

        public async Task<List<Advertising>?> GetAdvertisingsByRedirectType(RedirectTo redirectTo)
        {
            var advertising = await _postgresContext.Advertising.Where(adv => adv.IsActive).Include(adv => adv.AdvertisingDetail.Where(advd => advd.IsActive && advd.RedirectTo.Equals(redirectTo))).ToListAsync();

            return advertising;
        }

        #endregion Get
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AppResourceRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using LAFISE.CrossCutting.Core.Extensions;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class AppResourceRepository(PostgresContext postgresContext, ICacheService cacheService) : RepositoryAsync<AppResource, int>(postgresContext), IAppResourceRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        public async Task<AppResource?> SearchResourcesByResourceType(ResourceType resourceType) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (resourceType != ResourceType.PrivacyPolicy && resourceType != ResourceType.TermsAndConditions)
                    throw new ArgumentException("El tipo de recurso no pertenece al grupo global");

                return await _postgresContext.AppResources!
                    .Where(r => r.ResourceType == resourceType)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByResourceTypeAndBankId(ResourceType resourceType, string bankId) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByResourceTypeWithBankIdAndProductType(ResourceType resourceType, string bankId, ProductType productType) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString(),
                    CacheGroup.Product.GetDescription(),
                    productType.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                if (productType == default)
                    throw new ArgumentException("El tipo de producto no puede ser vacío");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId && r.ProductType == productType)
                    .FirstOrDefaultAsync();
            });

        public async Task<AppResource?> SearchResourcesByProductTypeAndSubProductAsync(ResourceType resourceType, string bankId, ProductType productType, string subProduct) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    Enum.Parse<CountryEnum>(bankId),
                    CacheGroup.Resources,
                    CacheGroup.Type.GetDescription(),
                    resourceType.ToString(),
                    CacheGroup.Product.GetDescription(),
                    productType.ToString(),
                    subProduct
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                if (resourceType == default)
                    throw new ArgumentException("El tipo de recurso no puede ser vacío");

                if (string.IsNullOrEmpty(bankId))
                    throw new ArgumentException("El BankId es requerido para este método");

                if (string.IsNullOrEmpty(subProduct))
                    throw new ArgumentException("El subProducto es requerido para este método");

                if (productType == default)
                    throw new ArgumentException("El tipo de producto no puede ser vacío");

                return await _postgresContext.AppResources
                    .Where(r => r.ResourceType == resourceType && r.BankId == bankId && r.ProductType == productType && r.SubProduct == subProduct)
                    .FirstOrDefaultAsync();
            });
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AppScreenRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class AppScreenRepository(PostgresContext postgresContext)
    : RepositoryAsync<AppScreen, string>(postgresContext), IAppScreenRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AppSectionCatalogRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class AppSectionCatalogRepository(PostgresContext postgresContext)
    : RepositoryAsync<AppSectionCatalog, int>(postgresContext), IAppSectionCatalogRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AppVersionDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class AppVersionDetailRepository : RepositoryAsync<AppVersionDetail, int>, IAppVersionDetailRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public AppVersionDetailRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public async Task<List<AppVersionDetail>> GetAppVersionDetailByAppVersion(string? appVersion)
        {
            var result = await _postgresContext.AppVersionDetail.Where(avd => avd.AppVersionId != null && avd.AppVersionId.Equals(appVersion)).ToListAsync();

            return result;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\AppVersionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class AppVersionRepository : RepositoryAsync<AppVersion, string>, IAppVersionRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public AppVersionRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        public async Task<AppVersion?> GetLastAppVersion()
        {
            var lastAppVersion = await _postgresContext.AppVersion.OrderByDescending(av => av.CreatedAt).Include(ap => ap.AppVersionDetail).FirstOrDefaultAsync();

            return lastAppVersion;
        }

        public async Task<AppVersion?> GetAppVersionById(string versionId)
        {
            var appVersion = await _postgresContext.AppVersion.Where(av => av.Id.Equals(versionId)).Include(ap => ap.AppVersionDetail).FirstOrDefaultAsync();

            return appVersion;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\BankRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class BankRepository : RepositoryAsync<Bank, string>, IBankRepository
{
    // Contexto para conectar a la base de datos
    private readonly PostgresContext _postgresContext;

    public BankRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        _postgresContext = postgresContext;
    }

    public async Task<List<Bank?>> GetAvailableBanks()
    {
        var availableBanks = await _postgresContext.Banks.Where(b => b.Active ?? false).ToListAsync<Bank?>();

        return availableBanks;
    }
}


```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\BiometricAccountRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class BiometricAccountRepository : RepositoryAsync<BiometricAccount, int>, IBiometricAccountRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public BiometricAccountRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        /// <summary>
        /// Obtiene el usuario con sus cuentas de biometría
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<User?> GetUserBiometricAccountsByUserId(Guid userId)
        {
            var userWithBiometricAccounts = await _postgresContext.Users.Include(u => u.BiometricAccounts.Where(ba => ba.IsActive)).FirstOrDefaultAsync(u => u.Id.Equals(userId));

            return userWithBiometricAccounts;
        }

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<List<BiometricAccount>?> GetBiometricAccountListByUserId(Guid userId)
        {
            var biometricAccountList = await _postgresContext.BiometricAccount.Where(ba => ba.UserId.Equals(userId) && ba.IsActive).ToListAsync();

            return biometricAccountList;
        }

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario (todas las activas e inactivas)
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<List<BiometricAccount>?> GetAllBiometricAccountListByUserId(Guid userId)
        {
            var biometricAccountList = await _postgresContext.BiometricAccount.Where(ba => ba.UserId.Equals(userId)).ToListAsync();

            return biometricAccountList;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\CountryBankProductTypeConfigRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class CountryBankProductTypeConfigRepository(PostgresContext postgresContext)
    : RepositoryAsync<CountryBankProductTypeConfig, int>(postgresContext), ICountryBankProductTypeConfigRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\CountryBankRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class CountryBankRepository(PostgresContext postgresContext, ICacheService cacheService) : RepositoryAsync<CountryBank, int>(postgresContext), ICountryBankRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;
        private readonly ICacheService _cacheService = cacheService;

        /// <summary>
        /// Obtener Country Bank por medio de codigo swift
        /// </summary>
        /// <param name="swiftCode">Swift Code</param>
        /// <returns></returns>
        public async Task<CountryBank?> GetCountryBankBySwiftCode(string swiftCode)
        {
            return await _postgresContext.CountryBanks
                .Where(cb => cb.SwiftCode!.ToLower().Equals(swiftCode.ToLower()))
                .FirstOrDefaultAsync();
        }

        public async Task<List<CountryBank>?> GetActiveCountryBanksByBankId(CountryEnum bankId) =>
            await _cacheService.GetOrCreateAsync(
                CacheKeyBuilder.BuildCacheKey(
                    CacheDomain.DigitalExperience,
                    bankId,
                    CacheGroup.Bank
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                var response = await _postgresContext.CountryBanks.Where(cb => cb.BankId == bankId.ToString() && cb.IsActive).ToListAsync();

                return response;
            });

        public async Task<CountryBank?> GetCountryBankByExternalReferenceAndBankId(CountryEnum bankId, string externalReference)
        {
            var BANK_ID = bankId.ToString();
            return await _postgresContext.CountryBanks
                .Where(
                    cb =>
                        cb.BankId == BANK_ID &&
                        cb.ExternalReference == externalReference)
                .FirstOrDefaultAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\DeviceRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Extensions;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class DeviceRepository : RepositoryAsync<Device, int>, IDeviceRepository
    {
        private readonly PostgresContext _postgresContext;
        private readonly ICacheService _cacheService;

        public DeviceRepository(PostgresContext postgresContext,
            ICacheService cacheService) : base(postgresContext)
        {
            _postgresContext = postgresContext;
            _cacheService = cacheService;
        }

        /// <summary>
        /// Obtiene los dispositivos por ID de usuario.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar los dispositivos.</param>
        /// <returns>Una lista de dispositivos asociados con el ID de usuario especificado.</returns>
        public async Task<List<Device>> GetDevicesByUserIdAsync(Guid userId) =>
         await _cacheService.GetOrCreateAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, userId.ToString(), CacheGroup.Device.GetDescription()),
                TimeSpan.FromMinutes(15),
                async () =>
                {
                    return await _postgresContext.Devices
                        .Where(device => device.UserId == userId && device.IsActive)
                        .ToListAsync();
                });

        /// <summary>
        /// Obtiene los dispositivos (activos o inactivos) por ID de usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<List<Device>?> GetAllDevicesByUserIdAsync(Guid userId)
        {
            // El mismo método pero para obtener los dispositivos que están activos
            return await _postgresContext.Devices
                .Where(device => device.UserId == userId)
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene los dispositivos activos por ID de usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<List<Device>> GetActiveDevicesByUserIdAsync(Guid userId) //
        {
            // El mismo método pero para obtener los dispositivos que están activos
            return await _postgresContext.Devices
                .Where(device => device.UserId == userId && device.IsActive)
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene un dispositivo por ID de usuario y ID de dispositivo.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar el dispositivo.</param>
        /// <param name="deviceId">El ID del dispositivo a buscar.</param>
        /// <returns>El dispositivo correspondiente al ID del usuario y al ID del dispositivo, o null si no se encuentra.</returns>
        public async Task<Device?> GetDeviceByIdAsync(Guid userId, int deviceId)
        {
            return await _postgresContext.Devices
                .FirstOrDefaultAsync(device => device.UserId == userId && device.Id == deviceId);
        }

        /// <summary>
        /// Elimina un dispositivo.
        /// </summary>
        /// <param name="device">El dispositivo a eliminar.</param>
        public async Task DeleteDeviceAsync(Device device)
        {
            // Usamos el método DeleteAsync de la clase base para eliminar la entidad.
            var entity = await _postgresContext.Devices.FindAsync(device.Id);

            if (entity != null)
            {
                // Marca la entidad como eliminada en lugar de eliminarla físicamente
                entity.DeletedAt = DateTime.UtcNow;
                entity.IsActive = false;
                entity.IsPrimary = false;
                // Actualiza la entidad en el contexto
                _postgresContext.Devices.Update(entity);
                await _postgresContext.SaveChangesAsync(); // Guarda los cambios de forma asíncrona
            }
        }

        public async Task UpdateUserDevicesToken(Guid userId, string token)
        {
            await _postgresContext.Devices
                .Where(d => d.UserId == userId)
                .ExecuteUpdateAsync(d => d.SetProperty(dv => dv.DeviceToken, dv => token));

            var devices = _postgresContext.Devices.Where(u => u.UserId == userId);

            // temporal code
            foreach (var device in devices)
            {
                await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, device.UserId.ToString(), CacheGroup.Device.GetDescription(), device.UniqueDeviceId));
            }

            await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, userId.ToString(), CacheGroup.Device.GetDescription()));
        }

        public async Task UpdateUserDevice(Device device)
        {
            _postgresContext.Devices.Update(device);

            await _postgresContext.SaveChangesAsync();

            await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, device.UserId.ToString(), CacheGroup.Device.GetDescription(), device.UniqueDeviceId));
            await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, device.UserId.ToString(), CacheGroup.Device.GetDescription()));
        }

        public async Task InsertUserDeviceAsync(Device device)
        {
            await _postgresContext.Devices.AddAsync(device);
            await _postgresContext.SaveChangesAsync();

            await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, device.UserId.ToString(), CacheGroup.Device.GetDescription()));
            await _cacheService.RemoveAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, device.UserId.ToString(), CacheGroup.Device.GetDescription(), device.UniqueDeviceId));
        }

        public async Task<Device?> GetDeviceByUniqueDeviceId(string uniqueDeviceId, Guid userId)
        {
            return await _cacheService.GetOrCreateAsync(CacheKeyBuilder.BuildCacheKey(CacheDomain.DigitalExperience, CacheGroup.User, userId.ToString(), CacheGroup.Device.GetDescription(), uniqueDeviceId),
                TimeSpan.FromMinutes(15),
                async () =>
                {
                    return await _postgresContext.Devices
                        .FirstOrDefaultAsync(device => device.UserId == userId && device.IsActive && device.UniqueDeviceId == uniqueDeviceId);
                });
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FailedOpportunityRepository.cs
```csharp
using System.Collections.Generic;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    // Adjusted constructor to avoid CS9107 diagnostic.
    public class FailedOpportunityRepository : RepositoryAsync<FailedOpportunity, int>, IFailedOpportunityRepository
    {
        private readonly PostgresContext _postgresContext;
        private readonly int _limit;
        private readonly int _maxRetries;
        public FailedOpportunityRepository(PostgresContext postgresContext, IConfiguration configuration) : base(postgresContext)
        {
            _postgresContext = postgresContext;
            _limit = configuration.GetValue<int>("RetryOpportunitySettings:MaxOpportunitiesPerBatch", 30); // Usamos 30 como fallback
            _maxRetries = configuration.GetValue<int>("RetryOpportunitySettings:MaxRetryAttempts", 3); // Usamos 3 como fallback
        }

        /// <summary>
        /// Retrieves failed opportunities that are pending retry, 
        /// prioritizing those with the fewest retry attempts.
        /// </summary>
        public async Task<List<FailedOpportunity>> GetPendingOpportunitiesAsync(CancellationToken cancellationToken)
        {
            // Access the DbSet<FailedOpportunity> from the DbContext
            return await _postgresContext.Set<FailedOpportunity>()

            // 1. FILTRO DE ESTADO (Inicial o En Progreso)
            .Where(fo => fo.CurrentStage == CurrentStage.Initial || fo.CurrentStage == CurrentStage.InProgress)

            // 2. FILTRO DE INTENTOS: Menor o igual al valor configurable (_maxRetries)
            .Where(fo => fo.RetriesNumber <= _maxRetries)

            // 3. ORDENAMIENTO: De menor a mayor por RetriesNumber
            .OrderBy(fo => fo.RetriesNumber)

            // 4. LÍMITE: Tomar el número configurable de registros (_limit)
            .Take(_limit)

            .ToListAsync(cancellationToken);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FavoritesRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FavoritesRepository(PostgresContext context) : RepositoryAsync<FavoriteGroup, int>(context), IFavoritesRepository
    {
        private readonly PostgresContext _context = context;

        /// <summary>
        /// Obtiene los grupos activos y sus transacciones activas para un usuario.
        /// </summary>
        /// <param name="userId">ID del usuario.</param>
        /// <returns>Lista de grupos activos con transacciones activas.</returns>
        public async Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserIdAsync(Guid userId, string bankid)
        {
            // Buscar el perfil del usuario
            var userProfile = await _context.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankid)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return [];

            // Obtener grupos activos y sus transacciones activas
            return await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfile.Id && g.IsActive && g.GroupType == GroupType.Transactions)
                .Include(g => g.FavoriteTransactions.Where(t => t.IsActive))
                    .ThenInclude(ft => ft.CountryBank)
                .Include(g => g.FavoriteTransactions.Where(t => t.IsActive))
                    .ThenInclude(ft => ft.UserDestination)
                .OrderByDescending(g => g.FavoriteTransactions.Max(ft => ft.UpdatedAt))
                .ToListAsync();
        }

        /// <summary>
        /// Método para obtener una lista de todos los grupos filtrados por id de perfil
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        public async Task<List<FavoriteGroup>?> GetAllGroupsByUserProfileIdAsync(Guid userProfileId)
        {
            // Obtener grupos activos y sus transacciones activas
            return await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfileId)
                .Include(g => g.FavoriteTransactions)
                .Include(g => g.FavoriteServices)
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene los grupos activos y sus servicios activos para un usuario ordenados por actualización.
        /// </summary>
        /// <param name="userId">ID del usuario.</param>
        /// <returns>Lista de grupos activos con servicios activos.</returns>
        public async Task<List<FavoriteGroup>> GetActiveGroupsAndServicesByUserIdAsync(Guid userId, string bankid)
        {
            // Buscar el perfil del usuario
            var userProfile = await _context.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankid)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return [];

            // Obtener grupos activos y sus servicios activos
            var groups = await _context.FavoriteGroups
                .Where(g => g.ProfileId == userProfile.Id && g.IsActive && g.GroupType == GroupType.Services)
                .Include(g => g.FavoriteServices
                    .Where(s => s.IsActive))
                .ToListAsync();

            return groups.OrderByDescending(g => g.FavoriteServices.Max(fs => fs.UpdatedAt)).ToList();
        }

        /// <summary>
        /// Obtiene una lista de las transacciones favoritas a través del id del grupo
        /// </summary>
        /// <param name="favoriteTransactionGroupId"></param>
        /// <returns></returns>
        public async Task<List<FavoriteTransaction>> GetFavoriteTransactionsByActiveGroupIdAsync(int favoriteTransactionGroupId)
        {
            var favoriteTransactions = await _context.FavoriteGroups
                .Where(fg => fg.Id == favoriteTransactionGroupId && fg.GroupType == GroupType.Transactions && fg.IsActive)
                .SelectMany(f => f.FavoriteTransactions.Where(ft => ft.IsActive))
                .Include(ftcb => ftcb.CountryBank)
                .Include(ftcb => ftcb.UserDestination)
                .ToListAsync();

            // Obtener transacciones activas de un solo grupo
            return favoriteTransactions;
        }

        /// <summary>
        /// Metodo para obtener los activos Grupos Favoritos por el Usuario Destino
        /// </summary>
        /// <param name="userDestinationId">Id del Usuario Destino</param>
        /// <returns></returns>
        public async Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserDestinationIdAsync(Guid userDestinationId)
        {
            return await _context.FavoriteGroups
                .Where(g => g.GroupType == GroupType.Transactions)
                .Include(g => g.FavoriteTransactions
                    .Where(t => t.UserDestinationId == userDestinationId))
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene una lista de los servicios favoritos a través del id del grupo
        /// </summary>
        /// <param name="favoriteServiceGroupId"></param>
        /// <returns></returns>
        public async Task<List<FavoriteService>> GetFavoriteServicesByActiveGroupIdAsync(int favoriteServiceGroupId)
        {
            var favoriteServices = await _context.FavoriteGroups
                .Where(fg => fg.Id == favoriteServiceGroupId && fg.GroupType == GroupType.Services && fg.IsActive)
                .SelectMany(f => f.FavoriteServices.Where(fs => fs.IsActive))
                .ToListAsync();

            // Obtener servicios activos de un solo grupo
            return favoriteServices;
        }

        /// <summary>
        /// Crea un grupo y una transacción dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="group">Grupo a crear.</param>
        /// <returns>Grupo creado con la transacción asociada.</returns>
        public async Task<FavoriteGroup?> CreateGroupAndTransactionAsync(FavoriteGroup group)
        {
            await _context.FavoriteGroups.AddAsync(group);
            await _context.SaveChangesAsync();

            return await _context.FavoriteGroups
                .Include(g => g.FavoriteTransactions)
                .ThenInclude(g => g.CountryBank)
                .FirstOrDefaultAsync(g => g.Id == group.Id);
        }

        /// <summary>
        /// Crea un grupo y un servicio dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="group">Grupo a crear.</param>
        /// <returns>Grupo creado con el servicio asociado.</returns>
        public async Task<FavoriteGroup?> CreateGroupAndServiceAsync(FavoriteGroup group)
        {
            await _context.FavoriteGroups.AddAsync(group);
            await _context.SaveChangesAsync(default);

            return await _context.FavoriteGroups
                .Include(g => g.FavoriteServices)
                .FirstOrDefaultAsync(g => g.Id == group.Id);
        }

        /// <summary>
        /// Añade una transacción a un grupo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo.</param>
        /// <param name="transaction">Transacción a añadir.</param>
        public async Task<FavoriteGroup?> AddTransactionToGroupAsync(int groupId, FavoriteTransaction transaction)
        {
            transaction.FavoriteGroupId = groupId;
            await _context.FavoriteTransactions.AddAsync(transaction);
            await _context.SaveChangesAsync();

            return await _context.FavoriteGroups
                .Include(g => g.FavoriteTransactions)
                .FirstOrDefaultAsync(g => g.Id == groupId);
        }

        /// <summary>
        /// Añade un servicio a un grupo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo.</param>
        /// <param name="service">Servicio a añadir.</param>
        public async Task<FavoriteGroup?> AddServiceToGroupAsync(int groupId, FavoriteService service)
        {
            service.FavoriteGroupId = groupId;
            await _context.FavoriteServices.AddAsync(service);
            await _context.SaveChangesAsync();

            return await _context.FavoriteGroups
                .Include(g => g.FavoriteServices)
                .FirstOrDefaultAsync(g => g.Id == groupId);
        }

        /// <summary>
        /// Actualiza un grupo activo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="group">Grupo con datos actualizados.</param>
        public async Task<FavoriteGroup?> UpdateActiveGroupAsync(FavoriteGroup group)
        {
            var existingGroup = await _context.FavoriteGroups
                .FirstOrDefaultAsync(g => g.Id == group.Id && g.IsActive);

            if (existingGroup != null)
            {
                existingGroup.GroupName = group.GroupName;
                existingGroup.UpdatedAt = DateTime.UtcNow;

                _context.FavoriteGroups.Update(existingGroup);
                await _context.SaveChangesAsync();

                return await _context.FavoriteGroups
                    .FirstOrDefaultAsync(g => g.Id == existingGroup.Id);
            }

            return null;
        }

        /// <summary>
        /// Actualiza una transacción activa dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo al que pertenece la transacción.</param>
        /// <param name="transactionId">ID de la transacción.</param>
        /// <param name="updatedTransaction">Datos actualizados de la transacción.</param>
        public async Task<FavoriteTransaction?> UpdateActiveTransactionAsync(int groupId, long transactionId, FavoriteTransaction updatedTransaction)
        {
            var existingTransaction = await _context.FavoriteTransactions
                .FirstOrDefaultAsync(t => t.Id == transactionId && t.FavoriteGroupId == groupId);

            if (existingTransaction != null)
            {
                updatedTransaction.UpdatedAt = DateTime.UtcNow;

                _context.FavoriteTransactions.Update(updatedTransaction);
                await _context.SaveChangesAsync();

                return updatedTransaction;
            }

            return null;
        }

        /// <summary>
        /// Actualiza un servicio activo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo al que pertenece el servicio.</param>
        /// <param name="serviceId">ID del servicio.</param>
        /// <param name="updatedService">Datos actualizados del servicio.</param>
        public async Task<FavoriteService?> UpdateActiveServiceAsync(int groupId, int serviceId, FavoriteService updatedService)
        {
            var existingService = await _context.FavoriteServices
                .FirstOrDefaultAsync(s => s.Id == serviceId && s.FavoriteGroupId == groupId);

            if (existingService != null)
            {
                existingService = updatedService;
                existingService.UpdatedAt = DateTime.UtcNow;

                _context.FavoriteServices.Update(existingService);
                await _context.SaveChangesAsync();

                return existingService;
            }

            return null;
        }
        /// <summary>
        /// Elimina lógicamente una transacción de un grupo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo.</param>
        /// <param name="transactionId">ID de la transacción a eliminar.</param>
        /// <returns>El grupo actualizado con las transacciones aún activas, o null si se eliminó el grupo.</returns>
        public async Task<FavoriteGroup?> RemoveTransactionFromGroupAsync(int groupId, long transactionId)
        {
            var transaction = await _context.FavoriteTransactions
                .FirstOrDefaultAsync(t => t.Id == transactionId && t.FavoriteGroupId == groupId);

            if (transaction != null)
            {
                // Marca la transacción como eliminada en lugar de eliminarla físicamente
                transaction.DeletedAt = DateTime.UtcNow;
                transaction.IsActive = false;

                _context.FavoriteTransactions.Update(transaction);
                await _context.SaveChangesAsync();

                // Verifica si aún hay transacciones activas en el grupo
                var group = await _context.FavoriteGroups
                    .Include(g => g.FavoriteTransactions)
                    .FirstOrDefaultAsync(g => g.Id == groupId);

                if (group != null)
                {
                    if (!group.FavoriteTransactions.Any(t => t.IsActive))
                    {
                        // No quedan transacciones activas, elimina lógicamente el grupo
                        group.DeletedAt = DateTime.UtcNow;
                        group.IsActive = false;
                        _context.FavoriteGroups.Update(group);
                        await _context.SaveChangesAsync();
                    }

                    // Devuelve el grupo con las transacciones aún activas
                    group.FavoriteTransactions = group.FavoriteTransactions.Where(ft => ft.IsActive).ToList();

                    return group;
                }
            }

            return null;
        }

        /// <summary>
        /// Elimina lógicamente un servicio de un grupo dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo.</param>
        /// <param name="serviceId">ID del servicio a eliminar.</param>
        /// <returns>El grupo actualizado con los servicios aún activos, o null si se eliminó el grupo.</returns>
        public async Task<FavoriteGroup?> RemoveServiceFromGroupAsync(int groupId, int serviceId)
        {
            var service = await _context.FavoriteServices
                .FirstOrDefaultAsync(s => s.Id == serviceId && s.FavoriteGroupId == groupId);

            if (service != null)
            {
                // Marca el servicio como eliminado en lugar de eliminarlo físicamente
                service.DeletedAt = DateTime.UtcNow;
                service.IsActive = false;

                _context.FavoriteServices.Update(service);
                await _context.SaveChangesAsync();

                // Verifica si aún hay servicios activos en el grupo
                var group = await _context.FavoriteGroups
                    .Include(g => g.FavoriteServices)
                    .FirstOrDefaultAsync(g => g.Id == groupId);

                if (group != null)
                {
                    if (!group.FavoriteServices.Any(s => s.IsActive))
                    {
                        // No quedan servicios activos, elimina lógicamente el grupo
                        group.DeletedAt = DateTime.UtcNow;
                        group.IsActive = false;
                        _context.FavoriteGroups.Update(group);
                        await _context.SaveChangesAsync();
                    }

                    // Devuelve el grupo con los servicios aún activos
                    group.FavoriteServices = group.FavoriteServices.Where(ft => ft.IsActive).ToList();

                    return group;
                }
            }

            return null;
        }

        /// <summary>
        /// Elimina lógicamente un grupo y sus transacciones dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo a eliminar.</param>
        public async Task DeleteGroupWithTransactionsAsync(int groupId)
        {
            var group = await _context.FavoriteGroups
                .Include(g => g.FavoriteTransactions)
                .FirstOrDefaultAsync(g => g.Id == groupId);

            if (group != null)
            {
                // Marca el grupo como eliminado
                group.DeletedAt = DateTime.UtcNow;
                group.IsActive = false;

                // Marca las transacciones asociadas como eliminadas
                foreach (var transaction in group.FavoriteTransactions)
                {
                    transaction.DeletedAt = DateTime.UtcNow;
                    transaction.IsActive = false;
                }

                _context.FavoriteGroups.Update(group);
                _context.FavoriteTransactions.UpdateRange(group.FavoriteTransactions);
                await _context.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Elimina lógicamente un grupo y sus servicios dentro de una transacción de base de datos.
        /// </summary>
        /// <param name="groupId">ID del grupo a eliminar.</param>
        public async Task DeleteGroupWithServicesAsync(int groupId)
        {
            var group = await _context.FavoriteGroups
                .Include(g => g.FavoriteServices)
                .FirstOrDefaultAsync(g => g.Id == groupId);

            if (group != null)
            {
                // Marca el grupo como eliminado
                group.DeletedAt = DateTime.UtcNow;
                group.IsActive = false;

                // Marca los servicios asociados como eliminados
                foreach (var service in group.FavoriteServices)
                {
                    service.DeletedAt = DateTime.UtcNow;
                    service.IsActive = false;
                }

                _context.FavoriteGroups.Update(group);
                _context.FavoriteServices.UpdateRange(group.FavoriteServices);
                await _context.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Elimina físicamente las transacciones y servicios favoritos en base al id del grupo
        /// </summary>
        /// <param name="groupId"></param>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        public async Task DeleteAllTransactionsAndServicesByGroupId(int groupId)
        {
            var group = await _context.FavoriteGroups
                .Include(g => g.FavoriteTransactions)
                .Include(g => g.FavoriteServices)
                .FirstOrDefaultAsync(g => g.Id == groupId);

            if (group != null)
            {
                if (group.FavoriteTransactions != null && group.FavoriteTransactions.Count != 0)
                    _context.FavoriteTransactions.RemoveRange(group.FavoriteTransactions);

                if (group.FavoriteServices != null && group.FavoriteServices.Count != 0)
                    _context.FavoriteServices.RemoveRange(group.FavoriteServices);

                _context.FavoriteGroups.Remove(group);
            }
        }

        /// <summary>
        /// Obtiene todas las transacciones favoritas de un usuario por medio de un numero de cuenta
        /// </summary>
        /// <param name="accountNumber">Numero de Cuenta</param>
        /// <returns></returns>
        public async Task<List<FavoriteGroup>> GetAllFavoritesTransactionGroupsByAccountNumber(Guid profileId,
            string bankId, string accountNumber)
        {
            var favoriteGroups = await _context.FavoriteGroups
                .Where(fg => fg.IsActive && fg.GroupType == GroupType.Transactions && fg.ProfileId == profileId)
                .Where(fg => fg.FavoriteTransactions.Any(ft => ft.IsActive && ft.ProductNumber == accountNumber))
                .Include(fg => fg.FavoriteTransactions)
                .ToListAsync();

            return favoriteGroups;
        }

        /// <summary>
        /// Obtiene todos los servicios favoritos en base a su id de servicio y categoría
        /// </summary>
        /// <param name="profileId"></param>
        /// <param name="serviceId"></param>
        /// <param name="categoryId"></param>
        /// <returns></returns>
        public async Task<List<FavoriteGroup>> GetAllFavoritesServiceGroupsByServiceAndCategoryId(Guid profileId, string serviceId, string categoryId)
        {
            var favoriteGroups = await _context.FavoriteGroups
                .Where(fg => fg.IsActive && fg.GroupType == GroupType.Services && fg.ProfileId == profileId)
                .Where(fg => fg.FavoriteServices.Any(ft => ft.IsActive && ft.ServiceIdCore == serviceId && ft.ServiceCategoryId == categoryId))
                .Include(fg => fg.FavoriteServices)
                .ToListAsync();

            return favoriteGroups;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FrequentlyQuestionsDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FrequentlyQuestionsDetailRepository : RepositoryAsync<FrequentlyQuestionsDetail, int>, IFrequentlyQuestionsDetailRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public FrequentlyQuestionsDetailRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        public async Task<List<FrequentlyQuestionsDetail>> GetDetailByFrequentlyQuestionId(int frequentlyQuestionId)
        {
            var detail = await _postgresContext.FrequentlyQuestionsDetail.Where(x => x.FrequentlyQuestionsId == frequentlyQuestionId && x.IsActive).ToListAsync();

            return detail;
        }

        public async Task<FrequentlyQuestionsDetail> GetDetailByFrequentlyQuestionIdAndLanguage(int frequentlyQuestionId, string language)
        {
            var detail = await _postgresContext.FrequentlyQuestionsDetail.Where(x => x.FrequentlyQuestionsId == frequentlyQuestionId && x.IsActive && x.Language!.Equals(language)).FirstAsync();

            return detail;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FrequentlyQuestionsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FrequentlyQuestionsRepository : RepositoryAsync<FrequentlyQuestions, int>, IFrequentlyQuestionsRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public FrequentlyQuestionsRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        // Obtener preguntas frecuentes (activas)
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestions()
        {
            var activeFrequentlyQuestions = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive)
                .Include(x => x.FrequentlyQuestionsDetail.Where(faqd => faqd.IsActive))
                .ToListAsync();

            return activeFrequentlyQuestions;
        }

        // Obtener preguntas frecuentes (activas) por id del banco
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankId(CountryEnum bankId)
        {
            var frequentlyQuestionsBank = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive && x.BankId!.Equals(bankId.ToString()))
                .Include(x => x.FrequentlyQuestionsDetail.Where(faqd => faqd.IsActive)).ToListAsync();

            return frequentlyQuestionsBank;
        }

        // Obtener preguntas frecuentes (activas) por id del banco y lenguaje
        public async Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankIdAndLanguage(CountryEnum bankId, string language)
        {
            var frequentlyQuestionsBank = await _postgresContext.FrequentlyQuestions
                .Where(x => x.IsActive && x.BankId!.Equals(bankId.ToString()))
                .Include(x => x.FrequentlyQuestionsDetail.Where(d => d.Language!.Equals(language) && d.IsActive))
                .ToListAsync();

            return frequentlyQuestionsBank;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FunctionalityRepository : RepositoryAsync<Functionality, int>, IFunctionalityRepository
    {
        private readonly PostgresContext _postgresContext;

        public FunctionalityRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }
        #region Get
        /// <summary>
        /// Obtiene todas las funcionalidades activas asociadas con un ID de usuario y un banco.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar las funcionalidades.</param>
        /// <param name="bank">El banco asociado para buscar las funcionalidades.</param>
        /// <returns>Una lista de funcionalidades activas del usuario para el banco especificado.</returns>
        public async Task<List<Functionality>> GetActiveFunctionalitiesByUserIdAndBankAsync(Guid userId, string bank)
        {
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bank)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
                return new List<Functionality>();

            var activeFunctionalityIds = await _postgresContext.UserFunctionalities
                .Where(uf => uf.ProfileId == userProfile.Id && uf.IsActive)
                .Select(uf => uf.FunctionalityId)
                .ToListAsync();

            if (activeFunctionalityIds.Count == 0)
                return new List<Functionality>();

            var functionalities = await _postgresContext.Functionalities
                .Where(f => activeFunctionalityIds.Contains(f.Id) && f.IsActive)
                .ToListAsync();

            var functionalityDict = functionalities.ToDictionary(f => f.Id);

            var parentFunctionalityIds = functionalities
                .Where(f => f.ParentFunctionalityId == null || !functionalities.Exists(c => c.ParentFunctionalityId == f.Id))
                .Select(f => f.Id)
                .ToList();

            var parentFunctionalities = functionalities
                .Where(f => parentFunctionalityIds.Contains(f.Id))
                .ToList();

            BuildHierarchy(parentFunctionalities, functionalityDict);

            return parentFunctionalities;
        }

        /// <summary>
        /// Construye la jerarquía de funcionalidades, asignando funcionalidades hijas a sus padres.
        /// </summary>
        /// <param name="parentFunctionalities">Lista de funcionalidades padre.</param>
        /// <param name="functionalityDict">Diccionario de funcionalidades por ID.</param>
        private static void BuildHierarchy(List<Functionality> parentFunctionalities, Dictionary<int, Functionality> functionalityDict)
        {
            foreach (var parent in parentFunctionalities)
            {
                var childFunctionalities = functionalityDict.Values
                    .Where(f => f.ParentFunctionalityId == parent.Id)
                    .ToList();

                foreach (var child in childFunctionalities)
                {
                    parent.ChildFunctionalities.Add(child);
                }

                BuildHierarchy(childFunctionalities, functionalityDict);
            }
        }

        /// <summary>
        /// Obtiene todas las funcionalidades activas para un banco específico.
        /// </summary>
        /// <param name="bankId">El ID del banco para buscar las funcionalidades.</param>
        /// <returns>Una lista de funcionalidades activas para el banco especificado.</returns>
        public async Task<List<Functionality>> GetFunctionalitiesByBankAsync(string bankId)
        {
            return await _postgresContext.Functionalities
                .Where(f => f.BankId == bankId)
                .ToListAsync();
        }

        #endregion
        #region Add
        /// <summary>
        /// Inserta una lista de funcionalidades en la tabla de UserFunctionality para un usuario y banco especificados.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a asignar al usuario.</param>
        public async Task AddFunctionalitiesToUserAsync(Guid userId, string bankId, List<int> functionalityIds)
        {
            // Obtener el ProfileId del usuario y banco
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile == null)
            {
                throw new InvalidOperationException("El perfil del usuario no existe o no está activo para el banco especificado.");
            }

            // Verificar funcionalidades existentes
            var existingUserFunctionalities = await _postgresContext.UserFunctionalities
                .Where(uf => uf.ProfileId == userProfile.Id && functionalityIds.Contains(uf.FunctionalityId))
                .ToListAsync();

            var existingFunctionalityIds = existingUserFunctionalities.Select(uf => uf.FunctionalityId).ToList();

            var newFunctionalityIds = functionalityIds.Except(existingFunctionalityIds).ToList();

            if (newFunctionalityIds.Count > 0)
            {
                var newUserFunctionalities = newFunctionalityIds.Select(fid => new UserFunctionality
                {
                    ProfileId = userProfile.Id,
                    FunctionalityId = fid,
                    IsActive = true,
                    AssignedDate = DateTime.UtcNow
                }).ToList();

                await _postgresContext.UserFunctionalities.AddRangeAsync(newUserFunctionalities);
                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Activa una funcionalidad específica y asegura que esté activa en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignará la funcionalidad.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad a activar.</param>
        public async Task ActivateFunctionalityAsync(Guid userId, string bankId, int functionalityId)
        {
            var functionality = await _postgresContext.Functionalities
                .FirstOrDefaultAsync(f => f.Id == functionalityId);

            if (functionality != null)
            {
                functionality.IsActive = true;
                _postgresContext.Functionalities.Update(functionality);

                var userProfile = await _postgresContext.UserProfiles
                    .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                    .Select(up => new { up.Id })
                    .FirstOrDefaultAsync();

                if (userProfile != null)
                {
                    var userFunctionality = await _postgresContext.UserFunctionalities
                        .FirstOrDefaultAsync(uf => uf.ProfileId == userProfile.Id && uf.FunctionalityId == functionalityId);

                    if (userFunctionality != null)
                    {
                        userFunctionality.IsActive = true;
                        _postgresContext.UserFunctionalities.Update(userFunctionality);
                    }
                    else
                    {
                        var newUserFunctionality = new UserFunctionality
                        {
                            ProfileId = userProfile.Id,
                            FunctionalityId = functionalityId,
                            IsActive = true,
                            AssignedDate = DateTime.UtcNow
                        };

                        await _postgresContext.UserFunctionalities.AddAsync(newUserFunctionality);
                    }

                    await _postgresContext.SaveChangesAsync();
                }
            }
        }

        /// <summary>
        /// Activa la funcionalidad padre y todas sus funcionalidades hijas en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad padre a activar.</param>
        public async Task ActivateParentFunctionalityAsync(Guid userId, string bankId, int functionalityId)
        {
            var functionality = await _postgresContext.Functionalities
                .Include(f => f.ChildFunctionalities)
                .FirstOrDefaultAsync(f => f.Id == functionalityId);

            if (functionality != null)
            {
                await ActivateRecursiveAsync(functionality.Id);

                var userProfile = await _postgresContext.UserProfiles
                    .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                    .Select(up => new { up.Id })
                    .FirstOrDefaultAsync();

                if (userProfile != null)
                {
                    var functionalityIds = await _postgresContext.Functionalities
                        .Where(f => f.ParentFunctionalityId == functionalityId || f.Id == functionalityId)
                        .Select(f => f.Id)
                        .ToListAsync();

                    var existingUserFunctionalities = await _postgresContext.UserFunctionalities
                        .Where(uf => uf.ProfileId == userProfile.Id && functionalityIds.Contains(uf.FunctionalityId))
                        .ToListAsync();

                    var existingFunctionalityIds = existingUserFunctionalities.Select(uf => uf.FunctionalityId).ToList();
                    var newFunctionalityIds = functionalityIds.Except(existingFunctionalityIds).ToList();

                    if (newFunctionalityIds.Count > 0)
                    {
                        var newUserFunctionalities = newFunctionalityIds.Select(fid => new UserFunctionality
                        {
                            ProfileId = userProfile.Id,
                            FunctionalityId = fid,
                            IsActive = true,
                            AssignedDate = DateTime.UtcNow
                        }).ToList();

                        await _postgresContext.UserFunctionalities.AddRangeAsync(newUserFunctionalities);
                        await _postgresContext.SaveChangesAsync();
                    }
                }
            }
        }
        /// <summary>
        /// Activa de manera recursiva todas las funcionalidades hijas de una funcionalidad padre.
        /// </summary>
        /// <param name="parentId">El ID de la funcionalidad padre a activar.</param>
        /// <summary>
        /// Activa de manera recursiva todas las funcionalidades hijas de una funcionalidad padre.
        /// </summary>
        /// <param name="parentId">El ID de la funcionalidad padre a activar.</param>
        private async Task ActivateRecursiveAsync(int parentId)
        {
            var functionalitiesToActivate = await _postgresContext.Functionalities
                .Where(f => f.ParentFunctionalityId == parentId)
                .ToListAsync();

            foreach (var functionality in functionalitiesToActivate)
            {
                functionality.IsActive = true;
                _postgresContext.Functionalities.Update(functionality);
                await ActivateRecursiveAsync(functionality.Id);
            }

            var parentFunctionality = await _postgresContext.Functionalities
                .FirstOrDefaultAsync(f => f.Id == parentId);

            if (parentFunctionality != null)
            {
                parentFunctionality.IsActive = true;
                _postgresContext.Functionalities.Update(parentFunctionality);
                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Activa una lista de funcionalidades para un usuario específico en un banco determinado.
        /// Si una funcionalidad ya existe en la base de datos para el usuario, se activa. 
        /// Si no existe, se agrega a la base de datos.
        /// </summary>
        /// <param name="userId">El ID del usuario para el cual se activarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a activar.</param>
        public async Task ActivateFunctionalitiesForUserAsync(Guid userId, string bankId, List<int> functionalityIds)
        {
            // Obtener el ProfileId del usuario y banco
            var userProfileId = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                .Select(up => up.Id)
                .FirstOrDefaultAsync();

            if (userProfileId == Guid.Empty)
            {
                throw new InvalidOperationException("El perfil del usuario no existe o no está activo para el banco especificado.");
            }

            // Obtener funcionalidades existentes en la base de datos para el perfil dado
            var existingUserFunctionalities = await _postgresContext.UserFunctionalities
                .Where(uf => uf.ProfileId == userProfileId && functionalityIds.Contains(uf.FunctionalityId))
                .ToListAsync();

            // Crear un diccionario para facilitar la actualización de funcionalidades existentes
            var existingFunctionalityIds = existingUserFunctionalities.Select(uf => uf.FunctionalityId).ToHashSet();
            var newFunctionalityIds = functionalityIds.Except(existingFunctionalityIds).ToList();

            // Activar funcionalidades existentes
            foreach (var existingUserFunctionality in existingUserFunctionalities)
            {
                existingUserFunctionality.IsActive = true;
                _postgresContext.UserFunctionalities.Update(existingUserFunctionality);
            }

            // Agregar nuevas funcionalidades
            if (newFunctionalityIds.Count > 0)
            {
                var newUserFunctionalities = newFunctionalityIds.Select(fid => new UserFunctionality
                {
                    ProfileId = userProfileId,
                    FunctionalityId = fid,
                    IsActive = true,
                    AssignedDate = DateTime.UtcNow
                }).ToList();

                await _postgresContext.UserFunctionalities.AddRangeAsync(newUserFunctionalities);
            }

            // Guardar los cambios en la base de datos
            await _postgresContext.SaveChangesAsync();
        }

        #endregion

        #region Desactive

        /// <summary>
        /// Desactiva un conjunto de funcionalidades para un usuario y banco específicos. 
        /// Si una de las funcionalidades es un padre, se desactivarán automáticamente todas las funcionalidades hijas.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivará las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a desactivar.</param>
        /// <returns>Una tarea que representa la operación asincrónica.</returns>
        public async Task DeactivateFunctionalitiesForUserAsync(Guid userId, string bankId, List<int> functionalityIds)
        {
            // Obtener el perfil del usuario
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile != null)
            {
                // Obtener las funcionalidades a desactivar
                var functionalitiesToDeactivate = await _postgresContext.Functionalities
                    .Where(f => functionalityIds.Contains(f.Id))
                    .Include(f => f.ChildFunctionalities)
                    .ToListAsync();

                // Funcionalidades a desactivar en la tabla UserFunctionalities
                var userFunctionalitiesToDeactivate = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.ProfileId == userProfile.Id && functionalityIds.Contains(uf.FunctionalityId))
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalitiesToDeactivate)
                {
                    userFunctionality.IsActive = false;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                // Desactivar funcionalidades hijas si la funcionalidad es un padre
                foreach (var functionality in functionalitiesToDeactivate)
                {
                    if (functionality.ChildFunctionalities.Count > 0)
                    {
                        await DeactivateRecursiveAsync(functionality.Id);
                    }
                    else
                    {
                        functionality.IsActive = false;
                        _postgresContext.Functionalities.Update(functionality);
                    }
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Desactiva una funcionalidad específica para un usuario y banco, y asegura que esté desactivada en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivará la funcionalidad.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad a desactivar.</param>
        public async Task DeactivateFunctionalityForUserAsync(Guid userId, string bankId, int functionalityId)
        {
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile != null)
            {
                var userFunctionality = await _postgresContext.UserFunctionalities
                    .FirstOrDefaultAsync(uf => uf.ProfileId == userProfile.Id && uf.FunctionalityId == functionalityId);

                if (userFunctionality != null)
                {
                    userFunctionality.IsActive = false;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                    await _postgresContext.SaveChangesAsync();
                }
            }
        }

        /// <summary>
        /// Desactiva la funcionalidad padre y todas sus funcionalidades hijas para un usuario y banco específicos, y asegura que estén desactivadas en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad padre a desactivar.</param>
        public async Task DeactivateParentFunctionalityForUserAsync(Guid userId, string bankId, int functionalityId)
        {
            var userProfile = await _postgresContext.UserProfiles
                .Where(up => up.UserId == userId && up.IsActive && up.BankID == bankId)
                .Select(up => new { up.Id })
                .FirstOrDefaultAsync();

            if (userProfile != null)
            {
                var functionalityIds = await _postgresContext.Functionalities
                    .Where(f => f.ParentFunctionalityId == functionalityId || f.Id == functionalityId)
                    .Select(f => f.Id)
                    .ToListAsync();

                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.ProfileId == userProfile.Id && functionalityIds.Contains(uf.FunctionalityId))
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Desactiva una funcionalidad específica y asegura que esté desactivada en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad a desactivar.</param>
        public async Task DeactivateFunctionalityAsync(int functionalityId)
        {
            var functionality = await _postgresContext.Functionalities
                .FirstOrDefaultAsync(f => f.Id == functionalityId);

            if (functionality != null)
            {
                // Desactiva la funcionalidad
                functionality.IsActive = false;
                _postgresContext.Functionalities.Update(functionality);

                // Desactiva también en UserFunctionality
                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.FunctionalityId == functionalityId)
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Desactiva la funcionalidad padre y todas sus funcionalidades hijas, y asegura que estén desactivadas en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad padre a desactivar.</param>
        public async Task DeactivateParentFunctionalityAsync(int functionalityId)
        {
            var functionality = await _postgresContext.Functionalities
                .Include(f => f.ChildFunctionalities)
                .FirstOrDefaultAsync(f => f.Id == functionalityId);

            if (functionality != null)
            {
                await DeactivateRecursiveAsync(functionality.Id);

                // Desactiva también en UserFunctionality para todas las funcionalidades hijas y la funcionalidad padre
                var functionalityIds = await _postgresContext.Functionalities
                    .Where(f => f.ParentFunctionalityId == functionalityId || f.Id == functionalityId)
                    .Select(f => f.Id)
                    .ToListAsync();

                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => functionalityIds.Contains(uf.FunctionalityId))
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Desactiva de manera recursiva todas las funcionalidades hijas de una funcionalidad padre.
        /// </summary>
        /// <param name="parentId">El ID de la funcionalidad padre a desactivar.</param>
        private async Task DeactivateRecursiveAsync(int parentId)
        {
            var functionalitiesToDeactivate = await _postgresContext.Functionalities
                .Where(f => f.ParentFunctionalityId == parentId)
                .ToListAsync();

            foreach (var functionality in functionalitiesToDeactivate)
            {
                functionality.IsActive = false;
                _postgresContext.Functionalities.Update(functionality);
                await DeactivateRecursiveAsync(functionality.Id);
            }

            var parentFunctionality = await _postgresContext.Functionalities
                .FirstOrDefaultAsync(f => f.Id == parentId);

            if (parentFunctionality != null)
            {
                parentFunctionality.IsActive = false;
                _postgresContext.Functionalities.Update(parentFunctionality);
                await _postgresContext.SaveChangesAsync();
            }
        }

        #endregion
        #region Delete
        /// <summary>
        /// Elimina una funcionalidad desactivándola y marcándola como eliminada, incluyendo la actualización en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad a eliminar.</param>
        public async Task DeleteFunctionalityAsync(int functionalityId)
        {
            var functionality = await _postgresContext.Functionalities
                .Include(f => f.ChildFunctionalities)
                .FirstOrDefaultAsync(f => f.Id == functionalityId);

            if (functionality != null)
            {
                await DeleteRecursiveAsync(functionality.Id);

                // Actualizar UserFunctionality para marcar la funcionalidad como eliminada
                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.FunctionalityId == functionalityId)
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    userFunctionality.DeletedAt = DateTime.UtcNow;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        /// <summary>
        /// Elimina de manera recursiva todas las funcionalidades hijas de una funcionalidad padre, y asegura que estén marcadas como eliminadas en UserFunctionality.
        /// </summary>
        /// <param name="parentId">El ID de la funcionalidad padre a eliminar.</param>
        private async Task DeleteRecursiveAsync(int parentId)
        {
            var functionalitiesToDelete = await _postgresContext.Functionalities
                .Where(f => f.ParentFunctionalityId == parentId)
                .ToListAsync();

            foreach (var functionality in functionalitiesToDelete)
            {
                functionality.IsActive = false;
                functionality.DeletedAt = DateTime.UtcNow;
                _postgresContext.Functionalities.Update(functionality);

                // Desactiva y marca como eliminada en UserFunctionality
                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.FunctionalityId == functionality.Id)
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    userFunctionality.DeletedAt = DateTime.UtcNow;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await DeleteRecursiveAsync(functionality.Id);
            }

            var parentFunctionality = await _postgresContext.Functionalities
                .FirstOrDefaultAsync(f => f.Id == parentId);

            if (parentFunctionality != null)
            {
                parentFunctionality.IsActive = false;
                parentFunctionality.DeletedAt = DateTime.UtcNow;
                _postgresContext.Functionalities.Update(parentFunctionality);

                // Desactiva y marca como eliminada en UserFunctionality
                var userFunctionalities = await _postgresContext.UserFunctionalities
                    .Where(uf => uf.FunctionalityId == parentId)
                    .ToListAsync();

                foreach (var userFunctionality in userFunctionalities)
                {
                    userFunctionality.IsActive = false;
                    userFunctionality.DeletedAt = DateTime.UtcNow;
                    _postgresContext.UserFunctionalities.Update(userFunctionality);
                }

                await _postgresContext.SaveChangesAsync();
            }
        }

        #endregion

    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FunFactDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FunFactDetailRepository : RepositoryAsync<FunFactDetail, int>, IFunFactDetailRepository
    {
        public FunFactDetailRepository(PostgresContext postgresContext) : base(postgresContext)
        {
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\FunFactRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class FunFactRepository : RepositoryAsync<FunFact, int>, IFunFactRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;
        public FunFactRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        //Obtener todos los fun facts por tipo de categoria
        public async Task<List<FunFact>> GetAllFunFactByCategoryScreenAndBankId(CategoryType categoryType, string screenId, CountryEnum bankId)
        {
            var funFacts = await _postgresContext.FunFact
                .Include(f => f.FunFactDetail)
                .Where(f => f.IsActive &&
                            f.BankId == bankId.ToString() &&
                            f.CategoryType == categoryType &&
                            f.ScreenId == screenId)
                .ToListAsync();

            return funFacts;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\KycRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class KycRepository : RepositoryAsync<Kyc, int>, IKycRepository
{
    private readonly PostgresContext postgresContext;

    public KycRepository(PostgresContext _context) : base(_context)
    {
        postgresContext = _context;
    }

    /// <summary>
    /// Obtiene los kycs del usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    public async Task<List<Kyc>?> GetAllKycsByUserId(Guid userId)
    {
        var kycs = await postgresContext.Kycs.Where(kyc => kyc.UserId == userId).ToListAsync();

        return kycs;
    }
}


```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\NotificationConfigRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class NotificationConfigRepository : RepositoryAsync<NotificationConfig, int>, INotificationConfigRepository
{
    // Contexto para conectar a la base de datos
    private readonly PostgresContext _postgresContext;

    public NotificationConfigRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        _postgresContext = postgresContext;
    }

    /// <summary>
    /// Obtiene el usuario con sus configuraciones de notificaciones
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    public async Task<User?> GetNotificationConfigsByUserId(Guid userId)
    {
        return await _postgresContext.Users.Where(u => u.Id.Equals(userId)).Include(ui => ui.NotificationConfigs).FirstOrDefaultAsync();
    }

    /// <summary>
    /// Obtiene las configuraciones de notificaciones según un usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    public async Task<List<NotificationConfig>?> GetAllNotificationConfigsByUserId(Guid userId)
    {
        return await _postgresContext.NotificationConfigs.Where(nc => nc.UserId == userId).ToListAsync();
    }
}


```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\NotificationHistoryRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class NotificationHistoryRepository : RepositoryAsync<NotificationHistory, long>, INotificationHistoryRepository
{
    private readonly PostgresContext postgresContext;

    public NotificationHistoryRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        this.postgresContext = postgresContext;
    }

    /// <summary>
    /// /// Obtiene las historias de notificaciones según el usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    public async Task<List<NotificationHistory>?> GetAllNotificationHistoriesByUserId(Guid userId)
    {
        var notificationHistory = await postgresContext.NotificationHistories.Where(nh => nh.UserId == userId).ToListAsync();
        return notificationHistory;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\NotificationRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class NotificationRepository : RepositoryAsync<Notification, long>, INotificationRepository
{
    private readonly PostgresContext postgresContext;

    public NotificationRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        this.postgresContext = postgresContext;
    }

    /// <summary>
    /// Obtiene todas las notificaciones según el ID del usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    public async Task<List<Notification>?> GetAllNotificationsByUserId(Guid userId)
    {
        var notifications = await postgresContext.Notifications.Where(n => n.UserId == userId).ToListAsync();

        return notifications;
    }

    /// <summary>
    /// Obtiene todas las notificaciones según un usuario específico y los últimos días especificados
    /// </summary>
    /// <param name="userId"></param>
    /// <param name="lastDays"></param>
    /// <param name="limit"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public async Task<List<Notification>> GetNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null)
    {
        if (lastDays <= 0)
        {
            throw new ArgumentException("El número de días debe ser mayor a cero", nameof(lastDays));
        }

        var lastDaysDate = DateTime.UtcNow.AddDays(-lastDays);

        var notifications = await postgresContext.Notifications
                .Where(n =>
                n.UserId == userId &&
                n.NotificationType == NotificationType.Push &&
                n.CreatedAt >= lastDaysDate)
                .OrderByDescending(n => n.CreatedAt)
                .ToListAsync();

        if (limit != null && limit > 0)
        {
            notifications = notifications.Take(limit.Value).ToList();
        }

        return notifications;
    }

    /// <summary>
    /// Obtiene todas las notificaciones (no leídas) según un usuario específico y los últimos días especificados
    /// </summary>
    /// <param name="userId"></param>
    /// <param name="lastDays"></param>
    /// <param name="limit"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public async Task<List<Notification>> GetUnreadNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null)
    {
        if (lastDays <= 0)
        {
            throw new ArgumentException("El número de días debe ser mayor a cero", nameof(lastDays));
        }

        var lastDaysDate = DateTime.UtcNow.AddDays(-lastDays);

        var unreadNotifications = await postgresContext.Notifications
                .Where(n =>
                n.UserId == userId &&
                n.NotificationType == NotificationType.Push &&
                n.Status != NotificationStatus.Read &&
                n.CreatedAt >= lastDaysDate)
                .OrderByDescending(n => n.CreatedAt)
                .ToListAsync();

        if (limit != null || limit > 0)
        {
            unreadNotifications = unreadNotifications.Take(limit.Value).ToList();
        }

        return unreadNotifications;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\NotificationTextsDetailRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class NotificationTextsDetailRepository : RepositoryAsync<NotificationTextsDetail, int>, INotificationTextsDetailRepository
    {
        private readonly PostgresContext _postgresContext;

        public NotificationTextsDetailRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext ?? throw new ArgumentNullException(nameof(postgresContext));
        }

        public async Task<List<NotificationTextsDetail>> GetAllNotificationTextsByLanguage(string language)
        {
            var nt = await _postgresContext.NotificationTextsDetail.Where(x => x.Language == language).ToListAsync();

            return nt;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\NotificationTextsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class NotificationTextsRepository : RepositoryAsync<NotificationTexts, int>, INotificationTextsRepository
{
    private readonly PostgresContext _postgresContext;

    public NotificationTextsRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        _postgresContext = postgresContext ?? throw new ArgumentNullException(nameof(postgresContext));
    }

    public async Task<List<NotificationTexts>> GetNotificationTextsByStatusAndTransactionType(TransactionType? transactionType,
        TransactionStatus? transactionStatus, string language, bool isDebitTransfer)
    {
        return await _postgresContext.NotificationTexts.AsNoTracking().Where(nt =>
            nt.TransactionType == transactionType
            && nt.TransactionStatus == transactionStatus
            && nt.IsDebit == isDebitTransfer
            && nt.Language == language).ToListAsync();
    }

    public async Task<NotificationTexts?> GetNotificationTextByEspecifiedData(TransactionType? transactionType,
        TransactionStatus? transactionStatus, string language, bool isDebitTransfer, string? externalId)
    {
        return await _postgresContext.NotificationTexts.AsNoTracking().Where(nt =>
            nt.TransactionType == transactionType
            && nt.TransactionStatus == transactionStatus
            && nt.IsDebit == isDebitTransfer
            && nt.Language == language
            && nt.ExternalId == externalId).FirstOrDefaultAsync();
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\OnboardingHistoryRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class OnboardingHistoryRepository : RepositoryAsync<OnboardingHistory, Guid>, IOnboardingHistoryRepository
{
    private readonly PostgresContext postgresContext;

    public OnboardingHistoryRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        this.postgresContext = postgresContext;
    }

    public async Task<List<OnboardingHistory>?> GetAllOnboardingHistoriesByUserId(Guid userId)
    {
        var onboardingHistories = await postgresContext.OnboardingHistories.Where(oh => oh.UserId == userId).ToListAsync();

        return onboardingHistories;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\OnboardingRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class OnboardingRepository : RepositoryAsync<Onboarding, Guid>, IOnboardingRepository
{
    private readonly PostgresContext _postgresContext;

    public OnboardingRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        _postgresContext = postgresContext;
    }

    /// <summary>
    /// Obtiene el onboarding por número de identificación.
    /// </summary>
    /// <param name="identification">El número de identificación para buscar el onboarding.</param>
    /// <returns>El onboarding asociado con el número de identificación especificado.</returns>
    public async Task<Onboarding?> GetOnboardingByIdentification(string identification)
    {
        return await _postgresContext.Onboardings
            .Include(on => on.OnboardingHistories)
            .FirstOrDefaultAsync(on => on.User.UserProfiles
            .Any(p => p.DocumentNumber.ToLower().Equals(identification.ToLower())));
    }

    public async Task<Onboarding?> GetLastOnboardingByIdentification(string identification, string bankId)
    {
        return await _postgresContext.Onboardings
            .Where(on => on.User.UserProfiles
                .Any(p => EF.Functions.ILike(p.DocumentNumber, identification) && p.BankID == bankId))
            .OrderByDescending(on => on.CreatedAt)
            .Include(on => on.OnboardingHistories)
            .FirstOrDefaultAsync();

    }

    public async Task<Onboarding?> GetOnboardingByUserId(Guid userId)
    {
        var onboarding = await _postgresContext.Onboardings
            .Include(on => on.User)
            .Include(on => on.OnboardingHistories)
            .Where(on => on.User.Id.Equals(userId))
            .SingleOrDefaultAsync();

        return onboarding;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\OptionItemRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class OptionItemRepository(PostgresContext postgresContext)
        : RepositoryAsync<OptionItem, Guid>(postgresContext), IOptionItemRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;

        public async Task<List<OptionItem>> GetOptionItemsByBankId(string bankId)
        {
            return await _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive && oi.UiGroup.BankId == bankId)
                .ToListAsync();
        }

        public async Task<List<OptionItem>> GetOptionItemsByBankIdAndCategoryId(string bankId, QuickActionCategory category)
        {
            return await _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive && oi.UiGroup.BankId == bankId && oi.Category == category)
                .ToListAsync();
        }

        public async Task<List<OptionItem>> GetOptionItemsByBankIdCategoryIdAndJsonPair(
            string? bankId,
            QuickActionCategory? category,
            string jsonKey,
            string jsonValue)
        {
            var query = _postgresContext.OptionItems
                .Include(oi => oi.UiGroup)
                .Where(oi => oi.IsActive)
                .AsQueryable();

            if (!string.IsNullOrEmpty(bankId))
                query = query.Where(q => q.UiGroup.BankId == bankId);

            if (category.HasValue)
                query = query.Where(q => q.Category == category.Value);

            if (!string.IsNullOrEmpty(jsonKey) && !string.IsNullOrEmpty(jsonValue))
            {
                var jsonFragment = $"{{ \"{jsonKey}\": \"{jsonValue}\" }}";
                query = query.Where(q => EF.Functions.JsonContains(q.AdditionalData!, jsonFragment));
            }

            return await query.ToListAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\OtpRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class OtpRepository(PostgresContext postgresContext)
    : RepositoryAsync<Otp, int>(postgresContext), IOtpRepository;


```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\ProfileAddressRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class ProfileAddressRepository : RepositoryAsync<ProfileAddress, int>, IProfileAddressRepository
    {
        private readonly PostgresContext postgresContext;

        public ProfileAddressRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            this.postgresContext = postgresContext;
        }

        #region C

        // CREACIÓN

        /// <summary>
        /// Se crea una dirección para el perfil
        /// </summary>
        /// <param name="profileAddress"></param>
        /// <returns></returns>
        public async Task<ProfileAddress> CreateProfileAddress(ProfileAddress profileAddress)
        {
            var result = await postgresContext.ProfileAddress.AddAsync(profileAddress);
            await postgresContext.SaveChangesAsync();

            return result.Entity;
        }

        #endregion C

        #region R

        // CONSULTA

        /// <summary>
        /// Se obtienen las direcciones del perfil (solo activas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        public async Task<List<ProfileAddress>> GetProfileAddressesByProfileId(Guid profileId)
        {
            var profileAddresses = await postgresContext.ProfileAddress.Where(pa => pa.ProfileId.Equals(profileId) && pa.IsActive).OrderBy(pa => pa.Id).ToListAsync();

            return profileAddresses;
        }

        /// <summary>
        /// Se obtienen todas las direcciones del perfil (ya sea que estén activas o inactivas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        public async Task<List<ProfileAddress>> GetAllProfileAddressesByProfileId(Guid profileId)
        {
            var profileAddresses = await postgresContext.ProfileAddress.Where(pa => pa.ProfileId.Equals(profileId)).ToListAsync();

            return profileAddresses;
        }

        #endregion R

        #region U

        // ACTUALIZACIÓN

        /// <summary>
        /// Se puede actualizar solamente el alias y la dirección
        /// </summary>
        /// <param name="profileAddress"></param>
        /// <returns></returns>
        public async Task<ProfileAddress?> UpdateProfileAddress(ProfileAddress profileAddress)
        {
            var updateProfileAddress = await postgresContext.ProfileAddress.FirstOrDefaultAsync(pa => pa.Id == profileAddress.Id && pa.IsActive);

            if (updateProfileAddress != null)
            {
                if (!string.IsNullOrEmpty(profileAddress.Alias))
                    updateProfileAddress.Alias = profileAddress.Alias;

                if (!string.IsNullOrEmpty(profileAddress.Address))
                    updateProfileAddress.Address = profileAddress.Address;

                if (!string.IsNullOrEmpty(profileAddress.GeographicalLocation))
                    updateProfileAddress.GeographicalLocation = profileAddress.GeographicalLocation;

                if (profileAddress.AddressType != updateProfileAddress.AddressType)
                    updateProfileAddress.AddressType = profileAddress.AddressType;

                if (profileAddress.Latitude != null && !profileAddress.Latitude.Equals(updateProfileAddress.Latitude))
                    updateProfileAddress.Latitude = profileAddress.Latitude;

                if (profileAddress.Longitude != null && !profileAddress.Latitude.Equals(updateProfileAddress.Longitude))
                    updateProfileAddress.Longitude = profileAddress.Longitude;

                postgresContext.ProfileAddress.Update(updateProfileAddress);

                await postgresContext.SaveChangesAsync();

                return updateProfileAddress;
            }

            return null;
        }

        #endregion U

        #region D

        // ELIMINACIÓN

        /// <summary>
        /// Se elimina la dirección de manera lógica
        /// </summary>
        /// <param name="profileAddressId"></param>
        /// <returns></returns>
        public async Task DeleteProfileAddress(int profileAddressId)
        {
            var deleteProfileAddress = await postgresContext.ProfileAddress.FirstOrDefaultAsync(pa => pa.Id == profileAddressId && pa.IsActive);

            if (deleteProfileAddress != null)
            {
                deleteProfileAddress.DeletedAt = DateTime.UtcNow;
                deleteProfileAddress.IsActive = false;

                postgresContext.ProfileAddress.Update(deleteProfileAddress);

                await postgresContext.SaveChangesAsync();
            }
        }

        #endregion D
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\QuickActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class QuickActionRepository(PostgresContext postgresContext)
        : RepositoryAsync<QuickAction, Guid>(postgresContext), IQuickActionRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;

        public async Task<List<QuickAction>> GetQuickActionsByBankId(string bankId)
        {
            return await _postgresContext.QuickActions
                .Where(qa => qa.IsActive && qa.BankId != null && qa.BankId.Equals(bankId))
                .ToListAsync();
        }

        public async Task<List<QuickAction>> GetQuickActionsByBankIdAndCategoryId(string bankId, QuickActionCategory category)
        {
            return await _postgresContext.QuickActions
                .Where(qa => qa.IsActive && qa.BankId.Equals(bankId) && qa.Category == category)
                .ToListAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\RepositorySettings.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class RepositorySettings
{
    public IAppScreenRepository? AppScreens { get; set; }
    public IAppSectionCatalogRepository? AppSectionCatalogs { get; set; }
    public IDeviceRepository? Devices { get; set; }
    public IOnboardingRepository? Onboardings { get; set; }
    public IOnboardingHistoryRepository? OnboardingHistories { get; set; }
    public IOtpRepository? Otps { get; set; }
    public IUserFavoriteFunctionalityRepository? UserFavoriteFunctionalities { get; set; }
    public IUserRepository? Users { get; set; }
    public IKycRepository? Kycs { get; set; }
    public IBankRepository? Banks { get; set; }
    public INotificationConfigRepository? NotificationConfigs { get; set; }
    public INotificationRepository? Notifications { get; set; }
    public INotificationHistoryRepository? NotificationHistories { get; set; }
    public ICountryBankRepository? CountryBanks { get; set; }
    public IProfileRepository? UserProfiles { get; set; }
    public IUserRequestRepository? UserRequests { get; set; }
    public IAccountTypeRepository? AccountTypes { get; set; }
    public IFavoritesRepository? FavoritesRepository { get; set; }
    public IAppResourceRepository? AppResources { get; set; }
    public IUserProductRepository? UserProducts { get; set; }
    public IUserSubProductRepository? UserSubProducts { get; set; }
    public IFunctionalityRepository? Functionalities { get; set; }
    public IUserFunctionalityRepository? UserFunctionalities { get; set; }
    public ITransactionRepository? Transactions { get; set; }
    public INotificationTextsRepository? NotificationTexts { get; set; }
    public IFrequentlyQuestionsRepository? FrequentlyQuestions { get; set; }
    public IFrequentlyQuestionsDetailRepository? FrequentlyQuestionsDetail { get; set; }
    public IUserTutorialsRepository? UserTutorials { get; set; }
    public INotificationTextsDetailRepository? NotificationTextsDetail { get; set; }
    public ITutorialsRepository? Tutorials { get; set; }
    public IProfileAddressRepository? ProfileAddress { get; set; }
    public IBiometricAccountRepository? BiometricAccount { get; set; }
    public IUserFailedAttemptRepository? UserFailedAttempts { get; set; }
    public IAppVersionRepository? AppVersion { get; set; }
    public IAppVersionDetailRepository? AppVersionDetail { get; set; }
    public IUserTransactionConditionRepository? UserTransactionConditions { get; set; }
    public IAdvertisingRepository? Advertising { get; set; }
    public IAdvertisingDetailRepository? AdvertisingDetail { get; set; }
    public IQuickActionRepository? QuickActions { get; set; }
    public IUserQuickActionRepository? UserQuickActions { get; set; }
    public ITransferMethodRepository? TransferMethods { get; set; }
    public ITransferMethodCurrencyRepository? TransferMethodCurrencies { get; set; }
    public ITransferMethodProductTypeRepository? TransferMethodProductTypes { get; set; }
    public ICountryBankProductTypeConfigRepository? CountryBankProductTypeConfigs { get; set; }
    public ITutorialProgressRepository? TutorialProgress { get; set; }
    public ITutorialActionRepository? TutorialAction { get; set; }
    public IUserConditionRepository? UserCondition { get; set; }
    public ITermsAndConditionsRepository? TermsAndConditions { get; set; }
    public IUiGroupRepository? UiGroups { get; set; }
    public IOptionItemRepository? OptionItems { get; set; }
    public IUserOptionItemRepository? UserOptionItems { get; set; }
    public IFailedOpportunityRepository? FailedOpportunity { get; set; }
    public IFunFactRepository? FunFactItems { get; set; }
    public IFunFactDetailRepository? FunFactDetailItems { get; set; }
    public IUserFeatureStateRepository? UserFeatureStates { get; set; }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TermsAndConditionsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class TermsAndConditionsRepository(PostgresContext postgresContext) : RepositoryAsync<TermsAndConditions, int>(postgresContext), ITermsAndConditionsRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TransactionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TransactionRepository : RepositoryAsync<Transaction, long>, ITransactionRepository
{
    private readonly PostgresContext postgresContext;

    public TransactionRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        this.postgresContext = postgresContext;
    }

    /// <summary>
    /// Función de repositorio que obtiene las transacciones en base al usuario, el número de producto y el tipo de transacción
    /// </summary>
    /// <returns></returns>
    public async Task<List<Transaction>?> GetOneTransactionByTransactionTypeAndProfile(UserProfile userProfile, TransactionType transactionType)
    {
        var transactions = await postgresContext.Transactions.Where(t => t.UserProfileId == userProfile.Id && t.TransactionType == transactionType).Take(1).ToListAsync();

        return transactions;
    }

    public async Task<List<TransactionType>?> GetTransactionTypeMadeByUserProfile(UserProfile userProfile)
    {
        var transactions = await postgresContext.Transactions
            .Where(t => t.UserProfileId == userProfile.Id)
            .Select(g => g.TransactionType)
            .Distinct()
            .ToListAsync();

        return transactions;
    }

    /// <summary>
    /// Función de repositorio que obtiene las transacciones en base al número de remesa en AdditionalData
    /// </summary>
    /// <returns></returns>
    public async Task<Transaction?> GetOneTransactionByRemittanceNumber(string remittanceNumber)
    {
        var transaction = await postgresContext.Transactions
            .FromSqlRaw(@"
            SELECT 
                *
            FROM dxp_app.transaction
            WHERE transaction_type = 'Remittances'
              AND additional_data IS NOT NULL
              AND additional_data ? 'Number'
              AND additional_data ->> 'Number' = @remittanceNumber
              AND transaction_status = 'InProgress'
            ORDER BY transaction_id DESC
            LIMIT 1
        ",
            new Npgsql.NpgsqlParameter("remittanceNumber", remittanceNumber)
            )
            .AsNoTracking()
            .SingleOrDefaultAsync();

        return transaction;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TransferMethodCurrencyRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TransferMethodCurrencyRepository(PostgresContext postgresContext)
    : RepositoryAsync<TransferMethodCurrency, int>(postgresContext), ITransferMethodCurrencyRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TransferMethodProductTypeRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TransferMethodProductTypeRepository(PostgresContext postgresContext)
    : RepositoryAsync<TransferMethodProductType, int>(postgresContext), ITransferMethodProductTypeRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TransferMethodRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TransferMethodRepository(PostgresContext postgresContext)
    : RepositoryAsync<TransferMethod, int>(postgresContext), ITransferMethodRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TutorialActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TutorialActionRepository(PostgresContext postgresContext)
    : RepositoryAsync<TutorialAction, int>(postgresContext), ITutorialActionRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TutorialProgressRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class TutorialProgressRepository(PostgresContext postgresContext)
    : RepositoryAsync<TutorialProgress, int>(postgresContext), ITutorialProgressRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\TutorialsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class TutorialsRepository : RepositoryAsync<Tutorials, int>, ITutorialsRepository
    {
        // Contexto para conectar a la base de datos
        private readonly PostgresContext _postgresContext;

        public TutorialsRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        /// <summary>
        /// Obtiene todos los tutoriales
        /// </summary>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetAllTutorials()
        {
            var tutorials = await _postgresContext.Tutorials.ToListAsync();

            return tutorials;
        }

        /// <summary>
        /// Obtiene los tutoriales activos
        /// </summary>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorials()
        {
            var tutorials = await _postgresContext.Tutorials.Where(t => t.IsActive).ToListAsync();

            return tutorials;
        }

        /// <summary>
        /// Obtiene todos los tutoriales filtrados por categoría
        /// </summary>
        /// <param name="tutorialCategory"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetTutorialsByCategory(TutorialCategory tutorialCategory)
        {
            var tutorials = await _postgresContext.Tutorials.Where(t => t.Category.Equals(tutorialCategory)).ToListAsync();

            return tutorials;
        }

        /// <summary>
        /// Obtiene los tutoriales activos filtrados por categoría
        /// </summary>
        /// <param name="tutorialCategory"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorialsByCategory(TutorialCategory tutorialCategory)
        {
            var tutorials = await _postgresContext.Tutorials.Where(t => t.Category.Equals(tutorialCategory) && t.IsActive).ToListAsync();

            return tutorials;
        }

        /// <summary>
        /// Obtiene los tutoriales por banco
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorialsByBank(CountryEnum bankId)
        {
            var tutorials = await _postgresContext.Tutorials.Where(t => t.IsActive && t.TutorialBankId.Equals(bankId.ToString())).ToListAsync();

            return tutorials;
        }

        /// <summary>
        /// Obtiene los tutoriales por banco y categoría
        /// </summary>
        /// <param name="category"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public async Task<List<Tutorials>> GetActiveTutorialsByBankAndCategory(CountryEnum bankId, TutorialCategory category)
        {
            var tutorials = await _postgresContext.Tutorials.Where(t => t.IsActive && t.TutorialBankId.Equals(bankId.ToString()) && t.Category.Equals(category)).ToListAsync();

            return tutorials;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UiGroupRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UiGroupRepository(PostgresContext postgresContext)
    : RepositoryAsync<UiGroup, int>(postgresContext), IUiGroupRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserConditionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserConditionRepository(PostgresContext postgresContext) : RepositoryAsync<UserCondition, int>(postgresContext), IUserConditionRepository
    {
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserFailedAttemptRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserFailedAttemptRepository(PostgresContext postgresContext)
    : RepositoryAsync<UserFailedAttempt, int>(postgresContext), IUserFailedAttemptRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserFavoriteFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserFavoriteFunctionalityRepository : RepositoryAsync<UserFavoriteFunctionality, int>, IUserFavoriteFunctionalityRepository
{
    private readonly PostgresContext postgresContext;

    public UserFavoriteFunctionalityRepository(PostgresContext postgresContext) : base(postgresContext)
    {
        this.postgresContext = postgresContext;
    }

    public async Task<List<UserFavoriteFunctionality>?> GetAllUserFavoriteFunctionalityByUserId(Guid userId)
    {
        var userff = await postgresContext.UserFavoriteFunctionalities.Where(ff => ff.UserId == userId).ToListAsync();

        return userff;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserFeatureStateRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserFeatureStateRepository : RepositoryAsync<UserFeatureState, int>, IUserFeatureStateRepository
    {
        private readonly PostgresContext _postgresContext;
        public UserFeatureStateRepository(PostgresContext postgresContext) : base(postgresContext) => _postgresContext = postgresContext;

        public async Task<List<UserFeatureState>> GetUserFeatureStateByCategoryAndReferenceKey(Guid profileId, UserFeatureCategory category, string? referenceKey)
        {
            var userFeatureStates = await _postgresContext.UserFeatureStates.Where(ufs => ufs.UserProfileId == profileId && ufs.Category == category && ufs.ReferenceKey == referenceKey).ToListAsync();
            return userFeatureStates;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserFunctionalityRepository : RepositoryAsync<UserFunctionality, int>, IUserFunctionalityRepository
    {
        private readonly PostgresContext _postgresContext;

        public UserFunctionalityRepository(PostgresContext postgresContext) : base(postgresContext)
        {
            _postgresContext = postgresContext;
        }

        /// <summary>
        /// Se obtienen todas las funcionalidades del usuario
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        public async Task<List<UserFunctionality>> GetAllUserFunctionalitiesByUserProfileId(Guid? userProfileId)
        {
            var userFunctionality = await _postgresContext.UserFunctionalities.Where(uf => uf.ProfileId == userProfileId).ToListAsync();

            return userFunctionality;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserOptionItemRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserOptionItemRepository(PostgresContext postgresContext) : RepositoryAsync<UserOptionItem, Guid>(postgresContext),
        IUserOptionItemRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;

        public async Task<List<UserOptionItem>?> GetAllUserOptionItemsByUserProfileId(Guid userProfileId)
        {
            var OptionItems = await _postgresContext.UserOptionItems
                .Include(uoi => uoi.OptionItem)
                .Include(uoi => uoi.OptionItem.UiGroup)
                .Where(uoi => uoi.UserProfileId == userProfileId).ToListAsync();

            return OptionItems;
        }

        public async Task InsertUserOptionItems(List<UserOptionItem> userOptionItems)
        {
            await _postgresContext.UserOptionItems.AddRangeAsync(userOptionItems);
            await _postgresContext.SaveChangesAsync(default);
        }

        public async Task UpdateUserOptionItems(List<UserOptionItem> userOptionItems)
        {
            _postgresContext.UserOptionItems.UpdateRange(userOptionItems);
            await _postgresContext.SaveChangesAsync(default);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserProductRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserProductRepository : RepositoryAsync<UserProduct, Guid>, IUserProductRepository
    {
        private readonly PostgresContext _postgresContext;

        public UserProductRepository(PostgresContext postgresContext) : base(postgresContext: postgresContext) => this._postgresContext = postgresContext;

        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile
        /// </summary>
        /// <param name="userProfile">Perfil del usuario</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        public async Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfile(Guid userProfileId) =>
            await _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.IsActive)
                .Include(p => p.UserSubProducts
                    .Where(sp => sp.IsActive))
                .ToListAsync();

        /// <summary>
        /// Obtiene todos los productos y subproductos (activos o no)
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        public async Task<List<UserProduct>?> GetAllUserProductsAndSubProductsByUserProfileId(Guid userProfileId) =>
            await _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId)
                .Include(p => p.UserSubProducts)
                .ToListAsync();

        /// <summary>
        /// Elimina los subproductos y el producto en base al producto
        /// </summary>
        /// <param name="product"></param>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        public async Task DeleteAllSubProductsByProduct(UserProduct product)
        {
            var subProducts = await _postgresContext.UserSubProducts.Where(sp => sp.ProductId == product.Id).ToListAsync();

            if (subProducts != null && subProducts.Count != 0)
                _postgresContext.UserSubProducts.RemoveRange(subProducts);

            _postgresContext.UserProducts.Remove(product);
        }

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        public async Task<UserProduct?> GetProductByAccountNumber(string accountNumber)
        {
            var result = await _postgresContext.UserProducts
                .Include(up => up.UserProfile)
                .ThenInclude(profile => profile.User)
                .ThenInclude(u => u.Devices)
                .FirstOrDefaultAsync(usp => usp.ProductNumber.Equals(accountNumber));

            return result;
        }

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta junto a la información del perfil y usuario
        /// </summary>
        /// <param name="accountNumber">The account or sub-product number to search for.</param>
        /// <returns>The UserProduct entity with loaded navigation properties, or null if not found.</returns>
        public async Task<UserProduct?> GetUserProductByAccountNumber(string accountNumber)
        {
            // Buscar el UserProduct a través de SubProductNumber
            var userProductFromSubProduct = await _postgresContext.UserSubProducts
                .Include(x => x.UserProduct)
                    .ThenInclude(x => x.UserProfile)
                        .ThenInclude(x => x.User)
                .Where(x => x.SubProductNumber == accountNumber)
                .Select(x => x.UserProduct)
                .FirstOrDefaultAsync();

            if (userProductFromSubProduct != null)
            {
                return userProductFromSubProduct;
            }

            // Buscar el UserProduct a través de ProductNumber
            var userProductFromProduct = await _postgresContext.UserProducts
                .Include(x => x.UserProfile)
                    .ThenInclude(x => x.User)
                .Where(x => x.ProductNumber == accountNumber)
                .FirstOrDefaultAsync();

            return userProductFromProduct;
        }

        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile y tipos de productos específicos
        /// </summary>
        /// <param name="userProfileId">Perfil del usuario</param>
        /// <param name="productTypes">Tipos de productos por filtrar</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        public async Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfileIdAndProductTypes(Guid userProfileId, params ProductType[] productTypes)
        {
            IQueryable<UserProduct> query = _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.IsActive);

            if (productTypes.Length > 0)
                query = query.Where(p => productTypes.Contains(p.ProductType));

            return await query
                .Include(p => p.UserSubProducts.Where(sp => sp.IsActive))
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene un producto de usuario filtrando por el ProfileId y el número de producto
        /// </summary>
        /// <param name="userProfileId">Id del perfil del usuario</param>
        /// <param name="productNumber">Número del producto</param>
        /// <param name="productType">Tipo de producto</param>
        /// <returns>Retorna un producto o nulo si no existe</returns>
        public async Task<UserProduct?> GetUserProductByProfileIdProductNumberAndProductType(Guid userProfileId, string productNumber, ProductType productType)
        {
            IQueryable<UserProduct> query = _postgresContext.UserProducts
                .Where(p => p.ProfileId == userProfileId && p.ProductNumber == productNumber && p.IsActive && p.ProductType == productType);

            return await query.FirstOrDefaultAsync();
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserProfileRepository.cs
```csharp
using DXP.Core.Application.Common.Utils;
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Domain.Enums;
using LAFISE.CrossCutting.Caching.Core.Interfaces;
using LAFISE.CrossCutting.Core.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserProfileRepository : RepositoryAsync<UserProfile, Guid>, IProfileRepository
{
    private readonly PostgresContext _postgresContext;
    private readonly ICacheService _cacheService;

    public UserProfileRepository(PostgresContext postgresContext, ICacheService cacheService)
        : base(postgresContext)
    {
        _postgresContext = postgresContext;
        _cacheService = cacheService;
    }

    /// <summary>
    /// Obtiene una lista de perfiles junto con la información del usuario filtrada por tipo de documento, número de documento y ID de banco.
    /// </summary>
    /// <param name="documentType">El tipo de documento para buscar.</param>
    /// <param name="documentNumber">El número de documento para buscar.</param>
    /// <param name="bankId">El ID del banco para buscar.</param>
    /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
    public async Task<UserProfile?> GetProfileByDocumentAsync(
        string documentType,
        string documentNumber,
        string bankId
    ) =>
        await _postgresContext
            .UserProfiles.Include(p => p.User)
            .SingleOrDefaultAsync(p =>
                p.DocumentType.Equals(documentType.ToUpper())
                && p.DocumentNumber.Equals(documentNumber.ToUpper())
                && p.BankID == bankId
                && p.IsActive
            );

    /// <summary>
    /// Obtiene una lista de perfiles junto con la información del usuario filtrada por CIF y ID de banco.
    /// </summary>
    /// <param name="cif">El CIF para buscar.</param>
    /// <param name="bankId">El ID del banco para buscar.</param>
    /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
    public async Task<UserProfile?> GetProfileByCifAsync(string cif, string bankId) =>
        await _postgresContext
            .UserProfiles.Include(p => p.User)
            .FirstOrDefaultAsync(p => p.CIF == cif && p.BankID == bankId && p.IsActive);

    /// <summary>
    /// Obtiene una lista de perfiles junto con la información del usuario filtrada por email.
    /// </summary>
    /// <param name="email">El email para buscar.</param>
    /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
    public async Task<List<UserProfile>> GetProfilesByEmailAsync(string email, string bankId) =>
        await _postgresContext
            .UserProfiles.Include(p => p.User)
            .Where(p =>
                p.Email != null
                && p.Email.ToLower().Equals(email.ToLower())
                && p.BankID == bankId
                && p.IsActive
            )
            .ToListAsync();

    /// <summary>
    /// Obtiene una lista de perfiles junto con la información del usuario filtrada por UserId y BankID.
    /// </summary>
    /// <param name="userId">El ID del usuario para buscar.</param>
    /// <param name="bankId">El ID del banco para buscar.</param>
    /// <returns>Un perfil junto con la información del usuario o null si no se encuentra ninguno.</returns>
    public async Task<UserProfile?> GetProfileByUserIdAndBankIdAsync(Guid userId, string bankId) =>
        await _postgresContext
            .UserProfiles.Include(p => p.User)
            .SingleOrDefaultAsync(p => p.UserId == userId && p.BankID == bankId && p.IsActive);

    /// <summary>
    /// Elimina de manera lógica al perfil del usuario
    /// </summary>
    /// <param name="userId">El ID del usuario para buscar.</param>
    /// <param name="bankId">El ID del banco para buscar.</param>
    public Task DeleteProfileAsync(UserProfile profile)
    {
        profile.IsActive = false;
        profile.DeletedAt = DateTime.UtcNow;

        profile.DocumentType = "";
        profile.DocumentNumber = "";
        profile.CountryCode = null;
        profile.PhoneNumber = null;
        profile.Email = null;
        profile.PhonePrefix = null;

        _postgresContext.UserProfiles.Update(profile);
        return Task.CompletedTask;
    }

    public async Task<UserProfile?> GetCachedProfilesByUserIdAndBankIdAsync(
        Guid userId,
        string bankId
    ) =>
        await _cacheService.GetOrCreateAsync(
            CacheKeyBuilder.BuildCacheKey(
                CacheDomain.DigitalExperience,
                Enum.TryParse(bankId, out CountryEnum bankInEnum) ? bankInEnum : CountryEnum.BLNI,
                CacheGroup.UserProfile,
                userId.ToString()
            ),
            TimeSpan.FromMinutes(5),
            async () =>
            {
                return await _postgresContext
                    .UserProfiles.AsNoTracking()
                    .Include(x => x.User)
                    .FirstOrDefaultAsync(up => up.UserId == userId && up.BankID == bankId);
            }
        );
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserQuickActionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserQuickActionRepository(PostgresContext postgresContext) : RepositoryAsync<UserQuickAction, Guid>(postgresContext),
        IUserQuickActionRepository
    {
        private readonly PostgresContext _postgresContext = postgresContext;

        public async Task<List<UserQuickAction>?> GetAllUserQuickActionsByUserProfileId(Guid userProfileId)
        {
            var quickActions = await _postgresContext.UserQuickActions
                .Include(qa => qa.QuickAction)
                .Where(qa => qa.UserProfileId == userProfileId).ToListAsync();

            return quickActions;
        }

        public async Task InsertUserQuickActions(List<UserQuickAction> userQuickActions)
        {
            await _postgresContext.UserQuickActions.AddRangeAsync(userQuickActions);
            await _postgresContext.SaveChangesAsync(default);
        }

        public async Task UpdateUserQuickActions(List<UserQuickAction> userQuickActions)
        {
            _postgresContext.UserQuickActions.UpdateRange(userQuickActions);
            await _postgresContext.SaveChangesAsync(default);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserRepository(PostgresContext postgresContext) : RepositoryAsync<User, Guid>(postgresContext), IUserRepository
{
    private readonly PostgresContext _postgresContext = postgresContext ?? throw new ArgumentNullException(nameof(postgresContext));

    public async Task<User?> GetUserByIdentityProviderId(string identityProviderId) =>
        await _postgresContext.Users.FirstOrDefaultAsync(u => u.Auth0UserId == identityProviderId && u.UserStatus != UserStatus.Deleted);

    /// <summary>
    /// Obtiene un usuario por su id
    /// </summary>
    /// <param name="keyValues"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public override async Task<User?> GetByIdAsync(params object?[]? keyValues)
    {
        if (keyValues == null || keyValues.Length != 1 || keyValues[0] is not Guid userId)
            throw new ArgumentException("Invalid key values");

        return await _postgresContext.Users.FirstOrDefaultAsync(u => u.Id == userId && u.UserStatus != UserStatus.Deleted);
    }

    /// <summary>
    /// Elimina el usuario de forma lógica
    /// </summary>
    /// <param name="user"></param>
    /// <returns></returns>
    public Task DeleteUserAsync(User user)
    {
        user.UserStatus = UserStatus.Deleted;
        user.DeletedAt = DateTime.UtcNow;

        user.Auth0UserId = "auth0|empty";
        user.HasNotificationEnabled = false;
        user.HasAcceptedTerms = false;
        user.IsExistingCustomer = false;
        user.Username = null;
        user.UserFullName = null;
        user.ProfilePictureKey = null;
        user.Sex = null;
        user.Language = null;
        user.LastUserBankId = null;
        user.ShortName = null;
        user.PeopleId = null;
        user.AuthenticationMethod = null;
        user.BirthDate = null;

        _postgresContext.Users.Update(user);

        return Task.CompletedTask;
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserRequestRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserRequestRepository(PostgresContext postgresContext)
    : RepositoryAsync<UserRequest, int>(postgresContext), IUserRequestRepository
{
    private readonly PostgresContext _postgresContext = postgresContext;

    public async Task<List<UserRequest>> GetUserRequestsByUserProfileId(Guid userProfileId) =>
        await _postgresContext.UserRequests
            .Where(x => x.UserProfileId.Equals(userProfileId))
            .AsNoTracking()
            .ToListAsync();
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserSubProductRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserSubProductRepository :
        RepositoryAsync<UserSubProduct, Guid>, IUserSubProductRepository
    {
        private readonly PostgresContext postgresContext;

        public UserSubProductRepository(PostgresContext postgresContext) : base(postgresContext: postgresContext)
        {
            this.postgresContext = postgresContext;
        }

        /// <summary>
        /// Obtiene todos los subproductos por id del producto
        /// </summary>
        /// <param name="productId"></param>
        /// <returns></returns>
        public async Task<List<UserSubProduct>?> GetAllSubProductsByProductId(Guid productId)
        {
            var subProducts = await postgresContext.UserSubProducts.Where(usp => usp.ProductId == productId).ToListAsync();

            return subProducts;
        }

        /// <summary>
        /// Obtiene datos de subproducto filtrando por el número de cuenta
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        public async Task<UserSubProduct?> GetSubProductByAccountNumber(string accountNumber)
        {
            var result = await postgresContext.UserSubProducts
                .Include(usp => usp.UserProduct)
                .ThenInclude(up => up.UserProfile)
                .ThenInclude(profile => profile.User)
                .ThenInclude(u => u.Devices)
                .FirstOrDefaultAsync(usp => usp.SubProductNumber.Equals(accountNumber));

            return result;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserTransactionConditionRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories;

public class UserTransactionConditionRepository(PostgresContext postgresContext)
    : RepositoryAsync<UserTransactionCondition, int>(postgresContext), IUserTransactionConditionRepository;

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Repositories\UserTutorialsRepository.cs
```csharp
using DXP.Core.Database.Application.Common.Interfaces.Repositories;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace DXP.Core.Database.Infrastructure.Persistence.Repositories
{
    public class UserTutorialsRepository : RepositoryAsync<UserTutorials, int>, IUserTutorialsRepository
    {
        private readonly PostgresContext context;

        public UserTutorialsRepository(PostgresContext _context) : base(_context)
        {
            context = _context;
        }

        /// <summary>
        /// Agrega un tutorial por cada vez que al usuario le aparezca uno para que luego no le vuelva a aparecer
        /// </summary>
        /// <param name="userTutorial"></param>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        public async Task<List<UserTutorials>> AddUserTutorial(UserTutorials userTutorial)
        {
            await context.UserTutorials.AddAsync(userTutorial);
            await context.SaveChangesAsync();

            return await context.UserTutorials
                .Where(ut => ut.UserId == userTutorial.UserId)
                .ToListAsync();
        }

        /// <summary>
        /// Obtiene los tutoriales que abrió el usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<List<UserTutorials>> GetUserTutorialsByUserId(Guid userId)
        {
            var userTutorials = await context.UserTutorials.Where(ut => ut.UserId == userId).ToListAsync();

            return userTutorials;
        }
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAccountTypeRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAccountTypeRepository : IReadRepositoryAsync<AccountType, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAdvertisingDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAdvertisingDetailRepository : IReadRepositoryAsync<AdvertisingDetail, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAdvertisingRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAdvertisingRepository : IReadRepositoryAsync<Advertising, int>
    {
        /// <summary>
        /// Obtiene todas las publicidades activas
        /// </summary>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisings();

        /// <summary>
        /// Obtiene todas las publicidades de un tipo específico
        /// </summary>
        /// <param name="advertisingType"></param>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisingsByType(AdvertisingType advertisingType);

        /// <summary>
        /// Obtiene todas las publicidades según el tipo de redirección
        /// </summary>
        /// <param name="redirectTo"></param>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisingsByRedirectType(RedirectTo redirectTo);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAppResourceRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAppResourceRepository : IReadRepositoryAsync<AppResource, int>
    {
        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceType(ResourceType resourceType);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <param name="bankId">Identificador del banco.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceTypeAndBankId(ResourceType resourceType, string bankId);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <param name="BankId">Identificador del banco.</param>
        /// <param name="productType">Tipo de producto</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceTypeWithBankIdAndProductType(ResourceType resourceType, string bankId, ProductType productType);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso</param>
        /// <param name="BankId">Identificador del banco.</param>
        /// <param name="productType">Tipo de producto</param>
        /// <param name="subProduct">Tipo de producto.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByProductTypeAndSubProductAsync(ResourceType resourceType, string bankId, ProductType productType, string subProduct);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAppScreenRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAppScreenRepository : IReadRepositoryAsync<AppScreen, string>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAppSectionCatalogRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAppSectionCatalogRepository : IReadRepositoryAsync<AppSectionCatalog, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAppVersionDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAppVersionDetailRepository : IReadRepositoryAsync<AppVersionDetail, int>
    {
        /// <summary>
        /// Obtiene una lista con el detalle de una versión
        /// </summary>
        /// <param name="appVersion"></param>
        /// <returns></returns>
        Task<List<AppVersionDetail>> GetAppVersionDetailByAppVersion(string? appVersion);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROAppVersionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROAppVersionRepository : IReadRepositoryAsync<AppVersion, string>
    {
        /// <summary>
        /// Se obtienen los detalles de la última versión de la app
        /// </summary>
        /// <returns></returns>
        Task<AppVersion?> GetLastAppVersion();

        /// <summary>
        /// Obtiene una versión específica junto con sus detalles
        /// </summary>
        /// <param name="versionId"></param>
        /// <returns></returns>
        Task<AppVersion?> GetAppVersionById(string versionId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROBankRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROBankRepository : IReadRepositoryAsync<Bank, string>
    {
        /// <summary>
        /// Get the information of the onboarding by the identification
        /// </summary>
        /// <param name="identification"></param>
        /// <returns></returns>
        Task<List<Bank?>> GetAvailableBanks();
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROBiometricAccountRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROBiometricAccountRepository : IReadRepositoryAsync<BiometricAccount, int>
    {
        /// <summary>
        /// Obtiene el usuario con sus cuentas de biometría
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<User?> GetUserBiometricAccountsByUserId(Guid userId);

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<BiometricAccount>?> GetBiometricAccountListByUserId(Guid userId);

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario (todas las activas e inactivas)
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<BiometricAccount>?> GetAllBiometricAccountListByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROCountryBankProductTypeConfigRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROCountryBankProductTypeConfigRepository : IReadRepositoryAsync<CountryBankProductTypeConfig, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROCountryBankRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROCountryBankRepository : IReadRepositoryAsync<CountryBank, int>
    {
        /// <summary>
        /// Obtener Country Bank por medio de codigo swift
        /// </summary>
        /// <param name="swiftCode">Swift Code</param>
        /// <returns></returns>
        Task<CountryBank?> GetCountryBankBySwiftCode(string swiftCode);

        /// <summary>
        /// Obtiene los bancos disponibles según el país
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task<List<CountryBank>?> GetActiveCountryBanksByBankId(CountryEnum bankId);

        /// <summary>
        /// Obtener banco disponible por CountryId y External Reference
        /// </summary>
        /// <param name="bankId">BankId</param>
        /// <param name="externalReference">ExternalReference</param>
        /// <returns></returns>
        Task<CountryBank?> GetCountryBankByExternalReferenceAndBankId(CountryEnum bankId, string externalReference);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRODeviceRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRODeviceRepository : IReadRepositoryAsync<Device, int>
    {
        /// <summary>
        /// Obtiene los dispositivos por ID de usuario.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar los dispositivos.</param>
        /// <returns>Una lista de dispositivos asociados con el ID de usuario especificado.</returns>
        Task<List<Device>> GetDevicesByUserIdAsync(Guid userId);

        /// <summary>
        /// Obtiene un dispositivo por el id unico del dispositivo y el usuario
        /// </summary>
        /// <param name="userId">El ID del usuario.</param>
        /// <param name="uniqueDeviceId">Id unico del dispositivo</param>
        /// <returns>El dispositivo.</returns>
        Task<Device?> GetDeviceByUniqueDeviceId(string uniqueDeviceId, Guid userId);

        /// <summary>
        /// Obtiene los dispositivos activos por ID de usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<Device>> GetActiveDevicesByUserIdAsync(Guid userId);

        /// <summary>
        /// Obtiene un dispositivo por ID de usuario y ID de dispositivo.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar el dispositivo.</param>
        /// <param name="deviceId">El ID del dispositivo a buscar.</param>
        /// <returns>El dispositivo correspondiente al ID del usuario y al ID del dispositivo, o null si no se encuentra.</returns>
        Task<Device?> GetDeviceByIdAsync(Guid userId, int deviceId);

        /// <summary>
        /// Obtiene los dispositivos (activos o inactivos) por ID de usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<Device>?> GetAllDevicesByUserIdAsync(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFailedOpportunityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFailedOpportunityRepository : IReadRepositoryAsync<FailedOpportunity, int>
    {
        /// <summary>
        /// Retrieves failed opportunities that are pending retry, 
        /// prioritizing those with the fewest retry attempts.
        /// </summary>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public Task<List<FailedOpportunity>> GetPendingOpportunitiesAsync(CancellationToken cancellationToken);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFavoritesRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFavoritesRepository : IReadRepositoryAsync<FavoriteGroup, int>
    {
        /// <summary>
        /// Busca grupos y transacciones favoritas activas por el ID del usuario.
        /// </summary>
        public Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserIdAsync(Guid userId, string bankid);

        /// <summary>
        /// Busca grupos y servicios favoritos activos por el ID del usuario.
        /// </summary>
        public Task<List<FavoriteGroup>> GetActiveGroupsAndServicesByUserIdAsync(Guid userId, string bankid);

        /// <summary>
        /// Retorna una lista con todas las transacciones favoritas por el id del grupo.
        /// </summary>
        public Task<List<FavoriteTransaction>> GetFavoriteTransactionsByActiveGroupIdAsync(int favoriteTransactionGroupId);

        /// <summary>
        /// Metodo para obtener los activos Grupos Favoritos por el Usuario Destino
        /// </summary>
        /// <param name="userDestinationId">Id del Usuario Destino</param>
        /// <returns></returns>
        public Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserDestinationIdAsync(Guid userDestinationId);

        /// <summary>
        /// Obtiene una lista de los servicios favoritos a través del id del grupo.
        /// </summary>
        public Task<List<FavoriteService>> GetFavoriteServicesByActiveGroupIdAsync(int favoriteServiceGroupId);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        public Task<List<FavoriteGroup>?> GetAllGroupsByUserProfileIdAsync(Guid userProfileId);

        /// <summary>
        /// Obtiene todas las transacciones favoritas de un usuario por medio de un numero de cuenta
        /// </summary>
        /// <param name="userId">Id del Usuario</param>
        /// <param name="accountNumber">Numero de Cuenta</param>
        /// <returns></returns>
        public Task<List<FavoriteGroup>> GetAllFavoritesTransactionGroupsByAccountNumber(Guid profileId, string bankId, string accountNumber);

        /// <summary>
        /// Obtiene los servicios favoritos por el id de servicio y categoría
        /// </summary>
        /// <param name="profileId"></param>
        /// <param name="serviceId"></param>
        /// <param name="categoryId"></param>
        /// <returns></returns>
        public Task<List<FavoriteGroup>> GetAllFavoritesServiceGroupsByServiceAndCategoryId(Guid profileId, string serviceId, string categoryId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFrequentlyQuestionsDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFrequentlyQuestionsDetailRepository : IReadRepositoryAsync<FrequentlyQuestionsDetail, int>
    {
        /// <summary>
        /// Obtiene las preguntas por contexto específico
        /// </summary>
        /// <param name="frequentlyQuestionId"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestionsDetail>> GetDetailByFrequentlyQuestionId(int frequentlyQuestionId);

        /// <summary>
        /// Obtiene las preguntas por contexto específico y lenguaje
        /// </summary>
        /// <param name="frequentlyQuestionId"></param>
        /// <param name="language"></param>
        /// <returns></returns>
        public Task<FrequentlyQuestionsDetail> GetDetailByFrequentlyQuestionIdAndLanguage(int frequentlyQuestionId, string language);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFrequentlyQuestionsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFrequentlyQuestionsRepository : IReadRepositoryAsync<FrequentlyQuestions, int>
    {
        /// <summary>
        /// Todas las preguntas frecuentes activas
        /// </summary>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestions();

        /// <summary>
        /// Todas las preguntas frecuentes activas por país
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankId(CountryEnum bankId);

        /// <summary>
        /// Todas las preguntas frecuentes activas por país y lenguaje
        /// </summary>
        /// <param name="bankId"></param>
        /// <param name="language"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankIdAndLanguage(CountryEnum bankId, string language);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFunctionalityRepository : IReadRepositoryAsync<Functionality, int>
    {
        /// <summary>
        /// Obtiene todas las funcionalidades activas asociadas con un ID de usuario y un banco.
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="bank"></param>
        /// <returns></returns>
        public Task<List<Functionality>> GetActiveFunctionalitiesByUserIdAndBankAsync(Guid userId, string bank);

        /// <summary>
        /// Obtiene todas las funcionalidades activas para un banco específico.
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public Task<List<Functionality>> GetFunctionalitiesByBankAsync(string bankId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFunFactDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFunFactDetailRepository : IReadRepositoryAsync<FunFactDetail, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROFunFactRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROFunFactRepository : IReadRepositoryAsync<FunFact, int>
    {
        /// <summary>
        /// Gets All the FunFact by type and bankid
        /// </summary>
        /// <param name="categoryType"></param>
        /// <param name="screenId"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public Task<List<FunFact>> GetAllFunFactByCategoryScreenAndBankId(CategoryType categoryType, string screenId, CountryEnum bankId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROKycRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROKycRepository : IReadRepositoryAsync<Kyc, int>
    {
        /// <summary>
        /// Obtiene los kycs del usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<Kyc>?> GetAllKycsByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRONotificationConfigRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRONotificationConfigRepository : IReadRepositoryAsync<NotificationConfig, int>
    {
        /// <summary>
        /// Se obtiene el usuario junto a sus configuraciones de las notificaciones
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<User?> GetNotificationConfigsByUserId(Guid userId);

        /// <summary>
        /// Se obtienen las configuraciones de las notificaciones según el usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<NotificationConfig>?> GetAllNotificationConfigsByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRONotificationHistoryRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRONotificationHistoryRepository : IReadRepositoryAsync<NotificationHistory, long>
    {
        /// <summary>
        /// Obtiene las historias de notificaciones según el usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<NotificationHistory>?> GetAllNotificationHistoriesByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRONotificationRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRONotificationRepository : IReadRepositoryAsync<Notification, long>
    {
        /// <summary>
        /// Obtiene todas las notificaciones según el id del usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<Notification>?> GetAllNotificationsByUserId(Guid userId);

        /// <summary>
        /// Obtiene todas las notificaciones según un usuario específico y los últimos días especificados
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<Notification>> GetNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null);

        /// <summary>
        /// Obtiene todas las notificaciones (no leídas) según un usuario específico y los últimos días especificados
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="lastDays"></param>
        /// <param name="limit"></param>
        /// <returns></returns>
        Task<List<Notification>> GetUnreadNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRONotificationTextDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRONotificationTextDetailRepository : IReadRepositoryAsync<NotificationTextsDetail, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IRONotificationTextsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IRONotificationTextsRepository : IReadRepositoryAsync<NotificationTexts, int>
    {
        /// <summary>
        /// Obtiene los textos de notificaciones segun el tipo de transaccion, el status de la transaccion y el lenguaje.
        /// </summary>
        /// <param name="transactionType">tipo de transaccion</param>
        /// <param name="transactionStatus">estatus de la transaccion</param>
        /// <param name="language">lenguaje del texto</param>
        /// <returns></returns>
        Task<List<NotificationTexts>> GetNotificationTextsByStatusAndTransactionType(TransactionType? transactionType, TransactionStatus? transactionStatus, string language, bool isDebitTransfer);

        /// <summary>
        /// Obtiene los textos de notificaciones segun datos específicos (Incluyendo el ExternalId)
        /// </summary>
        /// <param name="transactionType"></param>
        /// <param name="transactionStatus"></param>
        /// <param name="language"></param>
        /// <param name="isDebitTransfer"></param>
        /// <param name="ExternalId"></param>
        /// <returns></returns>
        Task<NotificationTexts?> GetNotificationTextByEspecifiedData(TransactionType? transactionType,
            TransactionStatus? transactionStatus, string language, bool isDebitTransfer, string? externalId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROOnboardingHistoryRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROOnboardingHistoryRepository : IReadRepositoryAsync<OnboardingHistory, Guid>
    {
        /// <summary>
        /// Obtiene el historial de onboarding en base al id del usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<OnboardingHistory>?> GetAllOnboardingHistoriesByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROOnboardingRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROOnboardingRepository
    {
        /// <summary>
        /// Returns the information of one onboarding associated to a document number
        /// </summary>
        /// <param name="documentNumber">The identification number of the customer</param>
        /// <param name="includeHistories">If true, returns the onboarding histories associated to the onboarding</param>
        /// <returns></returns>
        Task<Onboarding?> GetOnboardingByIdentification(string documentNumber, bool includeHistories = false);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROOptionItemRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROOptionItemRepository : IReadRepositoryAsync<OptionItem, Guid>
    {
        /// <summary>
        /// Se obtienen todas las opciones activas del banco
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankId(string bankId);

        /// <summary>
        /// Se obtiene todas las opciones activas, de una categoría, del banco
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankIdAndCategoryId(string bankId, QuickActionCategory category);

        /// <summary>
        /// Se obtiene todas las opciones activas, de una categoría, del banco, que contengan una clave-valor específicos en additional data.
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <param name="jsonkey">Key</param>
        /// <param name="jsonValue">Value</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankIdCategoryIdAndJsonPair(string? bankId, QuickActionCategory? category, string jsonKey, string jsonValue);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROOtpRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROOtpRepository : IReadRepositoryAsync<Otp, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROProfileAddressRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROProfileAddressRepository : IReadRepositoryAsync<ProfileAddress, int>
    {
        /// <summary>
        /// Se obtienen las direcciones del perfil (solo activas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        public Task<List<ProfileAddress>> GetProfileAddressesByProfileId(Guid profileId);

        /// <summary>
        /// Se obtienen todas las direcciones del perfil (ya sea que estén activas o inactivas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        public Task<List<ProfileAddress>> GetAllProfileAddressesByProfileId(Guid profileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROQuickActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROQuickActionRepository : IReadRepositoryAsync<QuickAction, Guid>
    {
        /// <summary>
        /// Get Quick Actions by Bank Id
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <returns></returns>
        Task<List<QuickAction>> GetQuickActionsByBankId(string bankId);

        /// <summary>
        /// Get Quick Actions By Bank Id And Category Id
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <returns></returns>
        Task<List<QuickAction>> GetQuickActionsByBankIdAndCategoryId(string bankId, QuickActionCategory category);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTermsAndConditionsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTermsAndConditionsRepository : IReadRepositoryAsync<TermsAndConditions, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTransactionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTransactionRepository : IReadRepositoryAsync<Transaction, long>
    {
        public Task<List<Transaction>?> GetOneTransactionByTransactionTypeAndProfile(UserProfile userProfile, TransactionType transactionType);
        public Task<List<TransactionType>?> GetTransactionTypeMadeByUserProfile(UserProfile userProfile);
        public Task<Transaction?> GetOneTransactionByRemittanceNumber(string remittanceNumber);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTransferMethodCurrencyRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTransferMethodCurrencyRepository : IReadRepositoryAsync<TransferMethodCurrency, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTransferMethodProductTypeRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTransferMethodProductTypeRepository : IReadRepositoryAsync<TransferMethodProductType, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTransferMethodRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTransferMethodRepository : IReadRepositoryAsync<TransferMethod, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTutorialActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTutorialActionRepository : IReadRepositoryAsync<TutorialAction, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTutorialProgressRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTutorialProgressRepository : IReadRepositoryAsync<TutorialProgress, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROTutorialsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROTutorialsRepository : IReadRepositoryAsync<Tutorials, int>
    {
        /// <summary>
        /// Obtiene los tutoriales por banco
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorialsByBank(CountryEnum bankId);
        /// <summary>
        /// Obtiene los tutoriales por banco y categoría
        /// </summary>
        /// <param name="category"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorialsByBankAndCategory(CountryEnum bankId, TutorialCategory category);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUiGroupRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUiGroupRepository : IReadRepositoryAsync<UiGroup, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserConditionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserConditionRepository : IReadRepositoryAsync<UserCondition, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserFailedAttemptRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserFailedAttemptRepository : IReadRepositoryAsync<UserFailedAttempt, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserFavoriteFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserFavoriteFunctionalityRepository : IReadRepositoryAsync<UserFavoriteFunctionality, int>
    {
        public Task<List<UserFavoriteFunctionality>?> GetAllUserFavoriteFunctionalityByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserFeatureStateRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserFeatureStateRepository : IReadRepositoryAsync<UserFeatureState, int>
    {
        /// <summary>
        /// Gets UserFeatureStates by ProfileId, Category and ReferenceKey using an index
        /// </summary>
        Task<List<UserFeatureState>> GetUserFeatureStateByCategoryAndReferenceKey(
            Guid profileId,
            UserFeatureCategory category,
            string? referenceKey);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserFunctionalityRepository : IReadRepositoryAsync<UserFunctionality, int>
    {
        /// <summary>
        /// Se obtienen todas las funcionalidades del usuario
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        Task<List<UserFunctionality>> GetAllUserFunctionalitiesByUserProfileId(Guid? userProfileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserOptionItemRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserOptionItemRepository : IReadRepositoryAsync<UserOptionItem, Guid>
    {
        /// <summary>
        /// Se obtienen todas las opciones activas para el perfil de usuario.
        /// </summary>
        /// <param name="userProfileId">User Profile ID</param>
        /// <returns></returns>
        Task<List<UserOptionItem>?> GetAllUserOptionItemsByUserProfileId(Guid userProfileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserProductRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserProductRepository : IReadRepositoryAsync<UserProduct, Guid>
    {
        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile
        /// </summary>
        /// <param name="userProfileid">Perfil del usuario</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfile(Guid userProfileId);

        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile (sin importar si está activo o inactivo)
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        Task<List<UserProduct>?> GetAllUserProductsAndSubProductsByUserProfileId(Guid userProfileId);

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta junto a la información del perfil, usuario y dispositivos asociados
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserProduct?> GetProductByAccountNumber(string accountNumber);

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta junto a la información del perfil y usuario 
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserProduct?> GetUserProductByAccountNumber(string accountNumber);

        /// <summary>
        /// Obtiene la lista de productos de usuarios por perfil 
        /// filtrados según los tipos de productos
        /// </summary>
        /// <remarks>Si no se especifica ningún tipo de producto, se retornarán todos los productos del perfil.</remarks>
        /// <param name="userProfileId">Perfil del usuario</param>
        /// <param name="productTypes">Tipos de productos por filtrar</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfileIdAndProductTypes(Guid userProfileId, params ProductType[] productTypes);

        /// <summary>
        /// Obtiene un producto de usuario filtrando por el ProfileId y el número de producto
        /// </summary>
        /// <param name="userProfileId">Id del perfil del usuario</param>
        /// <param name="productNumber">Número del producto</param>
        /// <param name="productType">Tipo de producto</param>
        /// <returns>Retorna un producto o nulo si no existe</returns>
        Task<UserProduct?> GetUserProductByProfileIdProductNumberAndProductType(Guid userProfileId, string productNumber, ProductType productType);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserProfileRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserProfileRepository : IReadRepositoryAsync<UserProfile, Guid>
    {
        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por tipo de documento, número de documento y ID de banco.
        /// </summary>
        /// <param name="documentType">El tipo de documento para buscar.</param>
        /// <param name="documentNumber">El número de documento para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByDocumentAsync(string documentType, string documentNumber, string bankId);

        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por CIF y ID de banco.
        /// </summary>
        /// <param name="cif">El CIF para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByCifAsync(string cif, string bankId);

        /// <summary>
        /// Obtiene un perfil del cliente por user id y banco. Este metodo cachea la respuesta de la consulta
        /// </summary>
        /// <param name="userId">El id del usuario para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Un perfil del usuario por el pais.</returns>
        Task<UserProfile?> GetCachedProfilesByUserIdAndBankIdAsync(Guid userId, string bankId);

        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por email.
        /// </summary>
        /// <param name="email">El email para buscar.</param>
        /// <param name="bankId">El ID del banco a buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<List<UserProfile>> GetProfilesByEmailAsync(string email, string bankId);
        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por UserId y BankID.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByUserIdAndBankIdAsync(Guid userId, string bankId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserQuickActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserQuickActionRepository : IReadRepositoryAsync<UserQuickAction, Guid>
    {
        /// <summary>
        /// Obtiene todos los quickactions del usuario por perfil
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        public Task<List<UserQuickAction>?> GetAllUserQuickActionsByUserProfileId(Guid userProfileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserRepository : IReadRepositoryAsync<User, Guid>
    {
        /// <summary>
        /// Obtiene la información de un usuario en base al id del proveedor de identidad
        /// </summary>
        /// <param name="identityProviderId">El Id del proveedor de identidad</param>
        /// <returns>Un usuario en caso de encontrarlo</returns>
        Task<User?> GetUserByIdentityProviderId(string identityProviderId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserRequestRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserRequestRepository : IReadRepositoryAsync<UserRequest, int>
    {
        /// <summary>
        /// Get User Requests By User Profile Id
        /// </summary>
        /// <param name="userProfileId">User Profile Id</param>
        /// <returns>User Requests By User Profile Id</returns>
        Task<List<UserRequest>> GetUserRequestsByUserProfileId(Guid userProfileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserSubProductRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserSubProductRepository : IReadRepositoryAsync<UserSubProduct, Guid>
    {
        /// <summary>
        /// Obtiene todos los subproductos por id del producto
        /// </summary>
        /// <param name="productId"></param>
        /// <returns></returns>
        Task<List<UserSubProduct>?> GetAllSubProductsByProductId(Guid productId);

        /// <summary>
        /// Devuelve un subproducto filtrando por su número de cuenta, a su vez trayendo datos del producto, perfil, usuario y dispositivos asociados
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserSubProduct?> GetSubProductByAccountNumber(string accountNumber);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserTransactionConditionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserTransactionConditionRepository : IReadRepositoryAsync<UserTransactionCondition, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\ReadonlyRepositories\IROUserTutorialsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.ReadonlyRepositories
{
    public interface IROUserTutorialsRepository : IReadRepositoryAsync<UserTutorials, int>
    {
        /// <summary>
        /// Obtiene los tutoriales que abrió el usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<UserTutorials>> GetUserTutorialsByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAccountTypeRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IAccountTypeRepository : IRepositoryAsync<AccountType, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAdvertisingDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IAdvertisingDetailRepository : IRepositoryAsync<AdvertisingDetail, int>
    {

    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAdvertisingRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IAdvertisingRepository : IRepositoryAsync<Advertising, int>
    {
        /// <summary>
        /// Obtiene todas las publicidades activas
        /// </summary>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisings();

        /// <summary>
        /// Obtiene todas las publicidades de un tipo específico
        /// </summary>
        /// <param name="advertisingType"></param>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisingsByType(AdvertisingType advertisingType);

        /// <summary>
        /// Obtiene todas las publicidades según el tipo de redirección
        /// </summary>
        /// <param name="redirectTo"></param>
        /// <returns></returns>
        public Task<List<Advertising>?> GetAdvertisingsByRedirectType(RedirectTo redirectTo);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAppResourceRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IAppResourceRepository : IRepositoryAsync<AppResource, int>
    {
        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceType(ResourceType resourceType);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <param name="bankId">Identificador del banco.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceTypeAndBankId(ResourceType resourceType, string bankId);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso.</param>
        /// <param name="BankId">Identificador del banco.</param>
        /// <param name="productType">Tipo de producto</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByResourceTypeWithBankIdAndProductType(ResourceType resourceType, string bankId, ProductType productType);

        /// <summary>
        ///  Busca recursos basados en los parámetros proporcionados.
        /// </summary>
        /// <param name="resourceType">Tipo de recurso</param>
        /// <param name="BankId">Identificador del banco.</param>
        /// <param name="productType">Tipo de producto</param>
        /// <param name="subProduct">Tipo de producto.</param>
        /// <returns>Una lista de recursos activos que coinciden con los criterios de búsqueda.</returns>
        Task<AppResource?> SearchResourcesByProductTypeAndSubProductAsync(ResourceType resourceType, string bankId, ProductType productType, string subProduct);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAppScreenRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IAppScreenRepository : IRepositoryAsync<AppScreen, string>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAppSectionCatalogRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IAppSectionCatalogRepository : IRepositoryAsync<AppSectionCatalog, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAppVersionDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IAppVersionDetailRepository : IRepositoryAsync<AppVersionDetail, int>
    {
        /// <summary>
        /// Obtiene una lista con el detalle de una versión
        /// </summary>
        /// <param name="appVersion"></param>
        /// <returns></returns>
        Task<List<AppVersionDetail>> GetAppVersionDetailByAppVersion(string? appVersion);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IAppVersionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IAppVersionRepository : IRepositoryAsync<AppVersion, string>
    {
        /// <summary>
        /// Se obtienen los detalles de la última versión de la app
        /// </summary>
        /// <returns></returns>
        Task<AppVersion?> GetLastAppVersion();

        /// <summary>
        /// Obtiene una versión específica junto con sus detalles
        /// </summary>
        /// <param name="versionId"></param>
        /// <returns></returns>
        Task<AppVersion?> GetAppVersionById(string versionId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IBankRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IBankRepository : IRepositoryAsync<Bank, string>
{
    /// <summary>
    /// Get the information of the onboarding by the identification
    /// </summary>
    /// <param name="identification"></param>
    /// <returns></returns>
    Task<List<Bank?>> GetAvailableBanks();
}


```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IBiometricAccountRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IBiometricAccountRepository : IRepositoryAsync<BiometricAccount, int>
    {
        /// <summary>
        /// Obtiene el usuario con sus cuentas de biometría
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<User?> GetUserBiometricAccountsByUserId(Guid userId);

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<BiometricAccount>?> GetBiometricAccountListByUserId(Guid userId);

        /// <summary>
        /// Obtiene una lista con las cuentas de biometría de un usuario (todas las activas e inactivas)
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<BiometricAccount>?> GetAllBiometricAccountListByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ICountryBankProductTypeConfigRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ICountryBankProductTypeConfigRepository : IRepositoryAsync<CountryBankProductTypeConfig, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ICountryBankRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ICountryBankRepository : IRepositoryAsync<CountryBank, int>
{
    /// <summary>
    /// Obtener Country Bank por medio de codigo swift
    /// </summary>
    /// <param name="swiftCode">Swift Code</param>
    /// <returns></returns>
    Task<CountryBank?> GetCountryBankBySwiftCode(string swiftCode);

    /// <summary>
    /// Obtiene los bancos disponibles según el país
    /// </summary>
    /// <param name="bankId"></param>
    /// <returns></returns>
    Task<List<CountryBank>?> GetActiveCountryBanksByBankId(CountryEnum bankId);

    /// <summary>
    /// Obtener banco disponible por CountryId y External Reference
    /// </summary>
    /// <param name="bankId">BankId</param>
    /// <param name="externalReference">ExternalReference</param>
    /// <returns></returns>
    Task<CountryBank?> GetCountryBankByExternalReferenceAndBankId(CountryEnum bankId, string externalReference);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IDeviceRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IDeviceRepository : IRepositoryAsync<Device, int>
{

    /// <summary>
    /// Obtiene los dispositivos por ID de usuario.
    /// </summary>
    /// <param name="userId">El ID del usuario para buscar los dispositivos.</param>
    /// <returns>Una lista de dispositivos asociados con el ID de usuario especificado.</returns>
    Task<List<Device>> GetDevicesByUserIdAsync(Guid userId);

    /// <summary>
    /// Obtiene un dispositivo por el id unico del dispositivo y el usuario
    /// </summary>
    /// <param name="userId">El ID del usuario.</param>
    /// <param name="uniqueDeviceId">Id unico del dispositivo</param>
    /// <returns>El dispositivo.</returns>
    Task<Device?> GetDeviceByUniqueDeviceId(string uniqueDeviceId, Guid userId);

    /// <summary>
    /// Obtiene los dispositivos activos por ID de usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<Device>> GetActiveDevicesByUserIdAsync(Guid userId);

    /// <summary>
    /// Obtiene un dispositivo por ID de usuario y ID de dispositivo.
    /// </summary>
    /// <param name="userId">El ID del usuario para buscar el dispositivo.</param>
    /// <param name="deviceId">El ID del dispositivo a buscar.</param>
    /// <returns>El dispositivo correspondiente al ID del usuario y al ID del dispositivo, o null si no se encuentra.</returns>
    Task<Device?> GetDeviceByIdAsync(Guid userId, int deviceId);

    /// <summary>
    /// Elimina un dispositivo.
    /// </summary>
    /// <param name="device">El dispositivo a eliminar.</param>
    Task DeleteDeviceAsync(Device device);

    /// <summary>
    /// Agrega un nuevo dispositivo.
    /// </summary>
    /// <param name="device">El dispositivo a agregar.</param>
    Task InsertUserDeviceAsync(Device device);

    /// <summary>
    /// Actualiza el token (de firebase) de una lista de dispositivos de un usuario
    /// </summary>
    /// <param name="userId">El id del usuario.</param>
    /// <param name="token">El token del dispositivo.</param>
    Task UpdateUserDevicesToken(Guid userId, string token);

    /// <summary>
    /// Actualiza un dispositivo y limpia cache
    /// </summary>
    /// <param name="device">El dispositivo a actualizar.</param>
    Task UpdateUserDevice(Device device);

    /// <summary>
    /// Obtiene los dispositivos (activos o inactivos) por ID de usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<Device>?> GetAllDevicesByUserIdAsync(Guid userId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFailedOpportunityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFailedOpportunityRepository : IRepositoryAsync<FailedOpportunity, int>
    {
        Task<List<FailedOpportunity>> GetPendingOpportunitiesAsync(CancellationToken cancellationToken);
    }

}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFavoritesRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFavoritesRepository : IRepositoryAsync<FavoriteGroup, int>
    {
        /// <summary>
        /// Busca grupos y transacciones favoritas activas por el ID del usuario.
        /// </summary>
        Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserIdAsync(Guid userId, string bankid);

        /// <summary>
        /// Busca grupos y servicios favoritos activos por el ID del usuario.
        /// </summary>
        Task<List<FavoriteGroup>> GetActiveGroupsAndServicesByUserIdAsync(Guid userId, string bankid);

        /// <summary>
        /// Retorna una lista con todas las transacciones favoritas por el id del grupo.
        /// </summary>
        Task<List<FavoriteTransaction>> GetFavoriteTransactionsByActiveGroupIdAsync(int favoriteTransactionGroupId);

        /// <summary>
        /// Metodo para obtener los activos Grupos Favoritos por el Usuario Destino
        /// </summary>
        /// <param name="userDestinationId">Id del Usuario Destino</param>
        /// <returns></returns>
        Task<List<FavoriteGroup>> GetActiveGroupsAndTransactionsByUserDestinationIdAsync(Guid userDestinationId);

        /// <summary>
        /// Obtiene una lista de los servicios favoritos a través del id del grupo.
        /// </summary>
        Task<List<FavoriteService>> GetFavoriteServicesByActiveGroupIdAsync(int favoriteServiceGroupId);

        /// <summary>
        /// Crea un nuevo grupo y una transacción favorita en una transacción.
        /// </summary>
        Task<FavoriteGroup?> CreateGroupAndTransactionAsync(FavoriteGroup group);

        /// <summary>
        /// Crea un nuevo grupo y un servicio favorito en una transacción.
        /// </summary>
        Task<FavoriteGroup?> CreateGroupAndServiceAsync(FavoriteGroup group);

        /// <summary>
        /// Permite agregar una nueva transacción a un grupo.
        /// </summary>
        Task<FavoriteGroup?> AddTransactionToGroupAsync(int groupId, FavoriteTransaction transaction);

        /// <summary>
        /// Permite agregar un nuevo servicio a un grupo.
        /// </summary>
        Task<FavoriteGroup?> AddServiceToGroupAsync(int groupId, FavoriteService service);

        /// <summary>
        /// Permite modificar un grupo activo.
        /// </summary>
        Task<FavoriteGroup?> UpdateActiveGroupAsync(FavoriteGroup group);

        /// <summary>
        /// Permite modificar una transacción activa de un grupo.
        /// </summary>
        Task<FavoriteTransaction?> UpdateActiveTransactionAsync(int groupId, long transactionId, FavoriteTransaction updatedTransaction);

        /// <summary>
        /// Permite modificar un servicio activo de un grupo.
        /// </summary>
        Task<FavoriteService?> UpdateActiveServiceAsync(int groupId, int serviceId, FavoriteService updatedService);

        /// <summary>
        /// Permite remover una transacción activa de un grupo.
        /// </summary>
        Task<FavoriteGroup?> RemoveTransactionFromGroupAsync(int groupId, long transactionId);

        /// <summary>
        /// Permite remover un servicio activo de un grupo.
        /// </summary>
        Task<FavoriteGroup?> RemoveServiceFromGroupAsync(int groupId, int serviceId);

        /// <summary>
        /// Elimina el grupo y las transacciones asociadas a él.
        /// </summary>
        Task DeleteGroupWithTransactionsAsync(int groupId);

        /// <summary>
        /// Elimina el grupo y los servicios asociados a él.
        /// </summary>
        Task DeleteGroupWithServicesAsync(int groupId);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        Task<List<FavoriteGroup>?> GetAllGroupsByUserProfileIdAsync(Guid userProfileId);

        /// <summary>
        /// Elimina físicamente los grupos y transacciones favoritos en base al id del grupo
        /// </summary>
        /// <param name="groupId"></param>
        /// <returns></returns>
        Task DeleteAllTransactionsAndServicesByGroupId(int groupId);

        /// <summary>
        /// Obtiene todas las transacciones favoritas de un usuario por medio de un numero de cuenta
        /// </summary>
        /// <param name="userId">Id del Usuario</param>
        /// <param name="accountNumber">Numero de Cuenta</param>
        /// <returns></returns>
        Task<List<FavoriteGroup>> GetAllFavoritesTransactionGroupsByAccountNumber(Guid profileId, string bankId, string accountNumber);

        /// <summary>
        /// Obtiene los servicios favoritos por el id de servicio y categoría
        /// </summary>
        /// <param name="profileId"></param>
        /// <param name="serviceId"></param>
        /// <param name="categoryId"></param>
        /// <returns></returns>
        Task<List<FavoriteGroup>> GetAllFavoritesServiceGroupsByServiceAndCategoryId(Guid profileId, string serviceId, string categoryId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFrequentlyQuestionsDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFrequentlyQuestionsDetailRepository : IRepositoryAsync<FrequentlyQuestionsDetail, int>
    {
        /// <summary>
        /// Obtiene las preguntas por contexto específico
        /// </summary>
        /// <param name="frequentlyQuestionId"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestionsDetail>> GetDetailByFrequentlyQuestionId(int frequentlyQuestionId);

        /// <summary>
        /// Obtiene las preguntas por contexto específico y lenguaje
        /// </summary>
        /// <param name="frequentlyQuestionId"></param>
        /// <param name="language"></param>
        /// <returns></returns>
        public Task<FrequentlyQuestionsDetail> GetDetailByFrequentlyQuestionIdAndLanguage(int frequentlyQuestionId, string language);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFrequentlyQuestionsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFrequentlyQuestionsRepository : IRepositoryAsync<FrequentlyQuestions, int>
    {
        /// <summary>
        /// Todas las preguntas frecuentes activas
        /// </summary>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestions();

        /// <summary>
        /// Todas las preguntas frecuentes activas por país
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankId(CountryEnum bankId);

        /// <summary>
        /// Todas las preguntas frecuentes activas por país y lenguaje
        /// </summary>
        /// <param name="bankId"></param>
        /// <param name="language"></param>
        /// <returns></returns>
        public Task<List<FrequentlyQuestions>>? GetActiveFrequentlyQuestionsByBankIdAndLanguage(CountryEnum bankId, string language);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFunctionalityRepository : IRepositoryAsync<Functionality, int>
    {
        #region Get

        /// <summary>
        /// Obtiene todas las funcionalidades activas asociadas con un ID de usuario y un banco.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar las funcionalidades.</param>
        /// <param name="bank">El banco asociado para buscar las funcionalidades.</param>
        /// <returns>Una lista de funcionalidades activas del usuario para el banco especificado.</returns>
        Task<List<Functionality>> GetActiveFunctionalitiesByUserIdAndBankAsync(Guid userId, string bank);

        /// <summary>
        /// Obtiene todas las funcionalidades activas para un banco específico.
        /// </summary>
        /// <param name="bankId">El ID del banco para buscar las funcionalidades.</param>
        /// <returns>Una lista de funcionalidades activas para el banco especificado.</returns>
        Task<List<Functionality>> GetFunctionalitiesByBankAsync(string bankId);

        #endregion

        #region Add

        /// <summary>
        /// Inserta una lista de funcionalidades en la tabla de UserFunctionality para un usuario y banco especificados.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a asignar al usuario.</param>
        Task AddFunctionalitiesToUserAsync(Guid userId, string bankId, List<int> functionalityIds);

        /// <summary>
        /// Activa una funcionalidad específica y asegura que esté activa en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignará la funcionalidad.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad a activar.</param>
        Task ActivateFunctionalityAsync(Guid userId, string bankId, int functionalityId);

        /// <summary>
        /// Activa la funcionalidad padre y todas sus funcionalidades hijas en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario al que se le asignarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad padre a activar.</param>
        Task ActivateParentFunctionalityAsync(Guid userId, string bankId, int functionalityId);

        /// <summary>
        /// Activa una lista de funcionalidades para un usuario específico en un banco determinado.
        /// Si una funcionalidad ya existe en la base de datos para el usuario, se activa. 
        /// Si no existe, se agrega a la base de datos.
        /// </summary>
        /// <param name="userId">El ID del usuario para el cual se activarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a activar.</param>
        Task ActivateFunctionalitiesForUserAsync(Guid userId, string bankId, List<int> functionalityIds);

        #endregion

        #region Desactive

        /// <summary>
        /// Desactiva un conjunto de funcionalidades para un usuario y banco específicos. 
        /// Si una de las funcionalidades es un padre, se desactivarán automáticamente todas las funcionalidades hijas.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivará las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityIds">Lista de IDs de funcionalidades a desactivar.</param>
        /// <returns>Una tarea que representa la operación asincrónica.</returns>
        Task DeactivateFunctionalitiesForUserAsync(Guid userId, string bankId, List<int> functionalityIds);

        /// <summary>
        /// Desactiva una funcionalidad específica para un usuario y banco, y asegura que esté desactivada en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivará la funcionalidad.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad a desactivar.</param>
        Task DeactivateFunctionalityForUserAsync(Guid userId, string bankId, int functionalityId);

        /// <summary>
        /// Desactiva la funcionalidad padre y todas sus funcionalidades hijas para un usuario y banco específicos, y asegura que estén desactivadas en UserFunctionality.
        /// </summary>
        /// <param name="userId">El ID del usuario para el que se desactivarán las funcionalidades.</param>
        /// <param name="bankId">El ID del banco asociado con el usuario.</param>
        /// <param name="functionalityId">El ID de la funcionalidad padre a desactivar.</param>
        Task DeactivateParentFunctionalityForUserAsync(Guid userId, string bankId, int functionalityId);

        /// <summary>
        /// Desactiva una funcionalidad específica y asegura que esté desactivada en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad a desactivar.</param>
        Task DeactivateFunctionalityAsync(int functionalityId);

        /// <summary>
        /// Desactiva la funcionalidad padre y todas sus funcionalidades hijas, y asegura que estén desactivadas en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad padre a desactivar.</param>
        Task DeactivateParentFunctionalityAsync(int functionalityId);

        #endregion

        #region Delete

        /// <summary>
        /// Elimina una funcionalidad desactivándola y marcándola como eliminada, incluyendo la actualización en UserFunctionality.
        /// </summary>
        /// <param name="functionalityId">El ID de la funcionalidad a eliminar.</param>
        Task DeleteFunctionalityAsync(int functionalityId);

        #endregion
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFunFactDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFunFactDetailRepository : IRepositoryAsync<FunFactDetail, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IFunFactRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IFunFactRepository : IRepositoryAsync<FunFact, int>
    {
        /// <summary>
        /// Retorna todos los Fun Fact por un tipo de categoría (por ejemplo: Insurance, Onboarding...) screenId y BankId
        /// </summary>
        public Task<List<FunFact>> GetAllFunFactByCategoryScreenAndBankId(CategoryType categoryType, string screenId, CountryEnum bankId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IKycRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IKycRepository : IRepositoryAsync<Kyc, int>
{
    /// <summary>
    /// Obtiene los kycs del usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<Kyc>?> GetAllKycsByUserId(Guid userId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\INotificationConfigRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface INotificationConfigRepository : IRepositoryAsync<NotificationConfig, int>
{
    /// <summary>
    /// Se obtiene el usuario junto a sus configuraciones de las notificaciones
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<User?> GetNotificationConfigsByUserId(Guid userId);

    /// <summary>
    /// Se obtienen las configuraciones de las notificaciones según el usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<NotificationConfig>?> GetAllNotificationConfigsByUserId(Guid userId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\INotificationHistoryRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface INotificationHistoryRepository : IRepositoryAsync<NotificationHistory, long>
{
    /// <summary>
    /// Obtiene las historias de notificaciones según el usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<NotificationHistory>?> GetAllNotificationHistoriesByUserId(Guid userId);
}


```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\INotificationRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface INotificationRepository : IRepositoryAsync<Notification, long>
{
    /// <summary>
    /// Obtiene todas las notificaciones según el id del usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<Notification>?> GetAllNotificationsByUserId(Guid userId);

    /// <summary>
    /// Obtiene todas las notificaciones según un usuario específico y los últimos días especificados
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<Notification>> GetNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null);

    /// <summary>
    /// Obtiene todas las notificaciones (no leídas) según un usuario específico y los últimos días especificados
    /// </summary>
    /// <param name="userId"></param>
    /// <param name="lastDays"></param>
    /// <param name="limit"></param>
    /// <returns></returns>
    Task<List<Notification>> GetUnreadNotificationsByUserIdAndLastDays(Guid userId, int lastDays, int? limit = null);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\INotificationTextsDetailRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface INotificationTextsDetailRepository : IRepositoryAsync<NotificationTextsDetail, int>
    {
        /// <summary>
        /// Devuelve una lista con todos los textos de notificaciones según el idioma
        /// </summary>
        /// <param name="language"></param>
        /// <returns></returns>
        Task<List<NotificationTextsDetail>> GetAllNotificationTextsByLanguage(string language);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\INotificationTextsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;
public interface INotificationTextsRepository : IRepositoryAsync<NotificationTexts, int>
{
    /// <summary>
    /// Obtiene los textos de notificaciones segun el tipo de transaccion, el status de la transaccion y el lenguaje.
    /// </summary>
    /// <param name="transactionType">tipo de transaccion</param>
    /// <param name="transactionStatus">estatus de la transaccion</param>
    /// <param name="language">lenguaje del texto</param>
    /// <returns></returns>
    Task<List<NotificationTexts>> GetNotificationTextsByStatusAndTransactionType(TransactionType? transactionType, TransactionStatus? transactionStatus, string language, bool isDebitTransfer);

    /// <summary>
    /// Obtiene los textos de notificaciones segun datos específicos (Incluyendo el ExternalId)
    /// </summary>
    /// <param name="transactionType"></param>
    /// <param name="transactionStatus"></param>
    /// <param name="language"></param>
    /// <param name="isDebitTransfer"></param>
    /// <param name="ExternalId"></param>
    /// <returns></returns>
    Task<NotificationTexts?> GetNotificationTextByEspecifiedData(TransactionType? transactionType,
        TransactionStatus? transactionStatus, string language, bool isDebitTransfer, string? externalId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IOnboardingHistoryRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;
public interface IOnboardingHistoryRepository : IRepositoryAsync<OnboardingHistory, Guid>
{
    /// <summary>
    /// Obtiene el historial de onboarding en base al id del usuario
    /// </summary>
    /// <param name="userId"></param>
    /// <returns></returns>
    Task<List<OnboardingHistory>?> GetAllOnboardingHistoriesByUserId(Guid userId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IOnboardingRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IOnboardingRepository : IRepositoryAsync<Onboarding, Guid>
{
    /// <summary>
    /// Get the information of the onboarding by the identification
    /// </summary>
    /// <param name="identification">The identification</param>
    /// <returns>The onboarding data</returns>
    Task<Onboarding?> GetOnboardingByIdentification(string identification);

    /// <summary>
    /// Get the information of the onboarding by the user id
    /// </summary>
    /// <param name="userId">The User id</param>
    /// <returns>The onboarding data</returns>
    Task<Onboarding?> GetOnboardingByUserId(Guid userId);

    /// <summary>
    /// Get the information of the last onboarding by the identification
    /// </summary>
    /// <param name="identification">The identification</param>
    /// <param name="bankId">bank identification</param>
    /// <returns>The onboarding data</returns>
    Task<Onboarding?> GetLastOnboardingByIdentification(string identification, string bankId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IOptionItemRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using MediatR;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IOptionItemRepository : IRepositoryAsync<OptionItem, Guid>
    {
        /// <summary>
        /// Se obtienen todas las opciones activas del banco
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankId(string bankId);

        /// <summary>
        /// Se obtiene todas las opciones activas, de una categoría, del banco
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankIdAndCategoryId(string bankId, QuickActionCategory category);

        /// <summary>
        /// Se obtiene todas las opciones activas, de una categoría, del banco, que contengan una clave-valor específicos en additional data.
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <param name="jsonkey">Key</param>
        /// <param name="jsonValue">Value</param>
        /// <returns></returns>
        Task<List<OptionItem>> GetOptionItemsByBankIdCategoryIdAndJsonPair(string? bankId, QuickActionCategory? category, string jsonKey, string jsonValue);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IOtpRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IOtpRepository : IRepositoryAsync<Otp, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IProfileAddressRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IProfileAddressRepository : IRepositoryAsync<ProfileAddress, int>
    {
        /// <summary>
        /// Se crea una dirección para el perfil
        /// </summary>
        /// <param name="profileAddress"></param>
        /// <returns></returns>
        Task<ProfileAddress> CreateProfileAddress(ProfileAddress profileAddress);

        /// <summary>
        /// Se obtienen las direcciones del perfil (solo activas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        Task<List<ProfileAddress>> GetProfileAddressesByProfileId(Guid profileId);

        /// <summary>
        /// Se obtienen todas las direcciones del perfil (ya sea que estén activas o inactivas)
        /// </summary>
        /// <param name="profileId"></param>
        /// <returns></returns>
        Task<List<ProfileAddress>> GetAllProfileAddressesByProfileId(Guid profileId);

        /// <summary>
        /// Se puede actualizar solamente el alias y la dirección
        /// </summary>
        /// <param name="profileAddress"></param>
        /// <returns></returns>
        Task<ProfileAddress?> UpdateProfileAddress(ProfileAddress profileAddress);

        /// <summary>
        /// Se elimina la dirección de manera lógica
        /// </summary>
        /// <param name="profileAddressId"></param>
        /// <returns></returns>
        Task DeleteProfileAddress(int profileAddressId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IProfileRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IProfileRepository : IRepositoryAsync<UserProfile, Guid>
    {
        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por tipo de documento, número de documento y ID de banco.
        /// </summary>
        /// <param name="documentType">El tipo de documento para buscar.</param>
        /// <param name="documentNumber">El número de documento para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByDocumentAsync(string documentType, string documentNumber, string bankId);

        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por CIF y ID de banco.
        /// </summary>
        /// <param name="cif">El CIF para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByCifAsync(string cif, string bankId);

        /// <summary>
        /// Obtiene un perfil del cliente por user id y banco. Este metodo cachea la respuesta de la consulta
        /// </summary>
        /// <param name="userId">El id del usuario para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Un perfil del usuario por el pais.</returns>
        Task<UserProfile?> GetCachedProfilesByUserIdAndBankIdAsync(Guid userId, string bankId);

        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por email.
        /// </summary>
        /// <param name="email">El email para buscar.</param>
        /// <param name="bankId">El ID del banco a buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<List<UserProfile>> GetProfilesByEmailAsync(string email, string bankId);
        /// <summary>
        /// Obtiene una lista de perfiles junto con la información del usuario filtrada por UserId y BankID.
        /// </summary>
        /// <param name="userId">El ID del usuario para buscar.</param>
        /// <param name="bankId">El ID del banco para buscar.</param>
        /// <returns>Una lista de perfiles junto con la información del usuario.</returns>
        Task<UserProfile?> GetProfileByUserIdAndBankIdAsync(Guid userId, string bankId);

        /// <summary>
        /// Elimina de forma lógica al usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task DeleteProfileAsync(UserProfile profile);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IQuickActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using MediatR;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IQuickActionRepository : IRepositoryAsync<QuickAction, Guid>
    {
        /// <summary>
        /// Get Quick Actions by Bank Id
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <returns></returns>
        Task<List<QuickAction>> GetQuickActionsByBankId(string bankId);

        /// <summary>
        /// Get Quick Actions By Bank Id And Category Id
        /// </summary>
        /// <param name="bankId">Bank Id</param>
        /// <param name="category">Category</param>
        /// <returns></returns>
        Task<List<QuickAction>> GetQuickActionsByBankIdAndCategoryId(string bankId, QuickActionCategory category);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITermsAndConditionsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface ITermsAndConditionsRepository : IRepositoryAsync<TermsAndConditions, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITransactionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITransactionRepository : IRepositoryAsync<Transaction, long>
{
    Task<List<Transaction>?> GetOneTransactionByTransactionTypeAndProfile(UserProfile userProfile, TransactionType transactionType);

    Task<List<TransactionType>?> GetTransactionTypeMadeByUserProfile(UserProfile userProfile);
    Task<Transaction?> GetOneTransactionByRemittanceNumber(string remittanceNumber);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITransferMethodCurrencyRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITransferMethodCurrencyRepository : IRepositoryAsync<TransferMethodCurrency, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITransferMethodProductTypeRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITransferMethodProductTypeRepository : IRepositoryAsync<TransferMethodProductType, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITransferMethodRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITransferMethodRepository : IRepositoryAsync<TransferMethod, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITutorialActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITutorialActionRepository : IRepositoryAsync<TutorialAction, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITutorialProgressRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface ITutorialProgressRepository : IRepositoryAsync<TutorialProgress, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\ITutorialsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using LAFISE.CrossCutting.Core.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface ITutorialsRepository : IRepositoryAsync<Tutorials, int>
    {
        /// <summary>
        /// Obtiene todos los tutoriales
        /// </summary>
        /// <returns></returns>
        Task<List<Tutorials>> GetAllTutorials();

        /// <summary>
        /// Obtiene los tutoriales activos
        /// </summary>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorials();

        /// <summary>
        /// Obtiene todos los tutoriales filtrados por categoría
        /// </summary>
        /// <param name="tutorialCategory"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetTutorialsByCategory(TutorialCategory tutorialCategory);

        /// <summary>
        /// Obtiene los tutoriales activos filtrados por categoría
        /// </summary>
        /// <param name="tutorialCategory"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorialsByCategory(TutorialCategory tutorialCategory);

        /// <summary>
        /// Obtiene los tutoriales por banco
        /// </summary>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorialsByBank(CountryEnum bankId);

        /// <summary>
        /// Obtiene los tutoriales por banco y categoría
        /// </summary>
        /// <param name="category"></param>
        /// <param name="bankId"></param>
        /// <returns></returns>
        Task<List<Tutorials>> GetActiveTutorialsByBankAndCategory(CountryEnum bankId, TutorialCategory category);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUiGroupRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUiGroupRepository : IRepositoryAsync<UiGroup, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserConditionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserConditionRepository : IRepositoryAsync<UserCondition, int>
    {
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserFailedAttemptRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUserFailedAttemptRepository : IRepositoryAsync<UserFailedAttempt, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserFavoriteFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUserFavoriteFunctionalityRepository : IRepositoryAsync<UserFavoriteFunctionality, int>
{
    Task<List<UserFavoriteFunctionality>?> GetAllUserFavoriteFunctionalityByUserId(Guid userId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserFeatureStateRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserFeatureStateRepository : IRepositoryAsync<UserFeatureState, int>
    {
        /// <summary>
        /// Gets UserFeatureStates by ProfileId, Category and ReferenceKey using an index
        /// </summary>
        Task<List<UserFeatureState>> GetUserFeatureStateByCategoryAndReferenceKey(
            Guid profileId,
            UserFeatureCategory category,
            string? referenceKey);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserFunctionalityRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserFunctionalityRepository : IRepositoryAsync<UserFunctionality, int>
    {
        /// <summary>
        /// Se obtienen todas las funcionalidades del usuario
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        Task<List<UserFunctionality>> GetAllUserFunctionalitiesByUserProfileId(Guid? userProfileId);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserOptionItemRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserOptionItemRepository : IRepositoryAsync<UserOptionItem, Guid>
    {
        /// <summary>
        /// Se obtienen todas las opciones activas para el perfil de usuario.
        /// </summary>
        /// <param name="userProfileId">User Profile ID</param>
        /// <returns></returns>
        Task<List<UserOptionItem>?> GetAllUserOptionItemsByUserProfileId(Guid userProfileId);

        /// <summary>
        /// Se relaciona una opción con un perfil de usuario.
        /// </summary>
        /// <param name="userOptionItems">User Option Item</param>
        /// <returns></returns>
        Task InsertUserOptionItems(List<UserOptionItem> userOptionItems);

        /// <summary>
        /// Se actualización la relación de una opción con un perfil de usuario.
        /// </summary>
        /// <param name="userOptionItems">User Option Item</param>
        /// <returns></returns>
        Task UpdateUserOptionItems(List<UserOptionItem> userOptionItems);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserProductRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserProductRepository : IRepositoryAsync<UserProduct, Guid>
    {
        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile
        /// </summary>
        /// <param name="userProfileid">Perfil del usuario</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfile(Guid userProfileId);

        /// <summary>
        /// Obtiene la lista de productos de usuarios junto a su subproducto filtrada por el UserProfile (sin importar si está activo o inactivo)
        /// </summary>
        /// <param name="userProfileId"></param>
        /// <returns></returns>
        Task<List<UserProduct>?> GetAllUserProductsAndSubProductsByUserProfileId(Guid userProfileId);

        /// <summary>
        /// Elimina los subproductos y el producto de manera física en base al producto
        /// </summary>
        /// <param name="product"></param>
        /// <returns></returns>
        Task DeleteAllSubProductsByProduct(UserProduct product);

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta junto a la información del perfil, usuario y dispositivos asociados
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserProduct?> GetProductByAccountNumber(string accountNumber);

        /// <summary>
        /// Obtiene datos de producto filtrando por el número de cuenta junto a la información del perfil y usuario 
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserProduct?> GetUserProductByAccountNumber(string accountNumber);

        /// <summary>
        /// Obtiene la lista de productos de usuarios por perfil 
        /// filtrados según los tipos de productos
        /// </summary>
        /// <remarks>Si no se especifica ningún tipo de producto, se retornarán todos los productos del perfil.</remarks>
        /// <param name="userProfileId">Perfil del usuario</param>
        /// <param name="productTypes">Tipos de productos por filtrar</param>
        /// <returns>Retornar lista de productos del usuario</returns>
        Task<List<UserProduct>> GetUserProductsAndSubProductsByUserProfileIdAndProductTypes(Guid userProfileId, params ProductType[] productTypes);

        /// <summary>
        /// Obtiene un producto de usuario filtrando por el ProfileId y el número de producto
        /// </summary>
        /// <param name="userProfileId">Id del perfil del usuario</param>
        /// <param name="productNumber">Número del producto</param>
        /// <param name="productType">Tipo de producto</param>
        /// <returns>Retorna un producto o nulo si no existe</returns>
        Task<UserProduct?> GetUserProductByProfileIdProductNumberAndProductType(Guid userProfileId, string productNumber, ProductType productType);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserQuickActionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserQuickActionRepository : IRepositoryAsync<UserQuickAction, Guid>
    {
        Task<List<UserQuickAction>?> GetAllUserQuickActionsByUserProfileId(Guid userProfileId);
        Task InsertUserQuickActions(List<UserQuickAction> userQuickActions);
        Task UpdateUserQuickActions(List<UserQuickAction> userQuickActions);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUserRepository : IRepositoryAsync<User, Guid>
{
    /// <summary>
    /// Obtiene la información de un usuario en base al id del proveedor de identidad
    /// </summary>
    /// <param name="identityProviderId">El Id del proveedor de identidad</param>
    /// <returns>Un usuario en caso de encontrarlo</returns>
    Task<User?> GetUserByIdentityProviderId(string identityProviderId);

    /// <summary>
    /// Elimina el usuario de forma lógica
    /// </summary>
    /// <param name="user"></param>
    /// <returns></returns>
    Task DeleteUserAsync(User user);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserRequestRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUserRequestRepository : IRepositoryAsync<UserRequest, int>
{
    /// <summary>
    /// Get User Requests By User Profile Id
    /// </summary>
    /// <param name="userProfileId">User Profile Id</param>
    /// <returns>User Requests By User Profile Id</returns>
    Task<List<UserRequest>> GetUserRequestsByUserProfileId(Guid userProfileId);
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserSubProductRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserSubProductRepository : IRepositoryAsync<UserSubProduct, Guid>
    {
        /// <summary>
        /// Obtiene todos los subproductos por id del producto
        /// </summary>
        /// <param name="productId"></param>
        /// <returns></returns>
        Task<List<UserSubProduct>?> GetAllSubProductsByProductId(Guid productId);

        /// <summary>
        /// Devuelve un subproducto filtrando por su número de cuenta, a su vez trayendo datos del producto, perfil, usuario y dispositivos asociados
        /// </summary>
        /// <param name="accountNumber"></param>
        /// <returns></returns>
        Task<UserSubProduct?> GetSubProductByAccountNumber(string accountNumber);
    }
}

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserTransactionConditionRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories;

public interface IUserTransactionConditionRepository : IRepositoryAsync<UserTransactionCondition, int>;

```

### FILE: src\DXP.Core.Database.Application\Common\Interfaces\Repositories\IUserTutorialsRepository.cs
```csharp
using DXP.Core.Database.Domain.Entities;

namespace DXP.Core.Database.Application.Common.Interfaces.Repositories
{
    public interface IUserTutorialsRepository : IRepositoryAsync<UserTutorials, int>
    {
        /// <summary>
        /// Agrega un tutorial por cada vez que al usuario le aparezca uno para que luego no le vuelva a aparecer
        /// </summary>
        /// <param name="userTutorial"></param>
        /// <returns></returns>
        Task<List<UserTutorials>> AddUserTutorial(UserTutorials userTutorial);

        /// <summary>
        /// Obtiene los tutoriales que abrió el usuario
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        Task<List<UserTutorials>> GetUserTutorialsByUserId(Guid userId);
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AccountTypeConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class AccountTypeConfiguration : IEntityTypeConfiguration<AccountType>
{
    public void Configure(EntityTypeBuilder<AccountType> builder)
    {
        builder.HasKey(e => e.Id).HasName("account_type_pkey");

        builder.ToTable("account_type");

        builder.Property(e => e.Id)
            .HasColumnName("account_type_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.CoreCode)
            .HasColumnName("core_code")
            .HasMaxLength(10)
            .IsRequired();

        builder.Property(e => e.BankId)
            .HasColumnName("bank_id")
            .IsRequired();

        builder.Property(e => e.Description)
            .HasColumnName("description")
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(e => e.Currency)
            .HasColumnName("currency")
            .HasMaxLength(3)
            .IsRequired();

        builder.Property(e => e.GlNumber)
            .HasMaxLength(16)
            .HasColumnName("gl_number");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.Bank)
            .WithMany(u => u.AccountTypes)
            .HasForeignKey(nc => nc.BankId)
            .HasConstraintName("fk_account_type_bank");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AdvertisingConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AdvertisingConfiguration : IEntityTypeConfiguration<Advertising>
    {
        public void Configure(EntityTypeBuilder<Advertising> entity)
        {
            entity.HasKey(e => e.Id).HasName("advertising_id_pkey");

            entity.ToTable("advertising");

            entity.Property(e => e.Id)
                .HasColumnName("advertising_id")
                .IsRequired();

            entity.Property(e => e.Description)
                .HasColumnName("description");

            entity.Property(e => e.ScreenId)
                .HasColumnName("screen_id")
                .IsRequired();

            entity.Property(e => e.Type)
                .HasColumnName("type")
                .IsRequired();

            entity.Property(e => e.Module)
                .HasColumnName("module")
                .HasDefaultValue(AdvertisingModule.Account);

            entity.Property(e => e.BankId)
                .HasColumnName("bank_id");

            entity.Property(e => e.IsActive)
                .HasColumnName("is_active");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AdvertisingDetailConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AdvertisingDetailConfiguration : IEntityTypeConfiguration<AdvertisingDetail>
    {
        public void Configure(EntityTypeBuilder<AdvertisingDetail> entity)
        {
            entity.HasKey(e => e.Id).HasName("advertising_detail_id_pkey");

            entity.ToTable("advertising_detail");

            entity.Property(e => e.Id)
                .HasColumnName("advertising_detail_id")
                .IsRequired();

            entity.Property(e => e.AdvertisingId)
                .IsRequired(true)
                .HasColumnName("advertising_id");

            entity.Property(e => e.MediaUrl)
                .HasColumnName("media_url");

            entity.Property(e => e.RedirectTo)
                .IsRequired(true)
                .HasColumnName("redirect_to");

            entity.Property(e => e.Link)
                .HasColumnName("link");

            entity.Property(e => e.HasCondition)
                .HasColumnName("has_condition");

            entity.Property(e => e.Description)
                .HasColumnName("description");

            entity.Property(e => e.Priority)
                .HasDefaultValue(0)
                .HasColumnName("priority");

            entity.Property(e => e.TargetData)
                .HasColumnName("target_data");

            entity.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.HasOne(e => e.Advertising)
                .WithMany(e => e.AdvertisingDetail)
                .HasForeignKey(fk => fk.AdvertisingId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("advertising_detail_advertising_id_fkey");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AppResourceConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class AppResourceConfiguration : IEntityTypeConfiguration<AppResource>
{
    public void Configure(EntityTypeBuilder<AppResource> builder)
    {
        // Configuración de la clave primaria
        builder.HasKey(e => e.Id).HasName("app_resource_pkey");

        // Configuración del nombre de la tabla
        builder.ToTable("app_resource");

        // Configuración de índices
        builder.HasIndex(e => new { e.ResourceType, e.BankId })
            .HasDatabaseName("app_resource_type_bank_id_idx");

        // Configuración de propiedades
        builder.Property(e => e.Id)
            .HasColumnName("app_resource_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.ResourceType)
            .IsRequired()
            .HasColumnName("resource_type");

        builder.Property(e => e.PathResource)
            .HasMaxLength(2000)
            .HasColumnName("path_resource");

        builder.Property(e => e.VersionResource)
            .IsRequired()
            .HasMaxLength(50)
            .HasColumnName("version_resource");

        builder.Property(e => e.BankId)
            .HasMaxLength(255)
            .HasColumnName("bank_id");

        builder.Property(e => e.ProductType)
            .HasColumnName("product_type");

        builder.Property(e => e.IsActive)
            .IsRequired()
            .HasDefaultValue(true)
            .HasColumnName("is_active");

        builder.Property(e => e.SubProduct)
            .HasMaxLength(255)
            .HasColumnName("sub_product");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
        .HasColumnType("timestamp with time zone")
        .HasColumnName("deleted_at");

        builder.HasOne(p => p.Bank)
            .WithMany(b => b.AppResources)
            .HasForeignKey(p => p.BankId)
            .OnDelete(DeleteBehavior.Cascade)
            .HasConstraintName("fk_app_resource_bank_id");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AppScreenConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AppScreenConfiguration : IEntityTypeConfiguration<AppScreen>
    {
        public void Configure(EntityTypeBuilder<AppScreen> entity)
        {
            entity.HasKey(e => e.Id).HasName("screen_pkey");

            entity.ToTable("app_screen");

            entity.HasIndex(e => e.SectionId).HasDatabaseName("fk_app_screens_section");

            entity.Property(e => e.Id)
                .HasColumnName("app_screen_id")
                .HasMaxLength(50)
                .IsRequired();

            entity.Property(e => e.ScreenName)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("screen_name");

            entity.Property(e => e.Description)
                .HasColumnName("description")
                .HasMaxLength(150);

            entity.Property(e => e.SectionId)
                .IsRequired()
                .HasColumnName("section_id");

            entity.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            entity.Property(e => e.CountryCode)
                .IsRequired()
                .HasMaxLength(3)
                .HasColumnName("country_code");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.HasOne(e => e.Section)
                .WithMany(u => u.Sections)
                .HasForeignKey(e => e.SectionId)
                .HasConstraintName("fk_app_screens_section");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AppSectionCatalogConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AppSectionCatalogConfiguration : IEntityTypeConfiguration<AppSectionCatalog>
    {
        public void Configure(EntityTypeBuilder<AppSectionCatalog> entity)
        {
            entity.HasKey(e => e.Id).HasName("section_pkey");

            entity.ToTable("app_section_catalog");

            entity.Property(e => e.Id)
                .HasColumnName("section_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            entity.Property(e => e.SectionName)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("section_name");

            entity.Property(e => e.Description)
                .HasColumnName("description")
                .HasMaxLength(150);

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                    .HasColumnType("timestamp with time zone")
                    .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AppVersionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AppVersionConfiguration : IEntityTypeConfiguration<AppVersion>
    {
        public void Configure(EntityTypeBuilder<AppVersion> entity)
        {
            entity.HasKey(e => e.Id).HasName("version_pkey");

            entity.ToTable("app_version");

            entity.Property(e => e.Id)
                .HasColumnName("app_version_id")
                .IsRequired();

            entity.Property(e => e.Description)
                .HasColumnName("description");

            entity.Property(e => e.IsRequired)
                .HasColumnName("is_required");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\AppVersionDetailConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class AppVersionDetailConfiguration : IEntityTypeConfiguration<AppVersionDetail>
    {
        public void Configure(EntityTypeBuilder<AppVersionDetail> entity)
        {
            entity.HasKey(e => e.Id).HasName("version_detail_pkey");

            entity.ToTable("app_version_detail");

            entity.Property(e => e.Id)
                .HasColumnName("app_version_detail_id")
                .IsRequired();

            entity.Property(e => e.AppVersionId)
                .IsRequired(true)
                .HasColumnName("app_version_id");

            entity.Property(e => e.NewDescription)
                .HasColumnName("new_description");

            entity.Property(e => e.NewImageUrl)
                .HasColumnName("new_image_url");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.HasOne(e => e.AppVersion)
                .WithMany(e => e.AppVersionDetail)
                .HasForeignKey(fk => fk.AppVersionId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("app_version_detail_app_version_id_fkey")
                .IsRequired(false);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\BankConfiguration.cs
```csharp
using Amazon.XRay.Recorder.Core.Internal.Entities;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class BankConfiguration : IEntityTypeConfiguration<Bank>
    {
        public void Configure(EntityTypeBuilder<Bank> builder)
        {
            // Definición de la clave primaria con tipo string
            builder.HasKey(e => e.Id).HasName("bank_pkey");

            // Configuración de la tabla y esquema
            builder.ToTable("bank", "dxp_app");

            // Configuración de las propiedades de la entidad Bank
            builder.Property(e => e.Id)
                .HasColumnName("bank_id")
                .HasMaxLength(10) // Tamaño máximo de 10 caracteres para bank_id
                .IsRequired(); // Opcional, dependiendo si deseas que el ID sea obligatorio

            builder.Property(e => e.BankName)
                .HasMaxLength(100)
                .HasColumnName("bank_name");

            builder.Property(e => e.Active)
                .HasColumnName("active");

            builder.Property(e => e.CreatedBy)
                .HasMaxLength(50)
                .HasColumnName("created_by");

            builder.Property(e => e.UpdatedBy)
                .HasMaxLength(50)
                .HasColumnName("updated_by");

            builder.Property(e => e.Prefix)
                .HasMaxLength(10)
                .HasColumnName("prefix");

            builder.Property(e => e.PhoneNumber)
                .HasMaxLength(25)
                .HasColumnName("phone_number");

            builder.Property(e => e.CreatedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'");

            builder.Property(e => e.UpdatedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de la relación con la entidad Onboarding
            builder.HasMany(e => e.Onboardings)
                .WithOne(o => o.Bank)
                .HasForeignKey(o => o.BankId)
                .OnDelete(DeleteBehavior.Restrict)
                .HasConstraintName("fk_onboarding_bank_id");

        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\BiometricAccountConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class BiometricAccountConfiguration : IEntityTypeConfiguration<BiometricAccount>
    {
        public void Configure(EntityTypeBuilder<BiometricAccount> builder)
        {
            builder.HasKey(e => e.Id).HasName("biometric_account_pkey");

            // Configure the table name
            builder.ToTable("biometric_account");

            builder.Property(e => e.Id)
                .HasColumnName("biometric_account_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(e => e.UserId)
                .IsRequired()
                .HasColumnName("user_id");

            builder.Property(e => e.AccountId)
                .IsRequired()
                .HasColumnName("account_id");

            builder.Property(e => e.ProviderName)
                .HasColumnName("provider_name_id");

            builder.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .IsRequired()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // RELATIONSHIPS
            builder.HasOne(e => e.User)
                .WithMany(er => er.BiometricAccounts)
                .HasForeignKey(e => e.UserId)
                .HasConstraintName("fk_biometric_account_user");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\CountryBankConfiguration.cs
```csharp
using Amazon.XRay.Recorder.Core.Internal.Entities;
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class CountryBankConfiguration : IEntityTypeConfiguration<CountryBank>
    {
        public void Configure(EntityTypeBuilder<CountryBank> builder)
        {
            // Definición de la clave primaria
            builder.HasKey(e => e.Id).HasName("country_bank_pkey");

            // Configuración de la tabla
            builder.ToTable("country_bank", "dxp_app");

            // Configuración de las propiedades
            builder.Property(e => e.Id)
                .HasColumnName("country_bank_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.CoreId)
                .HasMaxLength(50)
                .HasColumnName("core_id");

            builder.Property(e => e.Bic)
                .HasMaxLength(10)
                .HasColumnName("bic");

            builder.Property(e => e.BankName)
                .IsRequired()
                .HasMaxLength(200)
                .HasColumnName("bank_name");

            builder.Property(e => e.Alias)
                .HasMaxLength(25)
                .HasColumnName("alias");

            builder.Property(e => e.SwiftCode)
                .HasMaxLength(12)
                .HasColumnName("swift_code");

            builder.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(e => e.CountryCode)
                .IsRequired()
                .HasMaxLength(3)
                .HasColumnName("country_code");

            builder.Property(e => e.ImageUrl)
                .HasMaxLength(200)
                .HasColumnName("image_url");

            builder.Property(e => e.BankId)
               .HasMaxLength(255)
               .HasColumnName("bank_id");

            builder.Property(e => e.ExternalReference)
                .HasMaxLength(200)
                .HasColumnName("external_reference");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Índice único en BankName y CountryCode para asegurar la unicidad en el contexto del país
            builder.HasIndex(e => new { e.BankName, e.CountryCode })
                .IsUnique()
                .HasDatabaseName("ix_country_banks_bank_name_country_code");

            // Índice en CoreId para búsquedas rápidas por identificador central
            builder.HasIndex(e => e.CoreId)
                .HasDatabaseName("ix_country_banks_core_id");

            // Índice en SwiftCode para búsquedas rápidas por código SWIFT
            builder.HasIndex(e => e.SwiftCode)
                .HasDatabaseName("ix_country_banks_swift_code");

            builder.HasOne(cb => cb.Bank)
                    .WithMany(b => b.CountryBanks)
                    .HasForeignKey(cb => cb.BankId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict)
                    .HasConstraintName("fk_country_bank_bank_id");

        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\CountryBankProductTypeConfigConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class CountryBankProductTypeConfigConfiguration : IEntityTypeConfiguration<CountryBankProductTypeConfig>
{
    public void Configure(EntityTypeBuilder<CountryBankProductTypeConfig> builder)
    {
        builder.HasKey(e => e.Id).HasName("country_bank_product_type_config_pkey");

        builder.ToTable("country_bank_product_type_config");

        builder.Property(e => e.Id)
            .HasColumnName("country_bank_product_type_config_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.CountryBankId)
            .HasColumnName("country_bank_id");

        builder.Property(e => e.TransferMethodProductTypeId)
            .HasColumnName("transfer_method_product_type_id");

        builder.Property(e => e.Currency)
            .HasColumnName("currency")
            .HasMaxLength(3)
            .IsRequired();

        builder.Property(e => e.IsActive)
            .HasColumnName("is_active")
            .HasDefaultValue(true);

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.CountryBank)
            .WithMany(u => u.CountryBankProductTypeConfigs)
            .HasForeignKey(nc => nc.CountryBankId)
            .HasConstraintName("fk_country_bank_product_type_config_country_bank");

        builder.HasOne(nc => nc.TransferMethodProductType)
            .WithMany(u => u.CountryBankProductTypeConfigs)
            .HasForeignKey(nc => nc.TransferMethodProductTypeId)
            .HasConstraintName("fk_country_bank_product_type_config_transfer_method_product_type");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\DeviceConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class DeviceConfiguration : IEntityTypeConfiguration<Device>
    {
        public void Configure(EntityTypeBuilder<Device> builder)
        {
            builder.HasKey(e => e.Id).HasName("device_pkey");

            builder.ToTable("device");

            builder.Property(e => e.Id)
                .HasColumnName("device_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(e => e.UserId)
                .HasColumnName("user_id");

            builder.Property(e => e.DeviceToken)
                .IsRequired()
                .HasMaxLength(255)
                .HasColumnName("device_token");

            builder.Property(e => e.DeviceName)
                .HasMaxLength(100)
                .HasColumnName("device_name");

            builder.Property(e => e.UniqueDeviceId)
                .HasMaxLength(100)
                .HasColumnName("unique_device_id");

            builder.Property(e => e.IsPrimary)
                .HasDefaultValue(false)
                .HasColumnName("is_primary");

            builder.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(e => e.BiometricHash)
                .HasColumnName("biometric_hash");

            builder.Property(e => e.RefreshToken)
                .HasColumnName("refresh_token")
                .HasMaxLength(100);

            builder.Property(e => e.LastLogIn)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("last_log_in");

            builder.Property(e => e.LastLogOut)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("last_log_out");

            builder.Property(e => e.IsFirstLogIn)
                .HasColumnName("is_first_log_in");

            builder.Property(e => e.MustLogOut)
                .HasColumnName("must_log_out");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(d => d.User)
                .WithMany(u => u.Devices)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("device_user_id_fkey");

            // Índice en UserId, UniqueDeviceId e IsActive
            builder.HasIndex(p => new { p.UserId, p.UniqueDeviceId, p.IsActive })
                .HasDatabaseName("ix_device_user_id_unique_device_id_is_active");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FailedOpportunityConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FailedOpportunityConfiguration : IEntityTypeConfiguration<FailedOpportunity>
    {
        public void Configure(EntityTypeBuilder<FailedOpportunity> builder)
        {
            // Set the primary key
            builder.HasKey(e => e.Id).HasName("failed_opportunities_pkey");

            // Set the table name in snake_case
            builder.ToTable("failed_opportunities");

            // Map C# properties to snake_case columns
            builder.Property(fo => fo.Id)
                .HasColumnName("failed_opportunities_id")
                .ValueGeneratedOnAdd()
                .HasIdentityOptions(startValue: 1);

            builder.Property(e => e.UserId)
               .IsRequired()
               .HasColumnName("user_id");

            builder.Property(e => e.BankId)
               .IsRequired()
               .HasColumnName("bank_id");

            builder.Property(fo => fo.CurrentStage)
               .HasColumnName("current_stage")
               .HasColumnType("dxp_app.current_stage");

            builder.Property(fo => fo.FailedReason).HasColumnName("failed_reason");
            builder.Property(fo => fo.RetriesNumber).HasColumnName("retries_number");

            builder.Property(fo => fo.OpportunityJson)
                .HasColumnName("opportunity_json")
                .HasColumnType("jsonb");

            builder.Property(fo => fo.ErrorMessage).HasColumnName("error_message");

            builder.Property(fo => fo.ExpectedCloseDate)
                .HasDefaultValueSql("CURRENT_TIMESTAMP")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("expected_close_date");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            // Define foreign key relationships
            builder.HasOne(fo => fo.Bank)
                .WithMany(fo => fo.FailedOpportunities)
                .HasForeignKey(fo => fo.BankId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_failed_opportunities_bank_bank_id");

            builder.HasOne(fo => fo.User)
            .WithOne(fo => fo.FailedOpportunity)
            .HasForeignKey<FailedOpportunity>(fa => fa.UserId)
            .HasConstraintName("fk_failed_opportunities_user_user_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FavoriteGroupConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FavoriteGroupConfiguration : IEntityTypeConfiguration<FavoriteGroup>
    {
        public void Configure(EntityTypeBuilder<FavoriteGroup> builder)
        {
            // Configure the primary key
            builder.HasKey(e => e.Id)
                .HasName("favorites_groups_pkey");

            // Configure the table name
            builder.ToTable("favorites_group");

            // Configure properties
            builder.Property(e => e.Id)
                .HasColumnName("favorite_group_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.GroupName)
                .IsRequired()
                .HasMaxLength(200)
                .HasColumnName("group_name");

            builder.Property(e => e.ProfileId)
                .IsRequired()
                .HasColumnName("profile_id");

            builder.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(e => e.GroupType)
              .IsRequired(false)
              .HasColumnName("group_type");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .IsRequired()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configure relationships
            builder.HasOne(fg => fg.Profile)
                .WithMany(up => up.FavoriteGroups)
                .HasForeignKey(fg => fg.ProfileId)
                .HasConstraintName("fk_favorites_groups_user_profile");

            // Configure indices
            builder.HasIndex(fg => fg.GroupName)
                .HasDatabaseName("ix_favorites_groups_group_name");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FavoriteServiceConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FavoriteServiceConfiguration : IEntityTypeConfiguration<FavoriteService>
    {
        public void Configure(EntityTypeBuilder<FavoriteService> builder)
        {
            // Configure the primary key
            builder.HasKey(e => e.Id)
                .HasName("favorites_services_pkey");

            // Configure the table name
            builder.ToTable("favorites_service");

            // Configure properties
            builder.Property(e => e.Id)
                .HasColumnName("favorite_service_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.ServiceIdCore)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("service_id_core");

            builder.Property(e => e.ServiceCategoryId)
                .IsRequired()
                .HasMaxLength(200)
                .HasColumnName("service_category_id");

            builder.Property(e => e.FavoriteGroupId)
                .IsRequired()
                .HasColumnName("favorite_group_id");

            builder.Property(e => e.ServiceName)
                .IsRequired()
                .HasMaxLength(255)
                .HasColumnName("service_name");

            builder.Property(e => e.ProviderId)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("provider_id");

            builder.Property(e => e.ImageUrl)
                .HasColumnName("image_url");

            builder.Property(e => e.IsActive)
                .HasColumnName("is_active");

            builder.Property(e => e.Currency)
                .HasMaxLength(3)
                .HasColumnName("currency");

            builder.Property(e => e.Amount)
                .HasColumnName("amount");

            builder.Property(e => e.AdditionalDataPayment)
                .IsRequired()
                .HasColumnName("additional_data_payment");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .IsRequired()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configure relationships
            builder.HasOne(fs => fs.FavoriteGroup)
                .WithMany(bg => bg.FavoriteServices)
                .HasForeignKey(fs => fs.FavoriteGroupId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_favorites_services_favorite_group");

            // Configure indices
            builder.HasIndex(fs => fs.ServiceName)
                .HasDatabaseName("ix_favorites_services_service_name");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FavoriteTransactionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FavoriteTransactionConfiguration : IEntityTypeConfiguration<FavoriteTransaction>
    {
        public void Configure(EntityTypeBuilder<FavoriteTransaction> builder)
        {
            // Configure the primary key
            builder.HasKey(e => e.Id)
                .HasName("favorite_transaction_pkey");

            // Configure the table name
            builder.ToTable("favorites_transaction");

            // Configure properties
            builder.Property(e => e.Id)
                .HasColumnName("favorite_transaction_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.FavoriteGroupId)
                .IsRequired()
                .HasColumnName("favorite_group_id");

            builder.Property(e => e.Alias)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("alias");

            builder.Property(e => e.AccountHolderName)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("account_holder_name");

            builder.Property(e => e.ProductType)
               .IsRequired(false)
               .HasColumnName("product_type");

            builder.Property(e => e.ProductNumber)
                .IsRequired()
                .HasMaxLength(50)
                .HasColumnName("product_number");

            builder.Property(e => e.Amount)
                .HasColumnName("amount"); // Remove default value configuration

            builder.Property(e => e.IsActive)
                .HasColumnName("is_active");

            builder.Property(e => e.Currency)
                .IsRequired()
                .HasMaxLength(3)
                .HasColumnName("currency");

            builder.Property(e => e.TransactionType)
              .IsRequired(false)
              .HasColumnName("transaction_type");

            builder.Property(e => e.UserPicture)
                .IsRequired(false)
                .HasMaxLength(300)
                .HasColumnName("user_picture_url");

            builder.Property(e => e.AdditionalData)
                .IsRequired(false)
                .HasMaxLength(1000)
                .HasColumnName("additional_data");

            builder.Property(e => e.CountryBankId)
               .IsRequired()
               .HasColumnName("country_bank_id");

            builder.Property(e => e.UserDestinationId)
                .IsRequired(false)
                .HasColumnName("user_destination_id");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .IsRequired()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configure relationships
            builder.HasOne(ft => ft.CountryBank)
                .WithMany(cb => cb.FavoriteTransactions)
                .HasForeignKey(ft => ft.CountryBankId) // Corrected foreign key
                .HasConstraintName("fk_favorite_transaction_country_bank");

            builder.HasOne(ft => ft.FavoriteGroup)
                .WithMany(cb => cb.FavoriteTransactions)
                .HasForeignKey(ft => ft.FavoriteGroupId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_favorite_transaction_favorite_group");

            builder.HasOne(e => e.UserDestination)
                .WithMany(u => u.FavoriteTransactions)
                .HasForeignKey(e => e.UserDestinationId)
                .OnDelete(DeleteBehavior.Restrict)
                .HasConstraintName("fk_favorite_ransactions_user_destination");

            // Configure indices
            builder.HasIndex(ft => ft.ProductNumber)
                .HasDatabaseName("ix_favorite_transactions_product_number");

            builder.HasIndex(ft => ft.ProductType)
                .HasDatabaseName("ix_favorite_transactions_product_type");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FrequentlyQuestionsConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FrequentlyQuestionsConfiguration : IEntityTypeConfiguration<FrequentlyQuestions>
    {
        public void Configure(EntityTypeBuilder<FrequentlyQuestions> builder)
        {
            // pk
            builder.HasKey(x => x.Id).HasName("frequently_questions_pkey");

            // table
            builder.ToTable("frequently_question");

            // properties
            builder.Property(x => x.Id)
                .HasColumnName("frequently_questions_id")
                .ValueGeneratedOnAdd();

            builder.Property(x => x.BankId)
                .HasColumnName("bank_id")
                .HasMaxLength(10)
                .IsRequired();

            builder.Property(x => x.Description)
                .HasColumnName("description")
                .IsRequired();

            builder.Property(x => x.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(x => x.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(x => x.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // fk
            builder.HasOne(x => x.Bank)
                .WithMany(m => m.FrequentlyQuestions)
                .HasForeignKey(fk => fk.BankId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("frequently_questions_bank_id_fkey");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FrequentlyQuestionsDetailConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FrequentlyQuestionsDetailConfiguration : IEntityTypeConfiguration<FrequentlyQuestionsDetail>
    {
        public void Configure(EntityTypeBuilder<FrequentlyQuestionsDetail> builder)
        {
            // pk
            builder.HasKey(x => x.Id).HasName("frequently_questions_detail_pkey");

            // table
            builder.ToTable("frequently_questions_detail");

            // properties
            builder.Property(x => x.Id)
                .HasColumnName("frequently_questions_detail_id")
                .ValueGeneratedOnAdd();

            builder.Property(x => x.FrequentlyQuestionsId)
                .HasColumnName("frequently_questions_id")
                .HasMaxLength(10)
                .IsRequired();

            builder.Property(x => x.Question)
                .HasColumnName("question")
                .IsRequired();

            builder.Property(x => x.Answer)
                .HasColumnName("answer")
                .IsRequired();

            builder.Property(x => x.Language)
                .HasColumnName("language")
                .IsRequired();

            builder.Property(x => x.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(x => x.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(x => x.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // fk
            builder.HasOne(x => x.FrequentlyQuestion)
                .WithMany(m => m.FrequentlyQuestionsDetail)
                .HasForeignKey(fk => fk.FrequentlyQuestionsId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("frequently_question_detail_frequently_questions_id_fkey")
                .IsRequired(false);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FunctionalityConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FunctionalityConfiguration : IEntityTypeConfiguration<Functionality>
    {
        public void Configure(EntityTypeBuilder<Functionality> builder)
        {
            // Configuración de la clave primaria
            builder.HasKey(f => f.Id)
                .HasName("functionality_pkey");

            // Configuración de la tabla
            builder.ToTable("functionality");

            // Configuración de índices
            builder.HasIndex(f => f.FunctionalityName)
                .IsUnique()
                .HasDatabaseName("idx_functionality_name");

            builder.HasIndex(f => f.BankId)
                .HasDatabaseName("idx_functionality_bank_id");

            builder.HasIndex(f => f.IsActive)
                .HasDatabaseName("idx_functionality_is_active");

            builder.HasIndex(f => new { f.ParentFunctionalityId, f.IsActive })
                .HasDatabaseName("idx_functionality_parent_active");

            // Configuración de las propiedades
            builder.Property(f => f.Id)
                .HasColumnName("functionality_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(f => f.FunctionalityName)
                .IsRequired()
                .HasMaxLength(100)
                .HasColumnName("functionality_name");

            builder.Property(f => f.BankId)
                .IsRequired(false)
                .HasMaxLength(50)
                .HasColumnName("bank_id");

            builder.Property(f => f.Description)
                .HasMaxLength(500)
                .HasColumnName("description");

            builder.Property(f => f.ImageUrl)
                .HasMaxLength(255)
                .HasColumnName("image_url");

            builder.Property(f => f.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(f => f.ParentFunctionalityId)
                .HasColumnName("parent_functionality_id");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.Property(f => f.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(f => f.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            // Configuración de la relación con la entidad Bank
            builder.HasOne(f => f.Bank)
                .WithMany(b => b.Functionalities)
                .HasForeignKey(f => f.BankId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_functionality_bank_id");

            // Configuración de la relación auto-referencial (funcionalidades hijas y padre)
            builder.HasOne(f => f.ParentFunctionality)
                .WithMany(f => f.ChildFunctionalities)
                .HasForeignKey(f => f.ParentFunctionalityId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_functionality_parent_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FunFactConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FunFactConfiguration : IEntityTypeConfiguration<FunFact>
    {
        public void Configure(EntityTypeBuilder<FunFact> builder)
        {
            //Primary Key
            builder.HasKey(f => f.Id).HasName("fun_fact_pkey");

            //Table
            builder.ToTable("fun_fact");

            builder.Property(f => f.Id)
                .HasColumnName("fun_fact_id")
                .ValueGeneratedOnAdd();

            builder.Property(f => f.Title)
                .HasMaxLength(20)
                .HasColumnName("title");

            builder.Property(f => f.BankId)
                .HasColumnName("bank_id")
                .HasMaxLength(10)
                .IsRequired();

            builder.Property(f => f.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(f => f.CategoryType)
                .IsRequired()
                .HasColumnName("category_type");

            builder.Property(f => f.ScreenId)
                .HasMaxLength(50)
                .HasColumnName("screen_id");

            builder.Property(e => e.CreatedAt)
               .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
               .HasColumnType("timestamp with time zone")
               .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\FunFactDetailConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class FunFactDetailConfiguration : IEntityTypeConfiguration<FunFactDetail>
    {
        public void Configure(EntityTypeBuilder<FunFactDetail> builder)
        {
            //Primary Key
            builder.HasKey(x => x.Id);

            builder.ToTable("fun_fact_detail");

            builder.Property(f => f.FunFactId)
                .IsRequired(true)
                .HasColumnName("fun_fact_id");

            builder.Property(f => f.Description)
                .HasMaxLength(100)
                .IsRequired()
                .HasColumnName("description");

            builder.Property(f => f.Icon)
                .HasColumnName("icon");

            builder.Property(f => f.Priority)
                .HasColumnName("priority");

            builder.Property(f => f.Language)
                .HasColumnName("language");

            builder.HasOne(f => f.FunFact)
                .WithMany(fn => fn.FunFactDetail)
                .HasForeignKey(fk => fk.FunFactId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fun_fact_detail_fun_fact_id");

            builder.Property(e => e.CreatedAt)
               .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
               .HasColumnType("timestamp with time zone")
               .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\KycConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class KycConfiguration : IEntityTypeConfiguration<Kyc>
    {
        public void Configure(EntityTypeBuilder<Kyc> builder)
        {
            builder.HasKey(e => e.Id).HasName("kyc_pkey");

            builder.HasIndex(e => e.KycStatus).HasDatabaseName("idx_kycs_status");

            builder.ToTable("kyc");

            builder.Property(e => e.Id)
                .HasColumnName("kyc_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(e => e.UserId)
                .HasColumnName("user_id");

            builder.Property(e => e.JumioAccountId)
                .HasMaxLength(100)
                .HasColumnName("jumio_account_id");

            builder.Property(e => e.JumioWorkflowHref)
                .HasMaxLength(255)
                .HasColumnName("jumio_workflow_href");

            builder.Property(e => e.KycStatus)
                .IsRequired()
                .HasDefaultValue(KycStatus.Pending)
                .HasColumnName("kyc_status");

            builder.Property(e => e.BiometricData)
                .HasColumnType("json")
                .HasColumnName("biometric_data");

            // Configuración para la propiedad LogId
            builder.Property(e => e.LogId)
                .HasMaxLength(300) // Tamaño máximo para SHA
                .HasColumnName("log_id");

            // Configuración para la propiedad CertificateType
            builder.Property(e => e.CertificateType)
                .HasColumnName("certificate_type");

            // Configuración para la propiedad Certificate
            builder.Property(e => e.Certificate)
                .HasColumnType("text") // Tipo TEXT para almacenar certificados grandes
                .HasColumnName("certificate");

            builder.Property(e => e.Reason)
                .HasColumnName("reason")
                .HasMaxLength(50);

            builder.Property(e => e.CheckCategories)
                .HasColumnName("check_categories")
                .HasColumnType("jsonb");

            builder.Property(e => e.ChallengeId)
                .HasColumnName("challenge_id")
                .HasMaxLength(50);

            builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .ValueGeneratedOnAddOrUpdate()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(k => k.User)
                .WithMany(u => u.Kycs)
                .HasForeignKey(k => k.UserId)
                .OnDelete(DeleteBehavior.Restrict)
                .HasConstraintName("kyc_user_id_fkey");

            // Índice en LogId
            builder.HasIndex(k => k.LogId)
                .HasDatabaseName("ix_kyc_log_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\NotificationConfigConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class NotificationConfigConfiguration : IEntityTypeConfiguration<NotificationConfig>
    {
        public void Configure(EntityTypeBuilder<NotificationConfig> builder)
        {
            builder.HasKey(e => e.Id).HasName("notification_config_pkey");

            builder.ToTable("notification_config");

            builder.Property(e => e.Id)
                .HasColumnName("notification_config_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(e => e.UserId)
                .HasColumnName("user_id");

            builder.Property(e => e.NotificationType)
                .HasColumnName("notification_type")
                .IsRequired();

            builder.Property(e => e.ConfigurationType)
                .HasColumnName("configuration_type")
                .IsRequired();

            builder.Property(e => e.Description)
                .HasMaxLength(255)
                .HasColumnName("description");

            builder.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(nc => nc.User)
                .WithMany(u => u.NotificationConfigs)
                .HasForeignKey(nc => nc.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("notification_config_user_id_fkey");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\NotificationConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class NotificationConfiguration : IEntityTypeConfiguration<Notification>
    {
        public void Configure(EntityTypeBuilder<Notification> builder)
        {
            // Configuración de la clave primaria
            builder.HasKey(e => e.Id)
                .HasName("notification_pkey");

            // Configuración de la tabla
            builder.ToTable("notification");

            // Configuración de índices
            builder.HasIndex(e => e.UserId)
                .HasDatabaseName("idx_notification_user");

            builder.HasIndex(e => e.CreatedAt)
                .HasDatabaseName("idx_notification_sent_at");

            // Configuración de propiedades
            builder.Property(e => e.Id)
                .HasColumnName("notification_id")
                .ValueGeneratedOnAdd()  // Configura el ID para que sea autonumérico
                .HasIdentityOptions(startValue: 1); // Opcional: puedes configurar el valor inicial

            builder.Property(e => e.UserId)
                .HasColumnName("user_id")
                .IsRequired();

            builder.Property(e => e.NotificationType)
                .HasColumnName("notification_type")
                .IsRequired();

            builder.Property(e => e.ProcessType)
                .HasColumnName("process_type")
                .IsRequired();

            builder.Property(e => e.Message)
                .HasColumnName("message")
                .IsRequired()
                .HasMaxLength(1000); // Ajusta el tamaño según sea necesario

            builder.Property(e => e.Body)
                .HasColumnName("body")
                .IsRequired()
                .HasMaxLength(2000); // Ajusta el tamaño según sea necesario

            builder.Property(e => e.DeviceId)
                .HasColumnName("device_id");

            builder.Property(e => e.AppScreenId)
                .HasColumnName("app_screen_id");

            builder.Property(e => e.NotificationTextId)
                .IsRequired(false)
                .HasColumnName("notification_text_id");

            builder.Property(e => e.DataReplacement)
                .IsRequired(false)
                .HasColumnName("data_replacement");

            builder.Property(e => e.Status)
                .HasColumnName("status")
                .HasDefaultValue(NotificationStatus.Sent);

            builder.Property(e => e.ImageUrl)
                .HasColumnName("image_url")
                .HasMaxLength(3000);

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones
            builder.HasOne(e => e.User)
                .WithMany(u => u.Notifications)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("fk_notification_user");

            builder.HasOne(e => e.Device)
                .WithMany(u => u.Notifications)
                .HasForeignKey(e => e.DeviceId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_notification_device");

            builder.HasOne(e => e.AppScreen)
                .WithMany(u => u.Notifications)
                .HasForeignKey(e => e.AppScreenId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("fk_notification_app_screen");

            builder.HasOne(e => e.NotificationTexts)
                .WithMany(u => u.Notifications)
                .HasForeignKey(e => e.NotificationTextId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("fk_notification_notification_text");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\NotificationHistoryConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    /// <summary>
    /// Configuración para la entidad <see cref="NotificationHistory"/>.
    /// </summary>
    public class NotificationHistoryConfiguration : IEntityTypeConfiguration<NotificationHistory>
    {
        public void Configure(EntityTypeBuilder<NotificationHistory> builder)
        {
            // Configuración de la clave primaria
            builder.HasKey(e => e.Id)
                .HasName("notification_history_pkey");

            // Configuración de la tabla
            builder.ToTable("notification_history");

            // Configuración de índices
            builder.HasIndex(e => e.UserId)
                .HasDatabaseName("idx_notification_history_user");

            builder.HasIndex(e => e.SentAt)
                .HasDatabaseName("idx_notification_history_sent_at");

            // Configuración de propiedades
            builder.Property(e => e.Id)
                .HasColumnName("notification_history_id")
                .ValueGeneratedOnAdd()
                .HasIdentityOptions(startValue: 1); // Opcional: puedes configurar el valor inicial

            builder.Property(e => e.UserId)
                .HasColumnName("user_id")
                .IsRequired(false); // Permite valores nulos

            builder.Property(e => e.NotificationType)
                .HasColumnName("notification_type");

            builder.Property(e => e.ProcessType)
                .HasColumnName("process_type")
                .IsRequired();

            builder.Property(e => e.Message)
                .HasColumnName("message")
                .IsRequired(false) // Permite valores nulos
                .HasMaxLength(1000);

            builder.Property(e => e.SentAt)
                .HasColumnName("sent_at")
                .HasColumnType("timestamptz");

            builder.Property(e => e.DeviceId)
                .HasColumnName("device_id");

            builder.Property(e => e.AppScreenId)
                .HasColumnName("screen_id");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones
            builder.HasOne(e => e.User)
                .WithMany(u => u.NotificationHistories)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("fk_notification_history_user");

            builder.HasOne(e => e.Device)
                .WithMany(u => u.NotificationHistories)
                .HasForeignKey(e => e.DeviceId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_notification_history_device");

            builder.HasOne(e => e.AppScreen)
                .WithMany(u => u.NotificationHistories)
                .HasForeignKey(e => e.AppScreenId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("fk_notification_history_app_screen");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\NotificationTextsConfigurations.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class NotificationTextsConfigurations : IEntityTypeConfiguration<NotificationTexts>
    {
        public void Configure(EntityTypeBuilder<NotificationTexts> builder)
        {
            builder.HasKey(nt => nt.Id)
                .HasName("notification_text_pkey");

            builder.ToTable("notification_text");

            builder.Property(nt => nt.Language)
                .HasColumnName("language");

            builder.Property(nt => nt.TransactionType)
                .HasColumnName("transaction_type");

            builder.Property(nt => nt.ProcessType)
                .HasColumnName("process_type");

            builder.Property(nt => nt.TransactionStatus)
                .HasColumnName("transaction_status");

            builder.Property(nt => nt.Title)
                .HasColumnName("title");

            builder.Property(nt => nt.Body)
                .HasColumnName("body");

            builder.Property(nt => nt.IsDebit)
                .IsRequired()
                .HasColumnName("is_debit_transaction");

            builder.Property(nt => nt.ExternalId)
                .HasDefaultValue(null)
                .HasColumnName("external_id");

            builder.Property(nt => nt.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(nt => nt.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\NotificationTextsDetailConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class NotificationTextsDetailConfiguration : IEntityTypeConfiguration<NotificationTextsDetail>
    {
        public void Configure(EntityTypeBuilder<NotificationTextsDetail> builder)
        {
            builder.HasKey(nt => nt.Id)
                .HasName("notification_text_detail_pkey");

            builder.ToTable("notification_text_detail");

            builder.Property(e => e.Id)
                .HasColumnName("notification_text_detail_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.NotificationTextId)
                .IsRequired(false)
                .HasColumnName("notification_text_id");

            builder.Property(nt => nt.Language)
                .HasColumnName("language");

            builder.Property(nt => nt.Title)
                .HasColumnName("title");

            builder.Property(nt => nt.Body)
                .HasColumnName("body");

            builder.Property(nt => nt.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(nt => nt.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // ------------------------------------------------

            builder.HasOne(fg => fg.NotificationTexts)
                .WithMany(up => up.NotificationTextsDetail)
                .HasForeignKey(fg => fg.NotificationTextId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_notification_text_notification_text_detail");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\OnboardingConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class OnboardingConfiguration : IEntityTypeConfiguration<Onboarding>
    {
        public void Configure(EntityTypeBuilder<Onboarding> entity)
        {
            // Definición de la clave primaria
            entity.HasKey(e => e.Id).HasName("onboarding_pkey");

            // Configuración de la tabla y esquema
            entity.ToTable("onboarding");

            // Índice para el estado de onboarding
            entity.HasIndex(e => e.OnboardStatus).HasDatabaseName("idx_onboardings_status");

            // Configuración de la propiedad OnboardingId con tipo string y tamaño máximo 10
            entity.Property(e => e.Id)
                .HasColumnName("onboarding_id")
                .HasMaxLength(10) // Tamaño máximo de 10 caracteres
                .HasDefaultValueSql("gen_random_uuid()"); // Asignación automática puede ser necesario ajustar según la generación de ID en la aplicación

            // Configuración de la propiedad OnboardStatus
            entity.Property(e => e.OnboardStatus)
                .HasColumnName("onboard_status")
                .HasConversion(
                   v => v.HasValue ? v.ToString() : null,
                   v => v != null ? Enum.Parse<OnboardingStatus>(v) : (OnboardingStatus?)null)
                .IsRequired()
                .HasDefaultValue(OnboardingStatus.Pending);

            // Configuración de las propiedades CreatedAt y UpdatedAt
            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.Property(uf => uf.UserId)
                .HasColumnName("user_id");

            entity.Property(e => e.CampaingId)
                .IsRequired(false)
                .HasColumnName("campaing_id");

            entity.Property(e => e.Referenced)
                .IsRequired(false)
                .HasColumnName("referenced");

            entity.Property(e => e.CostCenter)
                .IsRequired(false)
                .HasColumnName("cost_center");

            entity.Property(e => e.BranchCode)
                .IsRequired(false)
                .HasColumnName("branch_code");

            entity.Property(e => e.OfficialCode)
                .IsRequired(false)
                .HasColumnName("official_code");

            entity.Property(e => e.OfficialName)
                .IsRequired(false)
                .HasColumnName("official_name");

            entity.Property(e => e.SubOfficialCode)
                .IsRequired(false)
                .HasColumnName("sub_official_code");

            entity.Property(e => e.SubOfficialName)
                .IsRequired(false)
                .HasColumnName("sub_official_name");

            // Configuración de la relación con la entidad User
            entity.HasOne(e => e.User)
                .WithOne(u => u.Onboarding)
                .HasForeignKey<Onboarding>(e => e.UserId)
                .HasConstraintName("fk_user_onboardings");

            // Configuración del nuevo campo BankId
            entity.Property(e => e.BankId)
                .HasColumnName("bank_id")
                .HasMaxLength(10); // Tamaño máximo de 10 caracteres

            // Configuración de la relación con la entidad Bank
            entity.HasOne(e => e.Bank)
                .WithMany(b => b.Onboardings)
                .HasForeignKey(e => e.BankId)
                .OnDelete(DeleteBehavior.Restrict)
                .HasConstraintName("fk_onboarding_bank_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\OnboardingHistoryConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class OnboardingHistoryConfiguration : IEntityTypeConfiguration<OnboardingHistory>
    {
        public void Configure(EntityTypeBuilder<OnboardingHistory> entity)
        {
            entity.HasKey(e => e.Id).HasName("history_pkey");

            entity.ToTable("onboarding_history");

            entity.HasIndex(e => e.CreatedAt).HasDatabaseName("created_at_idx");
            entity.HasIndex(e => e.UserId).HasDatabaseName("idx_onboarding_history_user_id");
            entity.HasIndex(e => e.OnboardingId).HasDatabaseName("idx_onboarding_history_onboarding_id");

            entity.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("history_id");

            entity.Property(e => e.ScreenId)
                .HasColumnName("screen_id")
                .HasMaxLength(50)  // Tamaño máximo de 50 caracteres
                .IsRequired(false);  // Permitir nulo si es opcional

            entity.Property(e => e.ScreenData)
                .HasColumnName("screen_data")
                .HasColumnType("jsonb");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.Property(uf => uf.UserId)
                .HasColumnName("user_id");

            entity.Property(uf => uf.OnboardingId)
                .HasColumnName("onboarding_id");

            entity.HasOne(e => e.User)
                .WithMany(u => u.OnboardingHistories)
                .HasForeignKey(e => e.UserId)
                .HasConstraintName("fk_user_onboarding_history");

            entity.HasOne(e => e.Onboarding)
                .WithMany(u => u.OnboardingHistories)
                .HasForeignKey(e => e.OnboardingId)
                .HasConstraintName("fk_onboarding_onboarding_history");

            entity.HasOne(e => e.AppScreen)
                .WithMany(u => u.OnboardingHistories)
                .HasForeignKey(e => e.ScreenId)
                .HasConstraintName("fk_screen_onboarding_history");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\OptionItemConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class OptionItemConfiguration : IEntityTypeConfiguration<OptionItem>
    {
        public void Configure(EntityTypeBuilder<OptionItem> builder)
        {
            // Definición de la clave primaria
            builder.HasKey(e => e.Id).HasName("option_item_pkey");

            // Tabla
            builder.ToTable("option_item", "dxp_app");

            // Id como Guid generado por la DB
            builder.Property(e => e.Id)
                .IsRequired(true)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("option_item_id");

            // Priority
            builder.Property(e => e.Priority)
                .HasColumnName("priority");

            // Name
            builder.Property(e => e.Name)
                .IsRequired()
                .HasMaxLength(60)
                .HasColumnName("name");

            // Label
            builder.Property(e => e.Label)
                .IsRequired()
                .HasMaxLength(60)
                .HasColumnName("label");

            // Icon
            builder.Property(e => e.Icon)
                .IsRequired()
                .HasMaxLength(250)
                .HasColumnName("icon");

            // Type
            builder.Property(e => e.Type)
                .IsRequired()
                .HasColumnName("type");

            // Category
            builder.Property(e => e.Category)
                .IsRequired()
                .HasColumnName("category");

            // RedirectTo
            builder.Property(e => e.RedirectTo)
                .IsRequired(false)
                .HasColumnName("redirect_to");

            // AdditionalData (JSONB)
            builder.Property(e => e.AdditionalData)
                .HasColumnType("jsonb")
                .HasColumnName("additional_data");

            // IsNew
            builder.Property(e => e.IsNew)
                .HasColumnName("is_new")
                .HasDefaultValue(false);

            // IsActive
            builder.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            // InMaintenance
            builder.Property(e => e.InMaintenance)
                .HasColumnName("in_maintenance")
                .HasDefaultValue(false);

            // Propiedades de versionamiento
            builder.Property(e => e.MinVersion)
                .IsRequired(true)
                .HasColumnName("min_version")
                .HasDefaultValue("1.0.0");

            builder.Property(e => e.MaxVersion)
                .IsRequired(false)
                .HasColumnName("max_version");

            // Relación con UiGroup
            builder.Property(e => e.UiGroupId)
                .IsRequired()
                .HasColumnName("ui_group_id");

            builder.HasOne(e => e.UiGroup)
                .WithMany(u => u.OptionItems)
                .HasForeignKey(e => e.UiGroupId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_option_item_ui_group");

            // Timestamps
            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\OtpConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using DXP.Core.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class OtpConfiguration : IEntityTypeConfiguration<Otp>
    {
        public void Configure(EntityTypeBuilder<Otp> builder)
        {
            // Definición de la clave primaria
            builder.HasKey(e => e.Id).HasName("otp_pkey");

            // Configuración de la tabla
            builder.ToTable("otp");

            // Configuración de la propiedad Id
            builder.Property(e => e.Id)
                .HasColumnName("otp_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            // Configuración de la propiedad UserId
            builder.Property(e => e.UserId)
                .HasColumnName("user_id");

            // Configuración de la propiedad BankId con tipo string y tamaño máximo de 10 caracteres
            builder.Property(e => e.BankId)
                .HasColumnName("bank_id")
                .HasMaxLength(10) // Tamaño máximo de 10 caracteres
                .IsRequired(false); // se coloca null para correcciones de foreign key constraint

            // Configuración de la propiedad OtpCode
            builder.Property(e => e.OtpCode)
                .IsRequired()
                .HasMaxLength(10)
                .HasColumnName("otp_code");

            // Configuración de la propiedad OtpType
            builder.Property(e => e.OtpType)
                .IsRequired()
                .HasColumnName("otp_type");

            // Configuración de la propiedad OtpStatus
            builder.Property(e => e.OtpStatus)
                .IsRequired()
                .HasDefaultValue(OtpStatus.Initialized)
                .HasColumnName("otp_status");

            // Configuración de la propiedad ExpiryTime
            builder.Property(e => e.ExpiryTime)
                .HasColumnName("expiry_time");

            // Configuración de la propiedad FailedAttempts
            builder.Property(e => e.FailedAttempts)
                .HasColumnName("failed_attempts")
                .HasDefaultValue(0);

            builder.Property(e => e.ProcessType)
                .HasColumnName("process_type");

            // Configuración de la propiedad CreatedAt
            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            // Configuración de la propiedad UpdatedAt
            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de la relación con la entidad Bank
            builder.HasOne(o => o.Bank)
                .WithMany(b => b.Otps)
                .HasForeignKey(o => o.BankId)
                .OnDelete(DeleteBehavior.Restrict)
                .HasConstraintName("otp_bank_id_fkey");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\ProfileAddressConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class ProfileAddressConfiguration : IEntityTypeConfiguration<ProfileAddress>
    {
        public void Configure(EntityTypeBuilder<ProfileAddress> builder)
        {
            builder.HasKey(e => e.Id).HasName("profile_address_pkey");

            builder.ToTable("profile_address");

            builder.Property(e => e.Id)
                .HasColumnName("profile_address_id")
                .ValueGeneratedOnAdd()
                .HasIdentityOptions(startValue: 1);

            builder.Property(e => e.AddressType)
                .IsRequired()
                .HasColumnName("address_type")
                .HasDefaultValue(AddressType.OtherType);

            builder.Property(e => e.Address)
                .IsRequired()
                .HasMaxLength(200)
                .HasColumnName("address");

            builder.Property(e => e.ProfileId)
                .IsRequired()
                .HasColumnName("profile_id");

            builder.Property(e => e.Alias)
                .HasMaxLength(25)
                .HasColumnName("alias");

            builder.Property(e => e.GeographicalLocation)
                .HasColumnName("geographical_location");

            builder.Property(e => e.Latitude)
                .HasColumnName("latitude");

            builder.Property(e => e.Longitude)
                .HasColumnName("longitude");

            builder.Property(e => e.IsActive)
                .IsRequired()
                .HasColumnName("is_active");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(e => e.UserProfile)
                .WithMany(e => e.ProfileAdresses)
                .HasForeignKey(e => e.ProfileId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_profile_address_user_profile")
                .IsRequired(true);
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\QuickActionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class QuickActionConfiguration : IEntityTypeConfiguration<QuickAction>
    {
        public void Configure(EntityTypeBuilder<QuickAction> entity)
        {
            entity.HasKey(e => e.Id).HasName("quick_action_pkey");

            entity.ToTable("quick_action", "dxp_app");

            entity.Property(e => e.Id)
                .IsRequired(true)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("quick_action_id");

            entity.Property(e => e.Name)
                .IsRequired(true)
                .HasMaxLength(60)
                .HasColumnName("name");

            entity.Property(e => e.Priority)
                .IsRequired(false)
                .HasColumnName("priority");

            entity.Property(e => e.Description)
                .IsRequired(true)
                .HasMaxLength(60)
                .HasColumnName("description");

            entity.Property(e => e.Icon)
                .IsRequired(true)
                .HasMaxLength(250)
                .HasColumnName("icon");

            entity.Property(e => e.Type)
                .IsRequired(true)
                .HasColumnName("type");

            entity.Property(e => e.Category)
                .IsRequired(true)
                .HasColumnName("category");

            entity.Property(e => e.BankId)
                .IsRequired(true)
                .HasMaxLength(4)
                .HasColumnName("bank_id");

            entity.Property(e => e.RedirectTo)
                .IsRequired(false)
                .HasMaxLength(150)
                .HasColumnName("redirect_to");

            entity.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            entity.Property(e => e.IsNew)
                .HasDefaultValue(false)
                .HasColumnName("is_new");

            entity.Property(e => e.InMaintenance)
                .HasDefaultValue(false)
                .HasColumnName("in_maintenance");

            entity.Property(e => e.AdditionalData)
                .IsRequired(false)
                .HasMaxLength(1500)
                .HasColumnName("additional_data");

            // Propiedades de versionamiento
            entity.Property(e => e.MinVersion)
                .IsRequired(true)
                .HasColumnName("min_version")
                .HasDefaultValue("1.0.0");

            entity.Property(e => e.MaxVersion)
                .IsRequired(false)
                .HasColumnName("max_version");

            // Propiedades de auditoría
            entity.Property(e => e.CreatedAt)
                 .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                 .IsRequired(true)
                 .HasColumnType("timestamp with time zone")
                 .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.HasIndex(e => e.Name)
                .HasDatabaseName("ix_quick_action_name");

            entity.HasIndex(e => e.BankId)
                .HasDatabaseName("ix_quick_action_bank_id");

            entity.HasIndex(e => e.IsActive)
                .HasDatabaseName("ix_quick_action_is_active");

            entity.HasIndex(e => new { e.Type, e.Category })
                .HasDatabaseName("ix_quick_action_type_and_category");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TermsAndConditionsConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class TermsAndConditionsConfiguration : IEntityTypeConfiguration<TermsAndConditions>
    {
        public void Configure(EntityTypeBuilder<TermsAndConditions> builder)
        {
            builder.HasKey(e => e.Id).HasName("terms_and_conditions_pkey");

            builder.ToTable("terms_and_conditions");

            builder.Property(e => e.Id)
                .HasColumnName("terms_and_condition_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.Name)
                .HasColumnName("name");

            builder.Property(e => e.IsActive)
                .HasColumnName("is_active");

            builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TransactionConfiguration.cs
```csharp
using System.Reflection.Emit;
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TransactionConfiguration : IEntityTypeConfiguration<Transaction>
{
    public void Configure(EntityTypeBuilder<Transaction> builder)
    {
        builder.HasKey(e => e.Id).HasName("transaction_pkey");

        builder.ToTable("transaction");

        builder.Property(e => e.Id)
            .HasColumnName("transaction_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserProfileId)
            .HasColumnName("user_profile_id");

        builder.Property(e => e.TransactionType)
            .HasColumnName("transaction_type")
            .IsRequired();

        builder.Property(e => e.TransactionDomainId)
            .HasColumnName("transaction_domain_id")
            .IsRequired(false);

        builder.Property(e => e.TransactionStatus)
            .HasColumnName("transaction_status")
            .IsRequired()
            .HasDefaultValue(TransactionStatus.Validated);

        builder.Property(e => e.TransactionSubStatus)
            .HasColumnName("transaction_sub_status")
            .IsRequired()
            .HasDefaultValue(TransactionSubStatus.Completed);

        builder.Property(e => e.DebitProductNumber)
            .HasColumnName("debit_product_number")
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(e => e.OriginCountryId)
            .HasColumnName("origin_country_id")
            .IsRequired();

        builder.Property(e => e.DestinationCountryId)
            .HasColumnName("destination_country_id")
            .IsRequired();

        builder.Property(e => e.DestinationProductHolder)
            .HasColumnName("destination_product_holder")
            .HasMaxLength(250);

        builder.Property(e => e.AdditionalData)
            .HasColumnName("additional_data")
            .HasColumnType("jsonb");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.UserProfile)
            .WithMany(u => u.Transactions)
            .HasForeignKey(nc => nc.UserProfileId)
            .HasConstraintName("fk_transaction_user_profile");

        builder.HasOne(nc => nc.OriginCountry)
            .WithMany(u => u.TransactionOriginCountries)
            .HasForeignKey(nc => nc.OriginCountryId)
            .HasConstraintName("fk_transaction_bank_originBank");

        builder.HasOne(nc => nc.DestinationCountry)
            .WithMany(u => u.TransactionDestinationCountries)
            .HasForeignKey(nc => nc.DestinationCountryId)
            .HasConstraintName("fk_transaction_bank_destinationBank");

        builder.HasIndex(t => t.UserProfileId)
            .HasDatabaseName("IX_transaction_user_profile_id");

        builder.HasIndex(t => new
        {
            t.UserProfileId,
            t.TransactionType,
            t.TransactionStatus,
            t.CreatedAt
        })
        .HasDatabaseName("IX_transaction_user_profile_id_type_status_created_at");

        // builder.HasIndex(t => t.AdditionalData)
        //     .HasDatabaseName("ix_transaction_additional_data")
        //     .HasMethod("hash"); // ❌ EF no soporta esto, debe ser SQL puro en migración
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TransferMethodConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TransferMethodConfiguration : IEntityTypeConfiguration<TransferMethod>
{
    public void Configure(EntityTypeBuilder<TransferMethod> builder)
    {
        builder.HasKey(e => e.Id).HasName("transfer_method_pkey");

        builder.ToTable("transfer_method");

        builder.Property(e => e.Id)
            .HasColumnName("transfer_method_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.BankId)
            .HasColumnName("bank_id");

        builder.Property(e => e.Description)
            .HasColumnName("description")
            .HasMaxLength(100);

        builder.Property(e => e.Name)
            .HasColumnName("name")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(e => e.IsActive)
            .HasColumnName("is_active")
            .HasDefaultValue(true);

        builder.Property(e => e.Icon)
            .HasColumnName("icon");

        builder.Property(e => e.TransactionDomainId)
            .HasColumnName("transaction_domain_id")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
            .HasColumnType("timestamp with time zone")
            .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.Bank)
            .WithMany(u => u.TransferMethods)
            .HasForeignKey(nc => nc.BankId)
            .HasConstraintName("fk_transfer_method_bank");
    }
}


```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TransferMethodCurrencyConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TransferMethodCurrencyConfiguration : IEntityTypeConfiguration<TransferMethodCurrency>
{
    public void Configure(EntityTypeBuilder<TransferMethodCurrency> builder)
    {
        builder.HasKey(e => e.Id).HasName("transfer_method_currency_pkey");

        builder.ToTable("transfer_method_currency");

        builder.Property(e => e.Id)
            .HasColumnName("transfer_method_currency_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.TransferMethodId)
            .HasColumnName("transfer_method_id");

        builder.Property(e => e.SourceCurrency)
            .HasColumnName("source_currency")
            .HasMaxLength(3)
            .IsRequired();

        builder.Property(e => e.DestinationCurrency)
            .HasColumnName("destination_currency")
            .HasMaxLength(3)
            .IsRequired();

        builder.Property(e => e.IsActive)
            .HasColumnName("is_active")
            .HasDefaultValue(true);

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.TransferMethod)
            .WithMany(u => u.TransferMethodCurrencies)
            .HasForeignKey(nc => nc.TransferMethodId)
            .HasConstraintName("fk_transfer_method_currency_transfer_method");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TransferMethodProductTypeConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TransferMethodProductTypeConfiguration : IEntityTypeConfiguration<TransferMethodProductType>
{
    public void Configure(EntityTypeBuilder<TransferMethodProductType> builder)
    {
        builder.HasKey(e => e.Id).HasName("transfer_method_product_type_pkey");

        builder.ToTable("transfer_method_product_type");

        builder.Property(e => e.Id)
            .HasColumnName("transfer_method_product_type_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.TransferMethodId)
            .HasColumnName("transfer_method_id");

        builder.Property(e => e.LocalBankProductType)
            .HasColumnName("local_bank_product_type")
            .IsRequired();

        builder.Property(e => e.IsActive)
            .HasColumnName("is_active")
            .HasDefaultValue(true);

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.TransferMethod)
            .WithMany(u => u.TransferMethodProductTypes)
            .HasForeignKey(nc => nc.TransferMethodId)
            .HasConstraintName("fk_transfer_method_product_type_transfer_method");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TutorialActionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TutorialActionConfiguration : IEntityTypeConfiguration<TutorialAction>
{
    public void Configure(EntityTypeBuilder<TutorialAction> builder)
    {
        builder.HasKey(e => e.Id).HasName("tutorial_action_pkey");

        builder.ToTable("tutorial_action");

        builder.Property(e => e.Id)
            .HasColumnName("tutorial_action_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.Step)
            .IsRequired()
            .HasColumnName("step");

        builder.Property(e => e.AppScreenId)
            .IsRequired()
            .HasColumnName("app_screen_id");

        builder.Property(e => e.ActionId)
            .IsRequired()
            .HasColumnName("action_id");

        builder.Property(e => e.TutorialDescription)
            .HasColumnName("tutorial_description");

        builder.Property(e => e.RedirectionBehavior)
            .IsRequired()
            .HasColumnName("redirection_behavior");

        builder.Property(e => e.BankId)
            .IsRequired()
            .HasColumnName("bank_id");

        builder.Property(x => x.IsActive)
            .IsRequired()
            .HasColumnName("is_active")
            .HasDefaultValue(true);

        builder.HasOne(x => x.Bank)
            .WithMany(m => m.TutorialActions)
            .HasForeignKey(fk => fk.BankId)
            .OnDelete(DeleteBehavior.Cascade)
            .HasConstraintName("tutorial_actions_bank_fkey");

        builder.HasOne(x => x.AppScreen)
            .WithMany(m => m.TutorialActions)
            .HasForeignKey(fk => fk.AppScreenId)
            .OnDelete(DeleteBehavior.Cascade)
            .HasConstraintName("tutorial_actions_app_screen_fkey");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(e => e.DeletedAt)
            .HasColumnType("timestamp with time zone")
            .HasColumnName("deleted_at");

        builder.HasIndex(e => new { e.Step, e.AppScreenId, e.ActionId, e.BankId })
            .IsUnique()
            .HasDatabaseName("ux_tutorial_action_step_screen_action_bank");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TutorialProgressConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class TutorialProgressConfiguration : IEntityTypeConfiguration<TutorialProgress>
{
    public void Configure(EntityTypeBuilder<TutorialProgress> builder)
    {
        builder.HasKey(e => e.Id).HasName("tutorial_progress_pkey");

        builder.ToTable("tutorial_progress");

        builder.Property(e => e.Id)
            .HasColumnName("tutorial_progress_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserProfileId)
            .IsRequired()
            .HasColumnName("user_id");

        builder.Property(e => e.Step)
            .IsRequired()
            .HasColumnName("step");

        builder.Property(e => e.ScreenId)
            .IsRequired()
            .HasColumnName("screen_id");

        builder.Property(e => e.ActionId)
            .IsRequired()
            .HasColumnName("action_id");

        builder.Property(e => e.TutorialDescription)
            .HasColumnName("tutorial_description");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(e => e.DeletedAt)
            .HasColumnType("timestamp with time zone")
            .HasColumnName("deleted_at");

        builder.HasOne(e => e.UserProfile)
            .WithMany(e => e.TutorialProgress)
            .HasForeignKey(e => e.UserProfileId)
            .HasConstraintName("fk_tutorial_progress_user_profile");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\TutorialsConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class TutorialsConfiguration : IEntityTypeConfiguration<Tutorials>
    {
        public void Configure(EntityTypeBuilder<Tutorials> builder)
        {
            // pk
            builder.HasKey(x => x.Id).HasName("tutorials_pkey");

            // table
            builder.ToTable("tutorials");

            // properties
            builder.Property(x => x.Id)
                .HasColumnName("tutorials_id")
                .ValueGeneratedOnAdd();

            builder.Property(x => x.Title)
                .HasColumnName("title")
                .IsRequired();

            builder.Property(x => x.Category)
                .HasColumnName("category")
                .IsRequired()
                .HasDefaultValue(TutorialCategory.Others);

            builder.Property(x => x.TutorialUrl)
                .HasColumnName("tutorial_url")
                .IsRequired();

            builder.Property(x => x.ThumbnailUrl)
                .HasColumnName("thumbnail_url");

            builder.Property(x => x.Duration)
                .HasColumnName("duration");

            builder.Property(x => x.TutorialBankId)
                .HasColumnName("tutorial_bank_id");

            builder.Property(x => x.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            builder.Property(x => x.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(x => x.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UiGroupConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UiGroupConfigurations : IEntityTypeConfiguration<UiGroup>
    {
        public void Configure(EntityTypeBuilder<UiGroup> builder)
        {
            // Key primaria
            builder.HasKey(e => e.Id).HasName("ui_group_pkey");

            // Tabla
            builder.ToTable("ui_group");

            // Id con identidad
            builder.Property(e => e.Id)
                .IsRequired(true)
                .HasColumnName("ui_group_id")
                .ValueGeneratedOnAdd()
                .HasIdentityOptions(startValue: 1);

            // Nombre
            builder.Property(e => e.Name)
                .IsRequired()
                .HasMaxLength(60)
                .HasColumnName("name");

            // Label
            builder.Property(e => e.Label)
                .IsRequired()
                .HasMaxLength(60)
                .HasColumnName("label");

            // Tipo de agrupador
            builder.Property(e => e.Type)
                .IsRequired()
                .HasColumnName("type");

            // IsActive
            builder.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            // AppScreenId
            builder.Property(e => e.AppScreenId)
                .IsRequired()
                .HasColumnName("app_screen_id");

            builder.HasOne(e => e.AppScreen)
                .WithMany(e => e.UiGroups)
                .HasForeignKey(e => e.AppScreenId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_ui_group_app_screen");

            // BankId
            builder.Property(e => e.BankId)
                .IsRequired()
                .HasColumnName("bank_id");

            builder.HasOne(e => e.Bank)
                .WithMany(e => e.UiGroups)
                .HasForeignKey(e => e.BankId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_ui_group_bank");

            // Timestamps
            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserConditionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserConditionConfiguration : IEntityTypeConfiguration<UserCondition>
    {
        public void Configure(EntityTypeBuilder<UserCondition> builder)
        {
            builder.HasKey(e => e.Id).HasName("user_condition_pkey");

            builder.ToTable("user_condition");

            builder.Property(e => e.Id)
                .HasColumnName("user_condition_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.Condition)
                .HasColumnName("condition");

            builder.Property(e => e.SubCondition)
                .HasColumnName("sub_condition");

            builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(e => e.UserProfile)
            .WithMany(e => e.UserConditions)
            .HasForeignKey(e => e.UserProfileId)
            .HasConstraintName("fk_user_condition_user_profile");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> entity)
        {
            entity.HasKey(e => e.Id).HasName("user_pkey");

            entity.ToTable("user");

            entity.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_id");

            entity.Property(e => e.Auth0UserId)
                .IsRequired()
                .HasMaxLength(5000)
                .HasColumnName("auth0_user_id");

            entity.Property(e => e.UserStatus)
             .HasColumnName("user_status")
             .HasConversion(
                   v => v.HasValue ? v.ToString() : null,
                   v => v != null ? Enum.Parse<UserStatus>(v) : (UserStatus?)null)
             .IsRequired()
             .HasDefaultValue(UserStatus.Created);

            entity.Property(e => e.HasNotificationEnabled)
                .IsRequired()
                .HasColumnName("has_notification_enabled")
                .HasDefaultValue(false);

            entity.Property(e => e.Username)
                .HasColumnName("username");

            entity.Property(e => e.UserFullName)
                .HasColumnName("user_full_name")
                .HasMaxLength(255);  // Adjust length as needed

            entity.Property(e => e.PeopleId)
                .HasColumnName("people_id")
                .HasMaxLength(64);

            entity.Property(e => e.Sex)
                .HasColumnName("sex")
                .HasMaxLength(10);

            entity.Property(e => e.ProfilePictureKey)
                .HasColumnName("profile_picture_key")
                .HasMaxLength(300);

            entity.Property(e => e.HasAcceptedTerms)
                .IsRequired()
                .HasColumnName("has_accepted_terms")
                .HasDefaultValue(false);

            entity.Property(e => e.IsExistingCustomer)
                .IsRequired()
                .HasColumnName("is_existing_customer")
                .HasDefaultValue(false);

            entity.Property(e => e.ShowAmount)
                .HasDefaultValue(true)
                .HasColumnName("show_amount");

            entity.Property(e => e.Language)
                .HasColumnName("language")
                .HasMaxLength(2);

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .IsRequired()
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            entity.HasOne(p => p.Bank)
                .WithMany(p => p.Users)
                .HasForeignKey(p => p.LastUserBankId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_last_user_bank_id");

            entity.Property(e => e.ShortName)
                .HasColumnName("short_name")
                .IsRequired(false);

            entity.Property(e => e.AuthenticationMethod)
                .HasColumnName("authentication_method")
                .IsRequired(false);

            entity.Property(e => e.BirthDate)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("birth_date");

            entity.Property(e => e.IsGenericUser)
                .HasColumnName("is_generic_user")
                .HasDefaultValue(false);

            entity.Property(e => e.LastUserBankId)
                .HasColumnName("last_user_bank_id")
                .IsRequired(false);

            // Configura el índice en Auth0UserId
            entity.HasIndex(e => new { e.Auth0UserId, e.UserStatus })
                .HasDatabaseName("ix_users_auth0_user_id_status");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserFailedAttemptConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class UserFailedAttemptConfiguration : IEntityTypeConfiguration<UserFailedAttempt>
{
    public void Configure(EntityTypeBuilder<UserFailedAttempt> builder)
    {
        builder.HasKey(e => e.Id).HasName("user_failed_attempt_pkey");

        builder.ToTable("user_failed_attempt");

        builder.Property(e => e.Id)
            .HasColumnName("user_failed_attempt_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserId)
            .HasColumnName("user_id")
            .IsRequired();

        builder.Property(e => e.AttemptNumber)
            .HasColumnName("attempt_number")
            .HasDefaultValue(1)
            .IsRequired();

        builder.Property(e => e.LastAttemptAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("last_attempt_at");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(fa => fa.User)
            .WithOne(u => u.UserFailedAttempt)
            .HasForeignKey<UserFailedAttempt>(fa => fa.UserId)
            .HasConstraintName("fk_user_failed_atttempt_user_profile");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserFavoriteFunctionalityConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserFavoriteFunctionalityConfiguration : IEntityTypeConfiguration<UserFavoriteFunctionality>
    {
        public void Configure(EntityTypeBuilder<UserFavoriteFunctionality> builder)
        {
            builder.HasKey(e => e.Id).HasName("user_favorite_functionality_pkey");

            builder.ToTable("user_favorite_functionality");

            builder.Property(e => e.Id)
                .HasColumnName("favorite_id")
                .ValueGeneratedOnAdd();

            builder.Property(e => e.UserId)
                .IsRequired()
                .HasColumnName("user_id");

            builder.Property(e => e.FunctionalityId)
                .IsRequired()
                .HasColumnName("functionality_id");

            builder.Property(e => e.Status)
                .IsRequired()
                .HasMaxLength(50)
                .HasDefaultValue("Active")
                .HasColumnName("status");

            builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasOne(e => e.User)
                .WithMany(u => u.UserFavoriteFunctionalities)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_favorite_user");

            builder.HasIndex(e => e.UserId).HasDatabaseName("idx_user_favorite_functionality_user_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserFeatureStateConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class UserFeatureStateConfiguration : IEntityTypeConfiguration<UserFeatureState>
{
    public void Configure(EntityTypeBuilder<UserFeatureState> builder)
    {
        builder.ToTable("user_feature_state");

        builder.HasKey(e => e.Id).HasName("user_feature_state_pkey");

        builder.Property(e => e.Id)
            .HasColumnName("user_feature_state_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserProfileId)
            .HasColumnName("user_profile_id");

        builder.Property(e => e.ReferenceKey)
            .HasColumnName("reference_key");

        builder.Property(e => e.Category)
            .HasColumnName("category")
            .IsRequired();

        builder.Property(e => e.Data)
            .HasColumnName("data")
            .HasColumnType("jsonb");

        builder.Property(e => e.Status)
            .HasColumnName("status");

        builder.Property(e => e.NextShowAt)
            .HasColumnType("timestamp with time zone")
            .HasColumnName("next_show_at");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(e => e.UserProfile)
            .WithMany(u => u.UserFeatureStates)
            .HasForeignKey(fk => fk.UserProfileId)
            .HasConstraintName("fk_user_request_user_profile");

        builder.HasIndex(e => new { e.UserProfileId, e.Category, e.ReferenceKey })
            .HasDatabaseName("ix_user_feture_state_profiles_category_reference");

        builder.HasIndex(e => new { e.UserProfileId, e.Category })
            .HasDatabaseName("ix_user_feture_state_profiles_category");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserFunctionalityConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserFunctionalityConfiguration : IEntityTypeConfiguration<UserFunctionality>
    {
        public void Configure(EntityTypeBuilder<UserFunctionality> builder)
        {
            // Configuración de la clave primaria
            builder.HasKey(uf => uf.Id)
                .HasName("user_functionality_pkey");

            // Configuración de la tabla
            builder.ToTable("user_functionality");

            // Configuración de los índices
            builder.HasIndex(uf => new { uf.ProfileId, uf.FunctionalityId })
                .IsUnique()
                .HasDatabaseName("idx_user_functionality_profile_functionality");

            builder.HasIndex(uf => uf.IsActive)
                .HasDatabaseName("idx_user_functionality_is_active");

            // Configuración de las propiedades
            builder.Property(uf => uf.Id)
                .HasColumnName("user_functionality_id")
                .ValueGeneratedOnAdd(); // Para columnas SERIAL en PostgreSQL

            builder.Property(uf => uf.ProfileId)
                .IsRequired(false)
                .HasColumnName("profile_id");

            builder.Property(uf => uf.FunctionalityId)
                .HasColumnName("functionality_id");

            builder.Property(uf => uf.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(uf => uf.AssignedDate)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("assigned_date");

            builder.Property(e => e.CreatedAt)
                 .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                 .IsRequired()
                 .HasColumnType("timestamp with time zone")
                 .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones
            builder.HasOne(uf => uf.Profile)
                .WithMany(p => p.UserFunctionalities)
                .HasForeignKey(uf => uf.ProfileId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_functionality_profile_id");

            builder.HasOne(uf => uf.Functionality)
                .WithMany(f => f.UserFunctionalities)
                .HasForeignKey(uf => uf.FunctionalityId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_functionality_functionality_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserOptionItemConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserOptionItemConfiguration : IEntityTypeConfiguration<UserOptionItem>
    {
        public void Configure(EntityTypeBuilder<UserOptionItem> builder)
        {
            // Clave primaria
            builder.HasKey(e => e.Id).HasName("user_option_item_pkey");

            // Tabla
            builder.ToTable("user_option_item", "dxp_app");

            // Id como Guid generado por la DB
            builder.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_option_item_id");

            // OptionItemId
            builder.Property(e => e.OptionItemId)
                .IsRequired()
                .HasColumnName("option_item_id");

            builder.HasOne(e => e.OptionItem)
                .WithMany(e => e.UserOptionItems)
                .HasForeignKey(e => e.OptionItemId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_option_item_option");

            // UserProfileId
            builder.Property(e => e.UserProfileId)
                .IsRequired()
                .HasColumnName("user_profile_id");

            builder.HasOne(e => e.UserProfile)
                .WithMany(e => e.UserOptionItems)
                .HasForeignKey(e => e.UserProfileId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_option_item_user_profile");

            // IsActive
            builder.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);

            // IsManuallyDisabled
            builder.Property(e => e.IsManuallyDisabled)
                .HasColumnName("is_manually_disabled")
                .HasDefaultValue(false);

            // Priority
            builder.Property(e => e.Priority)
                .IsRequired()
                .HasColumnName("priority");

            // Timestamps
            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserProductConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserProductConfiguration : IEntityTypeConfiguration<UserProduct>
    {
        public void Configure(EntityTypeBuilder<UserProduct> builder)
        {
            // Definición de la llave primaria
            builder.HasKey(e => e.Id).HasName("user_product_pkey");

            // Configuración de la tabla y esquema
            builder.ToTable("user_product", "dxp_app");

            // Configuración de las propiedades de la entidad UserProduct
            builder.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_product_id");

            builder.Property(e => e.ProfileId)
                .IsRequired()
                .HasColumnName("profile_id");

            builder.Property(e => e.ProductType)
                .IsRequired()
                .HasColumnName("product_type");

            builder.Property(e => e.ProductNumber)
                .IsRequired()
                .HasMaxLength(50)
                .HasColumnName("product_number");

            builder.Property(e => e.ProductCodeType)
                .IsRequired()
                .HasMaxLength(20)
                .HasColumnName("product_code_type");

            builder.Property(e => e.Alias)
                .IsRequired()
                .HasMaxLength(255)
                .HasColumnName("product_alias");

            builder.Property(e => e.IsActive)
                .IsRequired()
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(e => e.HasCreditMovements)
                .IsRequired()
                .HasDefaultValue(false)
                .HasColumnName("has_credit_movements");

            builder.Property(e => e.ImageUrl)
                .IsRequired()
                .HasMaxLength(1000)
                .HasColumnName("product_image_url");

            builder.Property(e => e.CardSubStatus)
            .HasDefaultValue(null)
            .HasColumnName("card_sub_status");

            builder.Property(e => e.QrFileName)
            .HasDefaultValue(null)
            .HasColumnName("qr_file_name");

            builder.Property(e => e.IsFavorite)
                .IsRequired()
                .HasDefaultValue(false)
                .HasColumnName("is_favorite_product");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones
            builder.HasOne(p => p.UserProfile)
                .WithMany(u => u.UserProducts)
                .HasForeignKey(p => p.ProfileId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_product_profile_id");

            // Product Number
            builder.HasIndex(p => p.ProductNumber)
                .HasDatabaseName("ix_user_products_product_number");

            // Product Type
            builder.HasIndex(p => p.ProductType)
                .HasDatabaseName("ix_user_products_product_type");

            // Is Favorite
            builder.HasIndex(p => p.IsFavorite)
                .HasDatabaseName("ix_user_products_is_favorite_product");

            // Profile Id
            builder.HasIndex(p => p.ProfileId)
                .HasDatabaseName("ix_user_products_profile_id");

            // Product Number and Profile Id
            builder.HasIndex(p => new { p.ProductNumber, p.ProfileId })
                .HasDatabaseName("ix_user_products_product_number_profile_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserProfileConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserProfileConfiguration : IEntityTypeConfiguration<UserProfile>
    {
        public void Configure(EntityTypeBuilder<UserProfile> builder)
        {
            // Definición de la clave primaria
            builder.HasKey(e => e.Id).HasName("user_profile_pkey");

            // Configuración de la tabla y esquema
            builder.ToTable("user_profile", "dxp_app");

            // Configuración de las propiedades de la entidad UserProfile
            builder.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_profile_id");

            builder.Property(e => e.UserId)
                .HasColumnName("user_id");

            builder.Property(e => e.DocumentType)
                .IsRequired()
                .HasMaxLength(50)
                .HasColumnName("document_type");

            builder.Property(e => e.DocumentNumber)
                .IsRequired()
                .HasMaxLength(50)
                .HasColumnName("document_number");

            builder.Property(e => e.CountryCode)
                .HasMaxLength(5) // Asumimos que el código del país es de 2 a 5 caracteres
                .HasColumnName("country_code");

            builder.Property(e => e.PhoneNumber)
                .HasMaxLength(20)
                .HasColumnName("phone_number");

            builder.Property(e => e.PhonePrefix)
                .HasMaxLength(5)
                .HasColumnName("phone_prefix");

            builder.Property(e => e.Email)
                .HasMaxLength(150)
                .HasColumnName("email");

            builder.Property(e => e.CIF)
                .HasMaxLength(50)
                .HasColumnName("cif");

            builder.Property(e => e.BankID)
                .IsRequired(false)
                .HasMaxLength(50)
                .HasColumnName("bank_id");

            builder.Property(e => e.IsActive)
                .IsRequired()
                .HasColumnName("is_active");

            // Propiedades de auditoría
            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones con las entidades User y Bank
            builder.HasOne(p => p.User)
                .WithMany(u => u.UserProfiles)
                .HasForeignKey(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_profile_user_id");

            builder.HasOne(p => p.Bank)
                .WithMany(b => b.UserProfiles)
                .HasForeignKey(p => p.BankID)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_profile_bank_id");

            // Índice en DocumentType, DocumentNumber, BankID e IsActive
            builder.HasIndex(p => new { p.DocumentType, p.DocumentNumber, p.BankID, p.IsActive })
                .HasDatabaseName("ix_user_profiles_document_type_document_number_bank_id_is_active");

            // Índice en UserId, BankID e IsActive
            builder.HasIndex(p => new { p.UserId, p.BankID, p.IsActive })
                .HasDatabaseName("ix_user_profiles_user_id_bank_id_is_active");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserQuickActionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserQuickActionConfiguration : IEntityTypeConfiguration<UserQuickAction>
    {
        public void Configure(EntityTypeBuilder<UserQuickAction> entity)
        {
            // Configuración de la clave primaria
            entity.HasKey(e => e.Id)
                .HasName("user_quick_action_pkey");

            // Configuración de la tabla
            entity.ToTable("user_quick_action", "dxp_app");

            // Configuración de los índices
            entity.HasIndex(e => new { e.UserProfileId, e.QuickActionId })
                .HasDatabaseName("ix_user_quick_action_profile_quick_action");

            entity.HasIndex(e => e.IsActive)
                .HasDatabaseName("ix_user_quick_action_is_active");

            // Configuración de las Propiedades
            entity.Property(e => e.Id)
                .IsRequired(true)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_quick_action_id");

            entity.Property(e => e.UserProfileId)
                .IsRequired(true)
                .HasColumnName("user_profile_id");

            entity.Property(e => e.QuickActionId)
                .IsRequired(true)
                .HasColumnName("quick_action_id");

            entity.Property(e => e.IsActive)
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            entity.Property(e => e.Order)
                .IsRequired(true)
                .HasColumnName("order");

            entity.Property(e => e.CreatedAt)
                 .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                 .IsRequired(true)
                 .HasColumnType("timestamp with time zone")
                 .HasColumnName("created_at");

            entity.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            entity.Property(e => e.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            // Configuración de las relaciones
            entity.HasOne(e => e.UserProfile)
                .WithMany(up => up.UserQuickActions)
                .HasForeignKey(e => e.UserProfileId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_quick_action_profile_id");

            entity.HasOne(e => e.QuickAction)
                .WithMany(qa => qa.UserQuickActions)
                .HasForeignKey(e => e.QuickActionId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_quick_action_quick_action_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserRequestConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using DXP.Core.Database.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class UserRequestConfiguration : IEntityTypeConfiguration<UserRequest>
{
    public void Configure(EntityTypeBuilder<UserRequest> builder)
    {
        builder.HasKey(e => e.Id).HasName("user_request_pkey");

        builder.ToTable("user_request");

        builder.Property(e => e.Id)
            .HasColumnName("user_request_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserProfileId)
            .HasColumnName("user_profile_id");

        builder.Property(e => e.Type)
            .HasColumnName("type")
            .IsRequired();

        builder.Property(e => e.SubType)
            .HasColumnName("sub_type");

        builder.Property(e => e.SubTypeProduct)
            .HasColumnName("sub_type_product");

        builder.Property(e => e.Data)
            .HasColumnName("data")
            .HasColumnType("jsonb")
            .IsRequired();

        builder.Property(e => e.Status)
            .HasColumnName("status")
            .IsRequired()
            .HasDefaultValue(RequestStatus.Initialized);

        builder.Property(e => e.ExternalRequestId)
            .HasColumnName("external_request_id");

        builder.Property(e => e.ErrorCode)
            .HasColumnName("error_code");

        builder.Property(e => e.ErrorMessage)
            .HasColumnName("error_message");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

        builder.HasOne(nc => nc.UserProfile)
            .WithMany(u => u.UserRequests)
            .HasForeignKey(nc => nc.UserProfileId)
            .HasConstraintName("fk_user_request_user_profile");

        // Índice en ExternalRequestId
        builder.HasIndex(e => e.ExternalRequestId)
            .HasDatabaseName("ix_external_request_id");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserSubProductConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserSubProductConfiguration : IEntityTypeConfiguration<UserSubProduct>
    {
        public void Configure(EntityTypeBuilder<UserSubProduct> builder)
        {
            // Definición de la llave primaria
            builder.HasKey(e => e.Id).HasName("user_sub_product_pkey");

            // Configuración de la tabla y esquema
            builder.ToTable("user_sub_product", "dxp_app");

            // Configuración de las propiedades de la entidad UserProduct
            builder.Property(e => e.Id)
                .HasDefaultValueSql("gen_random_uuid()")
                .HasColumnName("user_sub_product_id");

            builder.Property(e => e.ProductId)
                .HasColumnName("product_id");

            builder.Property(e => e.SubProductType)
                .IsRequired()
                .HasColumnName("sub_product_type");

            builder.Property(e => e.SubProductNumber)
                .IsRequired()
                .HasMaxLength(50)
                .HasColumnName("sub_product_number");

            builder.Property(e => e.SubProductCodeType)
                .IsRequired()
                .HasMaxLength(20)
                .HasColumnName("sub_product_code_type");

            builder.Property(e => e.IsActive)
                .IsRequired()
                .HasDefaultValue(true)
                .HasColumnName("is_active");

            builder.Property(e => e.CardDeliveryStatus)
                .HasDefaultValue(null)
                .HasColumnName("card_delivery_status");

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");

            builder.HasIndex(f => f.SubProductNumber)
                .HasDatabaseName("ix_user_sub_product_sub_product_number");

            builder.HasIndex(f => new { f.SubProductNumber, f.ProductId })
                .HasDatabaseName("ix_user_sub_product_sub_product_number_product_id");

            // Configuración de las relaciones
            builder.HasOne(p => p.UserProduct)
                .WithMany(u => u.UserSubProducts)
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_sub_product_product_id");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserTransactionConditionConfiguration.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities;

public class UserTransactionConditionConfiguration : IEntityTypeConfiguration<UserTransactionCondition>
{
    public void Configure(EntityTypeBuilder<UserTransactionCondition> builder)
    {
        builder.HasKey(e => e.Id).HasName("user_transaction_condition_pkey");

        builder.ToTable("user_transaction_condition");

        builder.Property(e => e.Id)
            .HasColumnName("user_transaction_condition_id")
            .ValueGeneratedOnAdd();

        builder.Property(e => e.UserProfileId)
            .IsRequired()
            .HasColumnName("user_profile_id");

        builder.Property(e => e.TransactionType)
            .IsRequired()
            .HasColumnName("transaction_type");

        builder.Property(e => e.TransactionSubType)
            .IsRequired(false)
            .HasColumnName("transaction_sub_type");

        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("created_at");

        builder.Property(e => e.UpdatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
            .HasColumnType("timestamp with time zone")
            .HasColumnName("updated_at");

        builder.Property(f => f.DeletedAt)
            .HasColumnType("timestamp with time zone")
            .HasColumnName("deleted_at");

        builder.HasOne(e => e.UserProfile)
            .WithMany(e => e.UserTransactionConditions)
            .HasForeignKey(e => e.UserProfileId)
            .HasConstraintName("fk_user_transaction_condition_user_profile");
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Entities\UserTutorialsConfigurations.cs
```csharp
using DXP.Core.Database.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Entities
{
    public class UserTutorialsConfigurations : IEntityTypeConfiguration<UserTutorials>
    {
        public void Configure(EntityTypeBuilder<UserTutorials> builder)
        {
            builder.HasKey(e => e.Id).HasName("user_tutorials_pkey");

            builder.ToTable("user_tutorials");

            builder.Property(e => e.Id)
                .HasColumnName("user_tutorials_id")
                .ValueGeneratedOnAdd()
                .HasIdentityOptions(startValue: 1);

            builder.Property(e => e.TransactionType)
                .IsRequired()
                .HasColumnName("transaction_type");

            builder.Property(e => e.TransactionSubType)
                .IsRequired(false)
                .HasColumnName("transaction_sub_type");

            builder.Property(e => e.UserId)
                .IsRequired()
                .HasColumnName("user_id");

            builder.HasOne(e => e.User)
                .WithMany(e => e.UserTutorials)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("fk_user_tutorials_user")
                .IsRequired(false);

            builder.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("created_at");

            builder.Property(e => e.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP AT TIME ZONE 'UTC'")
                .HasColumnType("timestamp with time zone")
                .HasColumnName("updated_at");

            builder.Property(f => f.DeletedAt)
                .HasColumnType("timestamp with time zone")
                .HasColumnName("deleted_at");
        }
    }
}

```

### FILE: src\DXP.Core.Database.Infrastructure\Persistence\Configurations\Options\DbOptions.cs
```csharp
namespace DXP.Core.Database.Infrastructure.Persistence.Configurations.Options;

public class DbOptions
{
    public string ConnectionString { get; init; } = null!;
}

```

